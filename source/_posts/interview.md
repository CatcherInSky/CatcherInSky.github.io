---
title: 前端学习指南
categories:
- FrontEnd
tags:
- 学习指南
display:none
date: 2019/06/03 14:59:54
---
## 前言



<!--more-->

# 前端学习指南

---
# 前言

# 计算机通识

## 计算机组成原理

https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/_u4E0B_u8F7D.png)

## 计算机网络

## 操作系统

### 内存

栈内存中变量存储的是对象在堆内存中的地址

### 进程与线程

**进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位**。

以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

当我们启动一个应用，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作，这些线程可以共享这部分内存中的数据。如果应用关闭，进程会被终结，操作系统会释放相关内存。

一个进程还可以要求操作系统生成另一个进程来执行不同的任务，系统会为新的进程分配独立的内存，两个进程之间可以使用 IPC （Inter Process Communication）进行通信。很多应用都会采用这样的设计，如果一个工作进程反应迟钝，重启这个进程不会影响应用其它进程的工作。

**线程的那些资源共享，那些资源不共享**

**共享的资源有**

a. 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）

b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的

c. 静态变量虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的

d. 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。

**独享的资源有**

a. 栈 栈是独享的

b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC

#### 死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁的发生必须具备以下四个必要条件：

**1**）**互斥条件**：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

（打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造）

**2**）**请求和保持条件**：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

（打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源）

**3**）**不剥夺条件**：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

（打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请）

**4**）**环路等待条件**：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

（打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源）

## 编译原理

# 数学基础

## 离散数学

## 线性代数

# 数据结构与算法

## 数据结构

### 线性表
### 栈、队列
两个栈实现队列。
### 链表
插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）
### 树
层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）红黑树性质
### 堆
大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）
### 图
深度广度优先遍历、单源最短路径、最小生成树）
## 算法

### 查找
二分查找（一般会深入，如寻找数组总和为K的两个数字
### 排序
排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）
### 动态规划
### 贪心
### 分治

# 前端基础
## HTML5
H5新特性：
(1)Canvas绘图
(2)SVG绘图
(3)地理定位
(4)Web Worker
web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。
(5)Web Storage
1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）2.（兼容性差,数据8MB,操作简单）sessionStorage 3.localStorage 
(6)Web Socket
WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。
## CSS3
1.复杂的选择器
2.弹性布局
3.动画



dpr 

initial-scale

px rem

物理像素

## JavaScript

```text
const peopleConfig = Object.create(peopleConfigPrototype)
// 采用Object.create方法，当前对象将被复制到peopleConfig的__proto__上
```

还有另一种方式进行对象拷贝，但是会丢掉对象中的函数：

```text
const peopleConfig = JSON.parse(JSON.stringfy(peopleConfigProtytype))
```

**MVC，MVVM**就是非常典型的中介模式。

中介模式，桥接模式，代理模式的区别是：

**代理模式一对一，只能代理特定类和对象，是对其的扩展或是约束。**

**桥接模式一对多，是对类或对象成员或属性的扩展。**

**中介模式多对多，全权承包所有两个概念间的关系。**

https://zhuanlan.zhihu.com/p/43283016

设计模式

## ES6

## ES7+
## TypeScript
1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。
2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。
TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。
## Node.js
## 浏览器
## 数据库
### cookie/session/LocalStorage/SessionStorage
|cookie|session|LocalStorage|SessionStorage|
|--|--|--|--|
|||||
# 工程化
## 性能优化
## 安全
## 测试
## 管理
### Git
### Webpack
## 模块化组件化
|名称|	说明|	举例|
|--|--|--|
|JS模块|	独立的算法和数据单元|	浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元|
|CSS模块|	独立的功能性样式单元|	栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元|
|UI组件|	独立的可视/可交互功能单元|	页头(header)，页尾(footer)，导航栏(nav)，搜索框(search)|
|页面	|前端这种GUI软件的界面状态，是UI组件的容器|	首页(index)，列表页(list)，用户管理(user)|
|应用	|整个项目或整个站点被称之为应用，由多个页面组成||


# 框架
## React 
## Vue

## 设计模式
## 函数式编程

https://www.flyzy2005.cn/tech/net/https-ssl-tls/

https://github.com/CyC2018/CS-Notes