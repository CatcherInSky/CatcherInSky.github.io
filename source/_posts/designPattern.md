---
title: 前端常用设计模式
categories:
- designPattern
tags:
- FrontEnd

date: 2018/06/17 23:47:41
---
施工中……

<!--more-->

# 设计模式

软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。

## 什么是设计模式

### UML类图
·类图结构为<<abstract>>，表示为一个抽象类；
·继承类和抽象类之间的关系为实现关系，使用带空心箭头的虚线表示；
·继承类与实例之间是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；
·实例与实例部件之间是组合关系，使用带实心箭头的实线表示；
·实例与用户之间是一种依赖关系，使用带箭头的虚线表示；
·用户与用户群之间是聚合关系，使用带空心箭头的实线表示；
·用户与身份证明之间为关联关系，使用一根实线表示；


### 类之间的关系
#### 继承关系
实例->继承类->抽象类
    泛化  实现
#### 个体和集体的关系
聚合 弱依赖
组合 强依赖
#### 不同类对象之间关系
关联是静态强关联关系，描述不同类的对象之间的结构关系，对象常通过成员变量实现，
依赖是临时性关系，描述一个对象运行期间会要到另一个对象的关系，尽量单向依赖


### 时序图
时序图是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。

时序图（Sequence Diagram）包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。

### 六大设计原则
#### 1)单一职责原则
该原则是针对类来说的，即一个类应该只负责一项职责。
如类T负责两个不同职责：职责P1，职责P2。当职责P1需求变更而改变T时，可能造成职责P2发生故障，所以需要将类T的粒度分解为T1，T2。
遵循单一职责的优点：
    a)降低类的复杂度，一个类只负责一项职责。
    b)提高类的可读性，可维护性
    v)降低变更引起的风险。

#### 2)里氏替换原则

如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。
换句话说，所有引用基类的地方必须能透明地使用其子类的对象。

由定义可知，在使用继承时，遵循里氏替换原则，在子类中尽量不要重写和重载父类的方法。
继承包含这样一层含义：父类中凡是已经实现好的方法（相对抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。
继承作为面向对象三大特性之一，在给程序设计带来巨大遍历的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。

#### 3)依赖倒转原则
程序要依赖于抽象接口，不要依赖于具体实现。高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体，具体应该依赖于抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。
#### 4)接口隔离原则
客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。

#### 5)迪米特法则
一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。
设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。
#### 6)开闭原则
开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则都是实现开闭原则的一种手段。对于扩展是开放的，对于修改是关闭的，这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。



## 创建型模式
创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。
## 简单工厂模式
在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

简单工厂模式包含如下角色：
Factory：工厂角色
工厂角色负责实现创建所有实例的内部逻辑
Product：抽象产品角色
抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
ConcreteProduct：具体产品角色
具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
![SimpleFactory.jpg-32.6kB][1]
![seq_SimpleFactory.jpg-18.7kB][2]

### 模式分析
将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。
简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。
简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

### 简单工厂模式的优点
工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

### 简单工厂模式的缺点
由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

##  工厂方法模式
工厂方法模式包含如下角色：
Product：抽象产品
ConcreteProduct：具体产品
Factory：抽象工厂
ConcreteFactory：具体工厂



[1]: http://static.zybuluo.com/CatcherInSky/guvuzx93cvrbxp9vmpez6vjf/SimpleFactory.jpg
[2]: http://static.zybuluo.com/CatcherInSky/9wgr37vbhw7ukc6o9vj649o1/seq_SimpleFactory.jpg