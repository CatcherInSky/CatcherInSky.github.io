<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F12%2Flogin%2F</url>
    <content type="text"><![CDATA[JWT验证是如何工作的在我们开始之前，我们需要确定验证的流程看起来是什么样的： 用户使用POST（通过HTTS）传给服务器验证的细节：{ username, password } 服务器确定该用户是否是用户自己声称的身份 如果用户的验证尝试成功通过，接下来服务器发送某种形式的数据（一般是token或者session id），在接下来的每次请求中可以附加上这种数据，这样可以识别用户是否经过验证。 使用sessionless验证，客户端接收到的数据负载是JWT。JWT应该包含编码过的用户标识，它是后端服务器签名过的JSON格式。我们把JWT放到cookie中，因此不必在local-storage中储存它以免受到XSS攻击。以下是名为TheLegend27的用户使用JWT验证的流程： cookie是一种通过验证后随着每次请求一起发送的特殊头部。它还可以方便的跨过用户session实现持久化。这意味着TheLegend27登录成功后，他在之后的每一次请求中都将他的JWT一起发送。我们所要做的是验证他的身份，检查请求中的cookie并验证JWT。 需要注意的重要事项： 我们不在服务器跟踪用户的session！这是JWT验证和session验证的明显不同之处。使用sessionless验证我们就少了一个需要担心的数据源。 我们的验证流程超级简单！如果你只是想尽可能直观，快速的在Web应用中实现身份验证，那么JWT是不错的方案。 这就是使用JWT实现sessionless验证的原理。 HTTP Basic AuthHTTP Basic Auth 简单点说明就是每次请求 API 时都提供用户的 username 和 password，简言之，Basic Auth 是最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，尽量避免采用 HTTP Basic Auth。 OAuthOAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，QQ，微信)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容 OAuth2.0的流程： 这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用。 Cookie AuthCookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改 cookie 的 expiretime 使cookie在一定时间内有效。 Token Auth对于Token认证机制，简单来说，就是每次客户端输入账号密码后向服务端发起登录请求，服务端在通过登录验证后，给客户端返回一个任意字符串，既token（token必须与用户的账户关联，如用userid和token形成键值对，保存在内存中（redis））。客户端拿到这个token后，在之后所有需要验证登录的请求中，或者参数中带上token或者在header中携带token，然后服务端根据接收到的token来验证用户的登录状态是否存在，是否有效。 出于安全考虑，token在每次登录时重新生成，并可以设置有效期，每次有效操作后更新token的时间戳，保证token有效期往后延续。 为了避免token被截获，伪造非法请求，在每次请求时，可以用userid+token+时间戳+密钥+请求参数，进行签名，服务端验证token，同时验证签名，以保证请求的安全性。 Token Auth相对于Cookie机制的优点 支持跨域访问：Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输。 无状态(也称服务端可扩展行)：Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息。 更适用 CDN： 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可。 去耦：不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在验证登录的API被调用的时候，进行Token生成调用即可。 更适用于移动应用：当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 CSRF：因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 性能：一次网络往返时间（通过数据库查询session信息）总比做一次 HMACSHA256 计算 的Token验证和解析要费时得多。 不需要为登录页面做特殊处理：如果你使用Protractor做功能测试的时候，不再需要为登录页面做特殊处理。 基于标准化：你的API可以采用标准化的 JSON Web Token (JWT)，这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Typescript学习笔记]]></title>
    <url>%2F2019%2F06%2F12%2Ftypescript%2F</url>
    <content type="text"><![CDATA[Typescript的学习记录，更新中…… 基础类型、接口、泛型、类、函数、对象、声明 Typescript学习笔记基础类型布尔值、数字同JS 字符串字符串字面量类型用来约束取值只能是某几个字符串中的一个。 1234567type EventNames = &apos;click&apos; | &apos;scroll&apos; | &apos;mousemove&apos;;function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById(&apos;hello&apos;), &apos;scroll&apos;); // 没问题handleEvent(document.getElementById(&apos;world&apos;), &apos;dbclick&apos;);/ 报错，event 不能为 &apos;dbclick&apos; 元组Tuple表示已知元素数量和类型的数组 1234// Declare a tuple typelet x: [string, number];// Initialize itx = [&apos;hello&apos;, 10]; 当访问一个越界的元素，会使用联合类型替代： 123x[3] = &apos;world&apos;; // OK, 字符串可以赋值给(string | number)类型x[6] = true; // Error, 布尔不是(string | number)类型console.log(x[5].toString()); // OK, &apos;string&apos; 和 &apos;number&apos; 都有 toString 枚举enum自定义索引的数组，为一组数值赋予友好的名字。用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等 12345enum Color &#123;Red, Green, Blue&#125;// 从0开始，0,1,2；Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;enum Color &#123;Red = 1, Green, Blue&#125;// 从1开始，1,2,3；enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;// 1,2,4；let c: Color = Color.Green;//2let colorName: string = Color[2];//由枚举的值得到它的名字 Green 字符串枚举字符串枚举的概念很简单，但是有细微的运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 123456enum Direction &#123; Up = "UP", Down = "DOWN", Left = "LEFT", Right = "RIGHT",&#125; 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。 任意值any使用any类型来标记不希望被类型检查器检查而直接通过编译阶段检查的变量。 允许你在编译时可选择地包含或移除类型检查。 你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法 123456let notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn&apos;t check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property &apos;toFixed&apos; doesn&apos;t exist on type &apos;Object&apos;. 空值void 当一个函数没有返回值时，你通常会见到其返回值类型是void： 123function warnUser(): void &#123; console.log("This is my warning message");&#125; void类型的变量只能赋予为undefined和null： 1let unusable: void = undefined; Null 和 Undefined默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给number类型的变量。 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; Nevernever类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。 下面是一些返回never类型的函数： 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error("Something failed");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 联合类型123456789101112131415let myFavoriteNumber: string | number;Dinner要么有 fish 要么有 bear// 🙁 Not good.interface Dinner1 &#123; fish?: number, bear?: number,&#125;// 🙂 Awesome!type Dinner2 = &#123; fish: number,&#125; | &#123; bear: number,&#125; 映射类型12type Keys = &apos;option1&apos; | &apos;option2&apos;;type Flags = &#123; [K in Keys]: boolean &#125;; 等价于 1234type Flags = &#123; option1: boolean; option2: boolean;&#125; 类型断言类型断言好比其它语言里的类型转换，把变量当做断言的类型，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。类型断言不是类型转换，只能断言成一个联合类型或any中的类型。 类型断言有两种形式。 其一是“尖括号”语法： 12let someValue: any = "this is a string";let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： 12let someValue: any = "this is a string";let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 123let ro: ReadonlyArray&lt;number&gt; = a;a = ro; // error! Readonlya = ro as number[];// 用类型断言重写 查找类型123456789interface Person &#123; name: string; age: number; location: string;&#125;type K1 = keyof Person; // "name" | "age" | "location"type K2 = keyof Person[]; // "length" | "push" | "pop" | "concat" | ...type K3 = keyof &#123; [x: string]: Person &#125;; // string in keyofkeyof产生联合类型,in` 则可以遍历枚举类型 keyof 可以用来取得一个对象接口的所有 key值. 12345interface Foo &#123; name: string; age: number&#125;type T = keyof Foo // -&gt; "name" | "age" in 则可以遍历枚举类型, 例如 1234type Keys = "a" | "b"type Obj = &#123; [p in Keys]: any&#125; // -&gt; &#123; a: any, b: any &#125; typeof123const a: number = 3// 相当于: const b: number = 4const b: typeof a = 4 isconst 断言12const x = &apos;x&apos;; // has the type &apos;x&apos; let y = &apos;x&apos;; // has the type string 接口变量类型123456789101112131415161718interface LabeledValue&#123; label:string; model:string=&apos;&apos;;//默认“” color?:string;//可选属性 readonly width:number;//只读属性,赋值后不能被改变&#125;function printLabel(labeledObj: LabeledValue) &#123;//引入接口 console.log(labeledObj.label);&#125;let myObj = &#123;color: &quot;red&quot;, label: &quot;Size 10 Object&quot;, width: 10&#125;;printLabel(myObj);type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;//keyof T 拿到 T 所有属性名, 然后 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值.type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;//将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个+? , 这个含义自然与-?之前相反, 它是用来把属性变成可选项的. readonly vs const做为变量使用的话用const，若做为属性则使用readonly。 函数类型使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 1234567891011121314interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125;// 函数的参数名不需要与接口里定义的名字相匹配,只要求对应位置上的参数类型是兼容的//等价mySearch = function(source: string, subString: string): boolean &#123; let result = source.search(subString); return result &gt; -1;&#125; 可索引的类型Typescript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用100（一个number）去索引等同于使用&quot;100&quot;（一个string）去索引，因此两者需要保持一致。 对数组的约束123456interface StringArray &#123; [index: number]: string;//表示定义的数组是key是number类型，value是string类型&#125;let myArray: StringArray;myArray = ["Bob", "Fred"];let myStr: string = myArray[0];//Bob 对对象的约束123456789101112131415interface UserObj &#123; [index: string]: string&#125;var arr: UserObj = &#123; name: &apos;张三&apos; &#125;;interface Dictionary&lt;T&gt; &#123; [index: string]: T;&#125;;interface NumericDictionary&lt;T&gt; &#123; [index: number]: T;&#125;;const data:Dictionary&lt;number&gt; = &#123; a: 3, b: 4&#125; 类型接口强制一个类去符合某种契约。同时描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 继承一个接口可以继承多个接口，创建出多个接口的合成接口。 123456789interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125; 泛型泛型变量泛型就是：给类型传参 3个主要用途： 声明泛型容器或组件。比如：各种容器类Map、Array、Set等；各种组件，比如React.Component。 对类型进行约束。比如：使用extends约束传入参数符合某种特定结构。 生成新的类型。比如，上一章提到的ReturnType。 当使用 TypeScript 实现的时候，我们需要在执行前就定义好函数返回的类型，但是我们又不能确定这个对象到底是什么类型，这里就可以借助泛型来实现：这是一种使返回值的类型与传入参数的类型是相同的方法。 这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。 我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。 123456789function identity&lt;T&gt;(arg: T): T &#123;//1.声明泛型，2.参数泛型，3.返回值泛型 return arg;&#125;//事先不知道它是哪种类型，所以不能随意的操作它的属性或方法，表明泛型是个数组后可以使用.lengthfunction loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125; 多个类型参数定义泛型的时候，可以一次定义多个类型参数： 1234function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, &apos;seven&apos;]); // [&apos;seven&apos;, 7] 上例中，我们定义了一个 swap 函数，用来交换输入的元组。 索引访问操作符12345function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] &#123; return o[name]; // o[name] is of type T[K]&#125;getProperty(&#123;age:18&#125;, &apos;age&apos;)//K是T的key，T[K]是T的value 泛型约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 工具泛型Partial &amp; Pick将所有属性变成可选属性 12345678910111213141516//源码type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;;type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;;interface User &#123; id: number; age: number; name: string;&#125;;// 相当于: type PartialUser = &#123; id?: number; age?: number; name?: string; &#125;type PartialUser = Partial&lt;User&gt;// 相当于: type PickUser = &#123; id: number; age: number; &#125;type PickUser = Pick&lt;User, &quot;id&quot; | &quot;age&quot;&gt; RequiredRequired 的作用是将传入的属性变为必选项, 源码如下 1type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;; -?将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个+? ,把属性变成可选项的. Mutable (未包含)类似地, 其实还有对 + 和 -, 这里要说的不是变量的之间的进行加减而是对 readonly 进行加减.以下代码的作用就是将 T 的所有属性的 readonly 移除,你也可以写一个相反的出来. 123type Mutable&lt;T&gt; = &#123; -readonly [P in keyof T]: T[P]&#125; Readonly将传入的属性变为只读选项 1type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;; Record将 K 中所有的属性的值转化为 T 类型 1type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T &#125;; EEOExclude 接受两个类型，去除T中的U1234type Exclude&lt;T, U&gt; = T extends U ? never : T;// 相当于: type A = 'a'type A = Exclude&lt;'x' | 'a', 'x' | 'y' | 'z'&gt;Exclude&lt;'age'|'name','age'&gt; // 'name' Extract 同样接受两个类型，提取T中的U1Extract&lt;'age'|'name'|'height','age'|'weight'&gt; // 'age' Omit12345678type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;interface User &#123; id: number; age: number; name: string;&#125;;// 相当于: type PickUser = &#123; age: number; name: string; &#125;type OmitUser = Omit&lt;User, &quot;id&quot;&gt; ReturnType在阅读源码之前我们需要了解一下 infer 这个关键字, 在条件类型语句中, 我们可以用 infer 声明一个类型变量并且对它进行使用,我们可以用它获取函数的返回类型， 源码如下 12345type ReturnType&lt;T&gt; = T extends ( ...args: any[]) =&gt; infer R ? R : any; 其实这里的 infer R 就是声明一个变量来承载传入函数签名的返回值类型, 简单说就是用它取到函数返回值的类型方便之后使用.具体用法 1234function foo(x: number): Array&lt;number&gt; &#123; return [x];&#125;type fn = ReturnType&lt;typeof foo&gt;; AxiosReturnType (未包含)开发经常使用 axios 进行封装 API层 请求, 通常是一个函数返回一个 AxiosPromise&lt;Resp&gt;, 现在我想取到它的 Resp 类型, 根据上一个工具泛型的知识我们可以这样写. 12345import &#123; AxiosPromise &#125; from 'axios' // 导入接口type AxiosReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; AxiosPromise&lt;infer R&gt; ? R : any// 使用type Resp = AxiosReturnType&lt;Api&gt; // 泛型参数中传入你的 Api 请求函数 类公有私有TypeScript里，成员都默认为public。当成员被标记成private时，它就不能在声明它的类的外部访问。 TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有private或protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样一个private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于protected成员也使用这个规则。 123456class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(&quot;Cat&quot;).name; // 错误: &apos;name&apos; 是私有的. 受保护protectedprotected修饰符与private修饰符的行为很相似，但有一点不同，protected`成员在派生类中仍然可以访问 1234567891011121314151617181920class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 只读readonly你可以使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 函数函数的完整类型 12let myAdd: (x:number, y:number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确，参数名旁使用?实现可选参数。lastName = “Smith” 把last name的默认值设置为&quot;Smith&quot;。 在函数和返回值类型之前使用(=&gt;)符号，使之清晰明了。如果函数没有返回任何值，也必须指定返回值类型为void而不能留空。 this匿名函数this12345678910111213141516171819202122interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123;//不指定this为any return () =&gt; &#123; //箭头函数能保存函数创建时的`this`值，而不是调用时的值。这里是Deck；如果是function()&#123; this 往往报错，为window或undefined let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125; 回调函数this当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的this会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，this将为undefined。 稍做改动，你就可以通过this参数来避免错误。 首先，库函数的作者要指定this的类型： 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void意味着addClickListener期望onclick是一个函数且它不需要一个this类型。 然后，为调用代码里的this添加类型注解： 123456789class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used this here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! 指定了this类型后，你显式声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到addClickListener要求函数带有this: void。 改变this类型来修复这个错误： 123456789class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use this here because it's of type void! console.log('clicked!'); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); 因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用this.info. 如果你两者都想要，你不得不使用箭头函数了： 1234class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message &#125;&#125; 这是可行的因为箭头函数使用外层的this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到Handler的原型链上。 它们在不同Handler对象间是共享的。 重载同一个函数提供多个函数类型定义来进行函数重载 对象对象的展开与剩余运算符TypeScript 2.1 带来了对 ES2017 展开与剩余运算符的支持. 和数组的展开类似, 展开一个对象可以很方便地获得它的浅拷贝: 1let copy = &#123; ...original &#125;; 相似的, 你可以合并多个不同的对象. 在下面的例子中, merged 会有来自 foo, bar 和 baz 的属性. 1let merged = &#123; ...foo, ...bar, ...baz &#125;; 你也可以覆盖已有的属性和添加新的属性: 12let obj = &#123; x: 1, y: "string" &#125;;var newObj = &#123;...obj, z: 3, y: 4&#125;; // &#123; x: number, y: number, z: number &#125; 指定展开操作的顺序决定了那些属性的值会留在创建的对象里; 在靠后的展开中出现的属性会 “战胜” 之前创建的属性. 对象的剩余操作和对象的展开是对应的, 这样一来我们可以导出解构一个元素时被漏掉的其他属性. 123let obj = &#123; x: 1, y: 1, z: 1 &#125;;let &#123; z, ...obj1 &#125; = obj;obj1; // &#123;x: number, y: number&#125;; 声明http://json.schemastore.org/tsconfig https://legacy.gitbook.com/book/zhongsp/typescript-handbook/details http://www.typescriptlang.org/ https://ts.xcatliu.com/ https://zhuanlan.zhihu.com/p/24267683 https://zhuanlan.zhihu.com/p/58517848 https://zhuanlan.zhihu.com/p/66624970 https://zhuanlan.zhihu.com/p/39620591 https://zhuanlan.zhihu.com/p/64423022 https://zhuanlan.zhihu.com/p/40311981]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南_浏览器]]></title>
    <url>%2F2019%2F06%2F03%2Finterview_browser%2F</url>
    <content type="text"><![CDATA[前端知识中涉及浏览器的部分、包括浏览器内核、工作原理、存储等 前端学习指南_浏览器浏览器组成主流浏览器：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera浏览器的主要组件为： 用户界面 - 除了浏览器主窗口显示的页面外，其他的部分，包括地址栏、前进/后退按钮、书签菜单等。 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。 渲染引擎 - 负责显示请求的内容，负责解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。Firefox-Gecko，Safari和Chrome-WebKit 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。内核 浏览器 渲染引擎 JS解释器 Chrome WebKit-&gt;Blink(2013)、 V8 Firefox Gecko SpiderMonkey Safari Webkit Nitro Edge EdgeHTML-&gt;Chromium(Blink) Chakra Opera Presto-&gt;Blink V8 IE Trident Chakra 其他浏览器360浏览器、猎豹浏览器内核：IE+Chrome双内核； 搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； 百度浏览器、世界之窗内核：IE内核； 2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了； UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。 事件循环浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务。 综合输入URL判断 协议 缓存 输入的是 URL 还是 query域名解析DNS 查询：顺序浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;运营商缓存-&gt;域名递归搜索 建立连接HTTPS TCP三握四挥 发送请求 接受响应 渲染页面 渲染1.加载 当请求响应返回的时候，network thread 会依据 Content-Type及 MIME Type sniffing 判断响应内容的格式 加载过程贼复杂，需要加载各种资源，比如html、css、js或者pdf等等。这里又可以分成两种情况，一种是内容加载，比如需要打开一个新进程、需要打开保存弹窗或者需要直接加载内容；另一种则是子资源下载，比如css、js、图片等等，这里又会涉及到缓存，选择本地读取还是去服务器请求等等一系列的问题。 如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程 2.解析 解析过程就就是解析上面加载的文件（HTML），建立DOM树的过程， 除了解析HTML生成DOM树，为了提高性能，一般浏览器都会做一些预处理动作，比如：DNS预获取、预加载扫描以及安全扫描(防XSS)等等。 DNS的预获取在前面就顺带提到了，预获取过程就在这里发生的。大家可以回到1688首页可以看到如下一段代码片：12345678&lt;!--dns预解析--&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cbu01.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//astyle-src.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//g.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//dcms.1688.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//gm.mmstat.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//log.mmstat.com&quot; /&gt; 这段代码片没有任何逻辑功能，唯一的作用就是主动告诉浏览器，赶紧去请求解析这些域名，我马上要用了，这样可以极大地缩减dns的解析时间。有人可能怀疑，放在头部，难道不会阻塞页面加载？实际上并不会，查了一下Chrome的文档，这玩意甚至都没有用浏览器的网络栈。Chrome会启动8个异步线程，啥都不干，就蹲在那里等浏览器给他丢任务（队列），然后去找操作系统要解析，这个过程唯一的作用就是提前触发DNS解析，后面再来的时候就直接走缓存了，实际上这8个线程只是下个任务罢了。除了上面这种写法来触发DNS的预获取，实际浏览器还会搞个线程去扫描html文件，看到域名以后也会丢给上面那8个线程。 3.构建DOM树 DOM本身没有任何渲染能力，我们渲染的也不是DOM。webkit会为DOM树建立一堆渲染树，这些渲染树再用于渲染。 渲染树是归属于DOM树的。渲染树是只存在于上下文中，上下文结束，树销毁；下次再次渲染，再新建一个渲染树。渲染树包含了渲染需要的一切信息。渲染树的节点会有不同种类，下面是几种常见的（都是从一个基类继承出来的），这些类都有自己的渲染方法，你只需要告诉它，该你出场了，他们自己就有方法去把自己画好解析html，生成一个DOM树，解析过程中遇到了script标签就会执行，注意的是，执行js会阻塞DOM的解析，这也是为什么都提倡把不重要的代码放到body的最后面来执行。 如果有些代码确实需要放在靠前的位置，可以写考虑写成异步的方式来避免阻塞页面渲染。新浏览器一般都支持了defer和async属性，其中defer属性的script的下载不会阻塞html解析，而且其会在解析完成后才执行；async属性则是下载不会阻塞html解析，但是执行还是会阻塞。这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 4.加载次级的资源网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 &lt;img&gt; &lt;link&gt; 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。 5.样式计算进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式 6.获取布局 想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下： 通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 display:none ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。 7.绘制各元素浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建 Rendering Tree即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。 8.合成帧最终通过调用Native GUI 的 API 绘制网页画面，称为 Paint复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成。主线程会遍历布局树来创建层树（layer tree），添加了 will-change CSS 属性的元素，会被看做单独的一层， z-index 9.事件处理 在构建Rendering Tree的同时，生成Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。件委托，基于事件冒泡，我们常常在最顶层绑定事件： 12345document.body.addEventListener(&apos;touchstart&apos;, event =&gt; &#123; if (event.target === area) &#123; event.preventDefault(); &#125;&#125;); 事件分法deligation Repaint当元素改变的时候，将不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为 Repaint。 重绘:当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。 Reflow当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。（ HTML 使用的是 flow based layout ，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 Reflow。） 回流:当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建回流必定会发生重绘，重绘不一定会引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 1）常见引起回流属性和方法任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流， 添加或者删除可见的DOM元素；元素尺寸改变——边距、填充、边框、宽度和高度内容变化，比如用户在input框中输入文字浏览器窗口尺寸改变——resize事件发生时计算 offsetWidth 和 offsetHeight 属性设置 style 属性的值 重排width height margin padding display border position overflow clientWidth/Height/Top/Left offsetWidth/Height/Top/Left scrollWidth/Height/Top/Left scrollIntoView ScrollTo scrollIntoViewIfNeeded getComputedStyle getBoundingClientRect 重绘color border-style viisbilitybackground text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size 不同的浏览器对于CSS和HTML的处理方式不同如果有的浏览器的渲染引擎是需要等待CSS加载完成之后，对HTML元素进行渲染和展示的，那么在CSS加载完成之前，页面上不有任何信息，这种现象称为白屏（谷歌Chrome和苹果Safari）而有的是先对HTML元素进行展示，然后等待CSS加载完成之后重新对样式进行修改，那么在CSS加载完之前，会首先在页面上显示没有任何CSS渲染的信息，这种现象称为FOUC(无样式内容闪烁)（IE和Firefox火狐） 问题四：为什么操作 DOM 慢因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。 问题五：渲染页面时常见哪些不良现象？由于浏览器的渲染机制不同，在渲染页面时会出现两种常见的不良现象—-白屏问题和FOUS（无样式内容闪烁） FOUC：由于浏览器渲染机制（比如firefox），再CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象； 白屏：有些浏览器渲染机制（比如chrome）要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把js文件放在头部，脚本会阻塞后面内容的呈现，脚本会阻塞其后组件的下载，出现白屏问题。 白屏和FOUC现象 不同的浏览器对于CSS和HTML的处理方式不同 如果有的浏览器的渲染引擎是需要等待CSS加载完成之后，对HTML元素进行渲染和展示的，那么在CSS加载完成之前，页面上不有任何信息，这种现象称为白屏（谷歌Chrome和苹果Safari） 而有的是先对HTML元素进行展示，然后等待CSS加载完成之后重新对样式进行修改，那么在CSS加载完之前，会首先在页面上显示没有任何CSS渲染的信息，这种现象称为FOUC(无样式内容闪烁)（IE和Firefox火狐） 工作原理 渲染API存储一、Cookie1. Cookie的来源Cookie 的本职工作并非本地存储，而是“维持状态”。 因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。 我们可以把Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。 在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。 2. 什么是Cookie及应用场景Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。 如上图所示，Cookie 以键值对的形式存在。 典型的应用场景有： 记住密码，下次自动登录。 购物车功能。 记录用户浏览数据，进行商品（广告）推荐。 3. Cookie的原理及生成方式Cookie的原理 第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。 Cookie的生成方式主要有两种： 生成方式一：http response header中的set-cookie 我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;//可以指定一个特定的过期时间（Expires）或有效期（Max-Age） 当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。 内存cookie，是指没有设在cookie的Expires的属性，此时cookie将停留在客户端的内存中，只有在该IE窗口中从“文件－新建－ 窗口”打开的新的IE窗和由form的target属性为_blank产生的新的IE窗口才共享同一个cookie信息。IE，Chome的选项卡都共享同一个cookie信息。 硬盘cookie，是指在你设置了cookie的Expires属性，此时cookie将保存到你的硬盘上。此时所有的窗口将共享同一个名字的cookie。 生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示 例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome 的 Application 面板查看生成的cookie: 123document.cookie="userName=hello"document.cookie="gender=male"document.cookie='age=20;domain=.baidu.com' 从上图中我们可以得出： Domain 标识指定了哪些域名可以接受Cookie。如果没有设置domain，就会自动绑定到执行语句的当前域。 如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。 4. Cookie的缺陷 Cookie 不够大 Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。 这里需注意：各浏览器的cookie每一个name=value的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。 过多的 Cookie 会带来巨大的性能浪费 Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。 cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。 5. Cookie与安全对于 cookie 来说，我们还需要注意安全性。 HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie， 所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。 HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。 LocalStorage 是一种本地存储的公共资源，域名下很多应用共享这份资源会有风险；LocalStorage 是以页面域名划分的，如果有多个等价域名之间的 LocalStorage 不互通，则会造成缓存多份浪费。 LocalStorage 在 PC 上的兼容性不太好，而且当网络速度快、协商缓存响应快时使用 localStorage 的速度比不上 304。并且不能缓存 css 文件。而移动端由于网速慢，使用 localStorage 要快于 304。 而相对 LocalStorage 来说，SessionStorage 的数据只存储到特定的会话中，不属于持久化的存储，所以关闭浏览器会清除数据。和 localstorage 具有相同的方法。 二、Web Storage API在HTML5中添加的在本地存储数据的新选项，从cookie用于保存客户端与服务器通信，但Web Storage API用于保存比cookie更大的客户端数据 1）LocalStorage1. LocalStorage的特点 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 多选项卡之间同步数据 基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。 2.存入/读取数据localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。 1localStorage.setItem("key","value"); 读取数据使用getItem方法。它只有一个参数，就是键名。 1var valueLocal = localStorage.getItem("key"); 具体步骤，请看下面的例子： 1234567891011121314151617181920212223&lt;script&gt; if(window.localStorage)&#123; localStorage.setItem（'name','world'） localStorage.setItem（“gender','famale'） &#125;&lt;/script&gt;&lt;body&gt; &lt;div id="name"&gt;&lt;/div&gt; &lt;div id="gender"&gt;&lt;/div&gt; &lt;script&gt; var name = localStorage.getItem("name"); var gender = localStorage.getItem("gender"); document.getElementById("name").innerHTML = name; document.getElementById("gender").innerHTML = gender; &lt;/script&gt;&lt;/body&gt;&lt;script&gt; window.adddEventListener('storage',()=&gt;&#123; console.log('local storage has been updated') &#125;) //支持度可能不够&lt;/script&gt; 3. 使用场景LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。 这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串： 除非适应localStorage.removeItem(‘key’)删除单个键值对，或localStorage.clear()清除所有数据 2）sessionStoragesessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。 1.sessionStorage的特点 会话级别的浏览器存储 大小为5M左右 仅在客户端使用，不和服务端进行通信 接口封装较好 基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。 2. 使用场景sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage就主要是存储你本次会话的浏览足迹： lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 sessionStorage 来处理再合适不过。 3.sessionStorage 、localStorage 和 cookie 之间的区别 共同点：都是保存在浏览器端，且都遵循同源策略。 不同点：在于生命周期与作用域的不同 作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下 生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。 Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。 说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！ 四、Session会话，服务器就要给每个客户端分配不同的“身份标识”。 Session是一种记录客户状态的机制，不同于Cookie的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。 客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。 如果说Cookie机制是通过检查客户身上的”通行证”来确定客户身份的话， 那么Session机制就是通过检查服务器上的”客户明细表”来确认客户身份。 Session相当于程序在服务器上建立的一份客户档案， 客户来访的时候只需要查询客户档案表就可以了。 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 Session机制一方面，我们可以把客户端浏览器与服务器之间一系列交互的动作称为一个 Session。 从这个语义出发，我们会提到Session持续的时间，会提到在Session过程中进行了什么操作等等。 另一方面，Session指的是服务器端为客户端所开辟的存储空间，该空间保存的信息就是用于保持状态。 从这个语义出发，我们则会提到往Session中存放什么内容，如何根据键值从Session中获取匹配的内容等。 要使用Session，当然是先要创建Session。那么Session在何时创建呢？ Session在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法， 在Java中是通过调用HttpServletRequest的getSession方法(使用true作为参数)创建的。 创建Session的同时，服务器会为该Session生成唯一的session id， 这个session id在随后的请求中会被用来重新获得已经创建的Session Session被创建之后，就可以调用Session相关的方法往Session中增加内容了， 而这些内容只会保存在服务器中，发到客户端的只有session id 当客户端再次发送请求的时候，会将这个session id带上， 服务器接受到请求之后就会依据session id找到相应的Session，从而再次使用Session。 Session的生命周期Session保存在服务器端。为了获得更高的存取速度，服务器一般把Session放在内存中。 每个用户都会有一个独立的Session。 如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。 因此，Session里的信息应该尽量精简。 Session在用户第一次访问服务器的时候自动创建。 需要注意只有访问JSP、Servlet等程序时才会创建Session， 只访问HTML、IMAGE等静态资源并不会创建Session。 如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。 Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。 用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session”活跃(active)”了一次。 1session的生命周期当一个Session开始时，Servlet容器会创建一个HttpSession对象，那么在HttpSession对象中，可以存放用户状态的信息。Servlet容器为HttpSession对象分配一个唯一标识符即Sessionid，Servlet容器把Sessionid作为一种Cookie保存在客户端的 *浏览器* 中。 ​ 用户每次发出Http请求时，Servlet容器会从HttpServletRequest对象中取出Sessionid,然后根据这个Sessionid找到相应的HttpSession对象，从而获取用户的状态信息。 我们知道Session是存在于服务器端的，当把浏览器关闭时，浏览器并没有向服务器发送任何请求来关闭Session，自然Session也不会被销毁，但是可以做一点努力，在所有的客户端页面里使用js的window.onclose来监视浏览器的关闭动作，然后向服务器发送一个请求来关闭Session，但是这种做法在实际的开发中也是不推荐使用的，最正常的办法就是不去管它，让它等到默认的时间后，自动销毁。那么为什么当我们关闭浏览器后，就再也访问不到之前的session了呢？其实之前的Session一直都在服务器端，而当我们关闭浏览器时，此时的Cookie是存在于浏览器的进程中的，当浏览器关闭时，Cookie也就不存在了。 其实Cookie有两种: 一种是存在于浏览器的进程中; 一种是存在于硬盘上 而session的Cookie是存在于浏览器的进程中，那么这种Cookie我们称为会话Cookie，当我们重新打开浏览器窗口时，之前的Cookie中存放的Sessionid已经不存在了，此时服务器从HttpServletRequest对象中没有检查到sessionid，服务器会再发送一个新的存有Sessionid的Cookie到客户端的浏览器中，此时对应的是一个新的会话，而服务器上原先的session等到它的默认时间到之后，便会自动销毁。 当在同一个浏览器中同时打开多个标签，发送同一个请求或不同的请求，仍是同一个session; ​ 当不在同一个窗口中打开相同的浏览器时，发送请求，仍是同一个session; ​ 当使用不同的浏览器时，发送请求，即使发送相同的请求，是不同的session; ​ 当把当前某个浏览器的窗口全关闭，再打开，发起相同的请求时，就是本文所阐述的，是不同的session,但是它和session的生命周期是没有关系的. Session的有效期由于会有越来越多的用户访问服务器，因此Session也会越来越多。 为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。 这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。 Session的超时时间为maxInactiveInterval属性， 可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(longinterval)修改。 Session的超时时间也可以在web.xml中修改。 另外，通过调用Session的invalidate()方法可以使Session失效。 Cookie和Session的的区别 HTTP协议是无状态的协议，服务端需要记录用户的状态，就需要用某种机制来识别具体的用户，这个机制就是Session。 Session典型的应用场景就是购物车，当点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的， 所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面的商品情况。 这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。 集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群， 用来保存用户会话，这个时候 Session 信息都是放在内存的，此外，一些缓存服务比如Memcached之类的来放 Session。 服务端使用Cookie来识别特定的客户。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。 实际上大多数的应用都是用 Cookie 来实现Session跟踪的， 第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个session id， 以后每次请求把这个 session id发送到服务器，这样就可以使用对应的Seesion了。 如果客户端的浏览器禁用了 Cookie 怎么办？ 一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪， 即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下， 设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？ 这个信息可以写到Cookie里面，访问网站的时候， 网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了， 能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。 五、Token在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。 以下几点特性会让你在程序中使用基于Token的身份验证 无状态、可扩展 支持移动设备 跨程序调用 安全 那些使用基于Token的身份验证的大佬们 大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。 用户输入登陆凭据； 基于服务器的验证我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。 随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。 基于服务器验证方式暴露的一些问题 Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。 可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。 CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。 在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。 基于Token的验证原理基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。 这种概念解决了在服务端存储信息时的许多问题 NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。 基于Token的身份验证的过程如下: 用户通过用户名和密码发送请求。 程序验证。 程序返回一个签名的token 给客户端。 客户端储存token,并且每次用于每次发送请求。 服务端验证token并返回数据。 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。 需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。 实现思路： 用户登录校验，校验成功后就返回Token给客户端。 客户端收到数据后保存在客户端 客户端每次访问API是携带Token到服务器端。 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码 当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。 我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token） Tokens的优势无状态、可扩展 在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。 如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。 但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。 安全性 请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。 可扩展性 Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。 使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。 多平台跨域 我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。 Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application. 只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。 1Access-Control-Allow-Origin: * 基于标准创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。 最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。 对比CookieCookies验证是有状态（stateful）的。这意味着，权限信息（比如session ID）必须同时在客户端和服务端维护。服务端需要根据session cookies信息去数据库查询用户相关信息；客户端每次发起请求时都必须带上Cookies信息作为身份验证。 特征： 1.不需要前端存储Cookies由后台设置（response header里的Set-Cookie），浏览器会在后续的请求中自动加上Cookies信息。有CSRF(跨站点伪造请求)风险 2.Cookies是不支持跨域访问的，一般只能在某个域名及其子域名下被访问。但是，由于Cookies可以通过JS代码获取（document.cookies），由此，可能会引发安全问题，比如著名的CSRF攻击（跨站请求伪造）。 3.移动端用在使用cookie时有各种不便利和局限 4.移动端平台和Cookies配合并不是太好，可能会在Cookies使用上有局限性。 5.Cookies可以在同一域名下或者同一主域不同子域下共享，一旦跨主域，就无法共享 如果遇到跨域共享身份信息的情况，就必须靠服务器协助（例如单点登录：一个身份，需要登录多个主域） 身份验证1.用户输入登陆凭据； 2.服务器验证凭据是否正确，并创建会话，然后把会话数据存储在数据库中； 3.具有会话id的cookie被放置在用户浏览器中； 4.服务器验证凭据是否正确，并创建会话； 5.在后续请求中，服务器会根据数据库验证会话id，如果验证通过，则继续处理； 6.一旦用户登出，服务端和客户端同时销毁该会话在后续请求中，服务器会根据数据库验证会话id，如果验证通过，则继续处理； TokenToken是无状态的（stateless）。也就是说，服务端不需要在数据库中存储和Token相关的字段，Token本身就已经包含了用户的所有信息 客户端一般在request header里面利用Authorization头传递Token值，格式为Bearer {JWT}（该格式并不是绝对的，要根据服务端具体情况来设置）。 特征： 1.Token值同样需要服务端提供（通过API返回）和Cookies不同，返回值不需要挂载在Set-Cookie上，而是利用其它response header或者response body返回Token值； 2.需要客户端存储和Cookies不同，浏览器无法自动在下一次请求中自动挂载身份信息。客户端必须自行存储Token值（建议用localstorage），然后在后续请求中通过设置request header来传递Token信息； 3.无CSRF风险适合移动端身份认证 4.Token支持各类跨域 身份验证 1.服务器验证凭据是否正确，然后返回一个经过签名的token； 2.客户端负责存储token，可以存在localstorage，或者cookie中 3.对服务器的请求带上这个token； 4.服务器对JWT进行解码，如果token有效，则处理该请求； 5.一旦用户登出，客户端销毁token。 四、IndexDB浏览器内置数据库系统，用于储存大量结构化数据 五、Cache API最初为 service workers 创建，用于缓存网络请求，API公开了window.caches,允许保存可永远以后访问的Requests和Responses对 缓存缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1. Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 2. Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存 内存缓存中有一块重要的缓存资源是preloader相关指令（例如&lt;link rel=&quot;prefetch&quot;&gt;）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。 3. Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先 当前系统内存使用率高的话，文件优先存储进硬盘 4. Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差 可以推送 no-cache 和 no-store 的资源 一旦连接被关闭，Push Cache 就被释放 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。 Push Cache 中的缓存只能被使用一次 浏览器可以拒绝接受已经存在的资源推送 你可以给其他域名推送资源 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 缓存过程分析浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。 https://www.cnblogs.com/lyzg/p/5125934.html#_label2 强缓存强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 1. Expires缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。 2.Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。 Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令： public：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。 private：所有内容只有客户端可以缓存，Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。需要注意的是，no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效 s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。 max-stale：能容忍的最大过期时间。max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。 min-fresh：能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。 3.Expires和Cache-Control两者对比其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存失效，返回200和请求结果 协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 1.Last-Modified和If-Modified-Since浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header； 1Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200 但是 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag和If-None-Match 2. ETag和If-None-MatchEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 3. 两者之间对比： 首先在精确度上，Etag要优于Last-Modified。 Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 缓存机制强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下： 看到这里，不知道你是否存在这样一个疑问:如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 实际场景应用缓存策略1. 频繁变动的资源 Cache-Control: no-cache 对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。 2. 不常变化的资源 Cache-Control: max-age=31536000 通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。 用户行为对浏览器缓存的影响所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种： 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。 Service WorkerService workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 服务工作线程概念和用法节Service worker是一个注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。 Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。 出于安全考量，Service workers只能由HTTPS承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险。在Firefox浏览器的用户隐私模式，Service Worker不可用。 使用 ServiceWorkerContainer.register() 方法首次注册service worker。如果注册成功，service worker就会被下载到客户端并尝试安装或激活（见下文），这将作用于整个域内用户可访问的URL，或者其特定子集。 下载、安装和激活此时，你的服务工作者(service worker)将遵守以下生命周期： 下载 安装 激活 用户首次访问service worker控制的网站或页面时，service worker会立刻被下载。 之后至少每24小时它会被下载一次。它可能被更频繁地下载，不过每24小时一定会被下载一次，以避免不良脚本长时间生效。 Service workers也可以用来做这些事情： 后台数据同步 响应来自其它源的资源请求 集中接收计算成本高的数据更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据 在客户端进行CoffeeScript，LESS，CJS/AMD等模块编译和依赖管理（用于开发目的） 后台服务钩子 自定义模板用于特定URL模式 性能增强，比如预取用户可能需要的资源，比如相册中的后面数张图片 未来service workers能够用来做更多使web平台接近原生应用的事。 值得关注的是，其他标准也能并且将会使用service worker，例如: 后台同步：启动一个service worker即使没有用户访问特定站点，也可以更新缓存 响应推送：启动一个service worker向用户发送一条信息通知新的内容可用 对时间或日期作出响应 进入地理围栏 https://zhuanlan.zhihu.com/p/47407398https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/ https://zhuanlan.zhihu.com/p/54314093 https://zhuanlan.zhihu.com/p/61704951 https://zhuanlan.zhihu.com/p/62168010]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>学习指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用CSS画一只电老鼠]]></title>
    <url>%2F2019%2F05%2F12%2Fpikachu%2F</url>
    <content type="text"><![CDATA[不知道大家有没有去看大侦探皮卡丘呀，有没有被银幕上毛茸茸的电老鼠萌到呢？现在我就来用CSS画一只简易版的皮卡丘吧。（希望不会收到东半球最强法务部的律师函） 12345678910111213141516171819&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;div class=&quot;ear left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ear right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;eye left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;eye right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mouth&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;ball&quot;&gt; &lt;div class=&quot;belt&quot;&gt; &lt;div class=&quot;lock&quot;&gt; &lt;div class=&quot;but&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;light&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177body&#123; display: flex; justify-content: center; align-items: center; min-height: 100vh; &#125;.main&#123; position: relative;&#125;.ear.left&#123; background: #ffe000; width:40px; height:90px; position: absolute; top:-44px; left:0; border-radius: 20px 20px 20px 20px/70px 070px 20px 20px; transform: rotate(-30deg); display: flex; justify-content: center; overflow: hidden;&#125;.ear.left::after&#123; content: &quot;&quot;; display: block; width:30px; height:20px; background: #4E4700; border-radius: 15px 15px 20px 20px/70px 70px 20px 20px;&#125;.ear.right&#123; background:#ffe000; width:40px; height:90px; position: absolute; top:-44px; right:0; border-radius: 20px 20px 20px 20px/70px 070px 20px 20px; transform: rotate(35deg); display: flex; justify-content: center; overflow: hidden;&#125;.ear.right::after&#123; content: &quot;&quot;; display: block; width:30px; height:20px; background: #4E4700; border-radius: 15px 15px 20px 20px/70px 70px 20px 20px;&#125;.eye&#123; background: #4E4700; width: 23px; height: 23px; border-radius: 23px;&#125;.eye.left&#123; position: absolute; left:38px; top:44px;&#125;.eye.right&#123; position: absolute; right:38px; top:44px;&#125;.mouth::before&#123; content: &apos;&apos;; display: block; width: 10px; height: 10px; border: 3px solid #4E4700; border-top:none; border-right: none; border-bottom-left-radius: 10px ; transform: rotateZ(-23deg); position: absolute; top:60px; left:86px;&#125;.mouth::after&#123; content: &apos;&apos;; display: block; width: 10px; height: 10px; border: 3px solid #4E4700; border-top: none; border-left: none; border-bottom-right-radius: 10px; transform: rotateZ(23deg); position: absolute; top:60px; right:86px;&#125;.head&#123; border-radius: 200px 200px 0 0; width:200px; height:100px; background:#ffe000;&#125;.face&#123; background:#FF9900; width:30px; height: 30px; border-radius: 30px; &#125;.face.left&#123; position: absolute; left:18px; bottom:101px;;&#125;.face.right&#123; position: absolute; right:18px; bottom:101px;&#125;.ball&#123; border-radius:0 0 200px 200px; width:200px; height:100px; background:#FF0000;&#125;.belt&#123; width:200px; height:15px; background:#322221; border-radius:0 0 2px 2px/0 0 15px 15px; display: flex; justify-content: center;&#125;.lock&#123; border-radius: 0 0 80px 80px; width:80px; height:40px; background:#322221;&#125;.lock::after&#123; content: &quot;&quot;; display:block; border-radius: 0 0 60px 60px; width:60px; height:30px; background:#FDFDFD; transform: translateX(10px);&#125;.but&#123; content: &quot;&quot;; display:block; border-radius: 0 0 40px 40px; width:40px; height:20px; background:#322221; transform: translateX(20px); position: absolute; z-index: 10;&#125;.but::after&#123; content: &quot;&quot;; display:block; border-radius: 0 0 20px 20px; width:20px; height:10px; background:#686160; transform: translateX(10px);&#125;.light&#123; background:#FFD7C9; width: 20px; height: 27px; border-radius: 10px 10px 10px 10px/15px 15px 10px 10px; position: absolute; top:150px; left:150px; transform: rotate(45deg);&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode做题记录]]></title>
    <url>%2F2019%2F05%2F03%2FLeetCode%2F</url>
    <content type="text"><![CDATA[个人LeetCode记录，持续更新中…… 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 1234567891011var twoSum = function(nums, target) &#123; let arr = [],length = nums.length; for(let i = 0;i&lt;length;++i)&#123; let temp = target - nums[i]; if(arr[temp]!=undefined)&#123; return [nums.indexOf(temp),i] &#125;else&#123; arr[nums[i]]=nums[i] &#125; &#125;&#125;; 哈希表的方法，用空间换时间，用数组的结构，要用indexOf查询下标，耗时 执行用时 :104 ms, 在所有 JavaScript 提交中击败了72.39%的用户 内存消耗 :34.5 MB, 在所有 JavaScript 提交中击败了72.79%的用户 1234567891011121314151617var twoSum = function(nums, target) &#123; let length = nums.length; let arr = new Object() for(let i = 0;i&lt;length;++i)&#123; let temp = target - nums[i]; if(arr.hasOwnProperty(temp))&#123; return [arr[temp],i] &#125;else&#123; Object.defineProperty(arr,nums[i],&#123; value : i, writable : true, enumerable : true, configurable : true &#125;) &#125; &#125;&#125;; 哈希表的方法，用空间换时间，用对象的方法，空间稍大但时间优化近20% 执行用时 :84 ms, 在所有 JavaScript 提交中击败了84.29%的用户 内存消耗 :36.3 MB, 在所有 JavaScript 提交中击败了7.49%的用户 2. 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 1234567891011121314151617181920var addTwoNumbers = function(l1, l2) &#123; let temp = 0;let p=l1,q=l2; while(q!=null)&#123; if(p.next==null&amp;&amp;q.next!=null)&#123; p.next = new ListNode(0); &#125; if(q.next==null&amp;&amp;p.next!=null)&#123; q.next = new ListNode(0); &#125; let sumAll = temp + p.val + q.val; p.val = sumAll % 10; temp = Math.floor(sumAll / 10); if(p.next == null &amp;&amp; q.next == null &amp;&amp; temp!=0)&#123; p.next = new ListNode(temp); &#125; p=p.next q=q.next &#125; return l1&#125;; 浅拷贝保存引用，操作p和q 执行用时 :172 ms, 在所有 JavaScript 提交中击败了78.18%的用户 内存消耗 :38.3 MB, 在所有 JavaScript 提交中击败了68.50%的用户 3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 12345678910111213141516171819202122var lengthOfLongestSubstring = function(s) &#123; let arr =new Array(); let j=0; arr[j]=new Array(); for(let i = 0;i&lt;s.length;++i)&#123; let k = arr[j].indexOf(s.charAt(i)) if(k==-1)&#123; arr[j].push(s.charAt(i)) &#125;else&#123; j++ arr[j]=new Array() arr[j]=arr[j-1].slice(k+1) arr[j-1]=arr[j-1].length arr[j].push(s.charAt(i)) &#125; &#125; arr[j]=arr[j].length arr.sort((a,b)=&gt;&#123; return b-a &#125;) return arr[0]&#125;; 开一个二维数组储存每段不重复子串，新开一个元素就把上一个元素转换成具体长度，排序求解 执行用时 :140 ms, 在所有 JavaScript 提交中击败了56.06%的用户 内存消耗 :43 MB, 在所有 JavaScript 提交中击败了13.45%的用户 12345678910111213141516var lengthOfLongestSubstring = function(s) &#123; if(s.length==0)&#123; return 0 &#125; let obj = &#123;&#125;,ans = 0,start=0; for(let i =0;i&lt;s.length;i++)&#123; if(obj.hasOwnProperty(s.charAt(i)))&#123; start = Math.max(start,obj[s.charAt(i)]+1) obj[s.charAt(i)]=i &#125;else&#123; obj[s.charAt(i)]=i &#125; ans = Math.max(i-start,ans) &#125; return ans+1&#125;; 滑动窗口https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/ 执行用时 :136 ms, 在所有 JavaScript 提交中击败了59.07%的用户 内存消耗 :40 MB, 在所有 JavaScript 提交中击败了55.58%的用户 4. 寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 12345678910111213var findMedianSortedArrays = function(nums1, nums2) &#123; nums1 = nums1.concat(nums2) nums1 = nums1.sort((a,b)=&gt;&#123; return a-b &#125;) let m = nums1.length; if(m%2==0)&#123; return (nums1[m/2]+nums1[m/2-1])/2 &#125;else&#123; return nums1[Math.floor(m/2)] &#125;&#125;; 暴力法，合并数组后排序取值 执行用时 :204 ms, 在所有 JavaScript 提交中击败了54.66%的用户 内存消耗 :39.3 MB, 在所有 JavaScript 提交中击败了61.53%的用户 5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 1234567891011121314151617181920var longestPalindrome = function(s) &#123; let len = s.length,start = 0,end = 0; for(let i = 0;i&lt;len;++i)&#123; let l1 = centralExpand(s,i,i,len), l2 = centralExpand(s,i,i+1,len); let l3 = Math.max(l1,l2); if (l3 &gt; end - start) &#123; start = i - l3/2+1 end = i + l3/2+1 &#125; &#125; return s.substring(start, end);&#125;;function centralExpand(s,l,r,len)&#123; while(l&gt;=0 &amp;&amp; r&lt;=len &amp;&amp; s.charAt(l)==s.charAt(r))&#123; l--; r++; &#125; return r-l-1;&#125; 中心扩展算法事实上，只需使用恒定的空间，我们就可以在 O(n^2) 的时间内解决这个问题。 我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有 2n - 1 个中心。对比扩展中心的两侧 时间复杂度：O(n^2)，由于围绕中心来扩展回文会耗去 O(n) 的时间，所以总的复杂度为 O(n^2)。 空间复杂度：O(1)。 执行用时 :180 ms, 在所有 JavaScript 提交中击败了62.54%的用户 内存消耗 :37.1 MB, 在所有 JavaScript 提交中击败了57.35%的用户 6. Z 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I RE T O E S I I GE D H N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 123456789101112131415161718192021222324252627282930313233343536var convert = function(s, numRows) &#123; let str = []; if(numRows==1|s.length==1|s.length&lt;=numRows)&#123; return s &#125; for(let i=0;i&lt;s.length/(numRows*2-2);++i)&#123; str[i]= s.substring(i*(numRows*2-2),(i+1)*(numRows*2-2)); str[i]=str[i].split(&quot;&quot;); &#125; let strs = []; for(let j=0;j&lt;numRows;++j)&#123; strs[j]=&apos;&apos;; if(j==0)&#123; for(let i=0;i&lt;str.length;++i)&#123; strs[j]+=str[i][0]; &#125; &#125;else if(j==numRows-1)&#123; for(let i=0;i&lt;str.length;++i)&#123; if(str[i][numRows-1])&#123; strs[j]+=str[i][numRows-1]; &#125; &#125; &#125;else&#123; for(let i=0;i&lt;str.length;++i)&#123; if(str[i][numRows*2-2-j])&#123; strs[j]+=str[i][j]+str[i][numRows*2-2-j]; &#125;else if(str[i][j])&#123; strs[j]+=str[i][j] &#125; &#125; &#125; &#125; strs=strs.join(&quot;&quot;) return strs;&#125;; 执行用时 :152 ms, 在所有 JavaScript 提交中击败了47.37%的用户 内存消耗 :39.1 MB, 在所有 JavaScript 提交中击败了46.97%的用户 7. 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321示例 3: 输入: 120输出: 21注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 1234567var reverse = function(x) &#123; var x1 = x &lt; 0 ? -1 : 1; let y = Math.abs(x); y = y.toString().split(&apos;&apos;).reverse().join(&apos;&apos;); let s = +y*x1 return s&gt;Math.pow(2, 31) - 1||s&lt;-Math.pow(2, 31)?0:s&#125;; 执行用时 :112 ms, 在所有 JavaScript 提交中击败了51.81%的用户 内存消耗 :35.8 MB, 在所有 JavaScript 提交中击败了40.11%的用户 8. 字符串转换整数 (atoi)123456789101112131415161718192021222324252627/** * @param &#123;string&#125; str * @return &#123;number&#125; */var myAtoi = function(str) &#123; str = str.trim() let f = false,reg = /^\d*/ if(str.charAt(0)==&quot;-&quot;)&#123; f = true str = str.substring(1) &#125;else if(str.charAt(0)==&quot;+&quot;)&#123; str = str.substring(1) &#125; let number = parseInt(str.match(reg)) if(isNaN(number))&#123; return 0 &#125; if(number&gt;=2147483648&amp;&amp;f==true)&#123; number = 2147483648 &#125;else if(number&gt;=2147483648)&#123; number = 2147483647 &#125; if(f)&#123; number*=-1 &#125; return number&#125;; 暴力破解 执行用时 :92 ms, 在所有 JavaScript 提交中击败了96.15%的用户 内存消耗 :36.2 MB, 在所有 JavaScript 提交中击败了35.32%的用户 1234567891011var myAtoi = function(str) &#123; str = parseInt(str)||0; if(str&gt;2147483647 )&#123; return 2147483647 &#125; if(str&lt;-2147483648 )&#123; return -2147483648 &#125; return str;&#125;; parseInt已经实现这个功能了… 10. 正则表达式匹配给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符‘*’ 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 * 123var isMatch = function(s, p) &#123; return new RegExp(&quot;^&quot;+p+&quot;$&quot;).test(s)&#125;; 赖皮做法，JS无脑过 执行用时 :92 ms, 在所有 JavaScript 提交中击败了94.99%的用户 内存消耗 :34.9 MB, 在所有 JavaScript 提交中击败了37.08%的用户 11. 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例: 输入: [1,8,6,2,5,4,8,3,7]输出: 49 1234567891011var maxArea = function(height) &#123; let maxarea = 0, l = 0, r = height.length - 1; while (l &lt; r) &#123; maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l)); if (height[l] &lt; height[r]) l++; else r--; &#125; return maxarea;&#125;; 外围逼近，中间扩展以及滑动窗口都跪了 执行用时 :64 ms, 在所有 JavaScript 提交中击败了99.65%的用户 内存消耗 :35.4 MB, 在所有 JavaScript 提交中击败了63.90%的用户 14. 最长公共前缀12345678910111213141516171819202122232425/** * @param &#123;string[]&#125; strs * @return &#123;string&#125; */var longestCommonPrefix = function(strs) &#123; if(strs.length==0)&#123; return &quot;&quot; &#125; let i = 0,con=true while(i&lt;strs[0].length)&#123; for(var j = 1;j&lt;strs.length;j++)&#123; if(strs[j].charAt(i)!=strs[j-1].charAt(i))&#123; break &#125; &#125; if(j!=strs.length)&#123; break &#125;else&#123; i++ &#125; &#125; let res = &quot;&quot; res+=strs[0].substr(0,i) return res&#125;; 执行用时 :68 ms, 在所有 JavaScript 提交中击败了95.21%的用户 内存消耗 :34.9 MB, 在所有 JavaScript 提交中击败了47.14%的用户 55. 跳跃游戏给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 12345678910111213141516171819202122232425var canJump = function(nums) &#123; let length = nums.length; let front = nums[0], behind = 0,temp=0,last=0; while(front&lt;length-1&amp;&amp;last!=front)&#123; last=front temp=behind while(behind&lt;front-1)&#123; behind++ temp=Math.max(temp,behind+nums[behind]) &#125; if(temp&gt;front)&#123; [front,behind]=[front,temp].sort((a,b)=&gt;b-a) &#125;else&#123; behind=front front+=nums[front] &#125; &#125; if(front&gt;=length-1)&#123; return true &#125;else&#123; return false &#125; &#125;; 执行用时 :84 ms, 在所有 JavaScript 提交中击败了66.37%的用户 内存消耗 :35.5 MB, 在所有 JavaScript 提交中击败了57.97%的用户 62. 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 示例 1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 123456var uniquePaths = function(m, n) &#123; if(m==1||n==1)&#123; return 1 &#125; return uniquePaths(m-1,n)+uniquePaths(m,n-1)&#125;; 递归DP，容易超时，二维数组考虑越界问题 1234567891011121314var uniquePaths = function(m, n) &#123; let dp = []; for(let j=0;j&lt;n;++j)&#123; dp.push([]) for(let i = 0;i&lt;m;++i)&#123; if(i==0||j==0)&#123; dp[j][i]=1 &#125;else&#123; dp[j].push(dp[j][i-1]+dp[j-1][i]) &#125; &#125; &#125; return dp[n-1][m-1]&#125;; DP 12345678910var uniquePaths = function(m, n) &#123; var a= new Array(n).fill(1); var dp=new Array(m).fill(a); for(var i=1; i&lt;m; i++)&#123; for(var j=1; j&lt;n; j++)&#123; dp[i][j]=dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1];&#125;; new Array(n).fill(1) 这个操作省时 63. 不同路径 II输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 12345678910111213141516171819202122var uniquePathsWithObstacles = function(obstacleGrid) &#123; let m = obstacleGrid.length,n = obstacleGrid[0].length; var a= new Array(n).fill(0); var dp=new Array(m).fill(a); for(let i=0; i&lt;m; i++)&#123; for(let j=0; j&lt;n; j++)&#123; if(i == 0 &amp;&amp; j == 0)&#123; dp[i][j]=1; &#125;else if(i == 0)&#123; dp[i][j]=dp[i][j-1] &#125;else if(j == 0)&#123; dp[i][j]=dp[i-1][j] &#125;else&#123; dp[i][j]=dp[i][j-1]+dp[i-1][j] &#125; if(obstacleGrid[i][j]==1)&#123; dp[i][j]=0 &#125; &#125; &#125; return dp[m-1][n-1];&#125;; let a = new Array(2).fill(0) let b = new Array(K+1).fill(a) let dp = new Array(n).fill(b) fill创建三维数组带来浅拷贝的问题，Array.fill()如果填充类型为对象，则为浅拷贝。数组内的对象指向的都是同一个内存地址。 你可以这样做执行用时 :88 ms, 在所有 JavaScript 提交中击败了65.92%的用户 内存消耗 :34.9 MB, 在所有 JavaScript 提交中击败了98.31%的用户 94. 二叉树的中序遍历123456789101112var inorderTraversal = function(root) &#123; let arr=[] order(root,arr) return arr&#125;;function order(root,arr)&#123; if(root!=null)&#123; order(root.left,arr) arr.push(root.val) order(root.right,arr) &#125;&#125; 执行用时 :76 ms, 在所有 JavaScript 提交中击败了56.89%的用户 内存消耗 :34.3 MB, 在所有 JavaScript 提交中击败了5.23%的用户 123456789101112var inorderTraversal = function(root) &#123; let arr=[] function order(root)&#123; if(root!=null)&#123; order(root.left) arr.push(root.val) order(root.right) &#125; &#125; order(root) return arr&#125;; 改成内部函数，去掉arr的调参 执行用时 :56 ms, 在所有 JavaScript 提交中击败了98.33%的用户 内存消耗 :34.3 MB, 在所有 JavaScript 提交中击败了5.23%的用户 98. 验证二叉搜索树给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 深搜123456789101112131415161718192021222324252627var isValidBST = function(root) &#123; if(root == null)&#123; return true &#125; let right = leftest(root.right) let left = rightest(root.left) if (left &amp;&amp; left.val &gt;= root.val) &#123; return false &#125; if (right &amp;&amp; right.val &lt;= root.val) &#123; return false &#125; return isValidBST(root.left) &amp;&amp; isValidBST(root.right)&#125;;function rightest(node)&#123; while(node &amp;&amp; node.right)&#123; node = node.right &#125; return node&#125;function leftest(node)&#123; while(node &amp;&amp; node.left)&#123; node = node.left &#125; return node&#125; 对比左子树最右节点和右子树最左节点确保左子树所有值小于自身，右大于自身 执行用时 :112 ms, 在所有 JavaScript 提交中击败了30.95%的用户 内存消耗 :37.4 MB, 在所有 JavaScript 提交中击败了57.23%的用户 12345678910var isValidBST = function(root, arr = []) &#123; if (!root) return true; return isValidBST(root.left, arr) &amp;&amp; compareAndPush(root.val, arr) &amp;&amp; isValidBST(root.right, arr);&#125;;function compareAndPush (val, arr) &#123; if (arr.length) if (arr[arr.length - 1] &gt;= val) return false arr.push(val); return true;&#125; 中序遍历方法 1234567891011121314/** * @param &#123;TreeNode&#125; root * @param &#123;TreeNode&#125; pre 当前节点值的下限 * @param &#123;TreeNode&#125; next 当前节点值的上限 * @return &#123;boolean&#125; */var isValidBST = function(root, pre = null, next = null) &#123; if (!root) return true; // 在这里打印日志可以很好的观察到遍历顺序以及每个节点到底与哪些上下限进行了比较 // console.log(root &amp;&amp; root.val, pre &amp;&amp; pre.val, next &amp;&amp; next.val); if (pre &amp;&amp; pre.val &gt;= root.val) return false; if (next &amp;&amp; next.val &lt;= root.val) return false; return isValidBST(root.left, pre, root) &amp;&amp; isValidBST(root.right, root, next);&#125;; 因为在每个二叉搜索树中，根节点的值一定比左子树所有节点的值大且一定比右子树所有节点的值小。巧妙的将这些上下限值通过函数递归传给子节点来进行比较。顺便发现了该方法的遍历顺序就是先序遍历 123456789101112131415161718var isValidBST = function(root) &#123; let data = [] Inorder(root,data) for(let i=0;i+1&lt;data.length;i++)&#123; if(data[i]&gt;=data[i+1]) return false &#125; return true&#125;;function Inorder(root,data)&#123; if(root)&#123; Inorder(root.left,data) data.push(root.val) Inorder(root.right,data) &#125; else return&#125; 最快，把树全部打印成数组从头比较过去 100. 相同的树123456789101112131415161718192021/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function(p, q) &#123; if(p!=null&amp;&amp;q!=null)&#123; return q.val==p.val &amp;&amp; isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right) &#125;else if(p==null&amp;&amp;q==null)&#123; return true &#125;else&#123; return false &#125;&#125;; 执行用时 :60 ms, 在所有 JavaScript 提交中击败了96.35%的用户 内存消耗 :33.7 MB, 在所有 JavaScript 提交中击败了21.59%的用户 101. 对称二叉树广搜123456789101112var isSymmetric = function(root) &#123; return isM(root,root)&#125;;function isM(n1,n2)&#123; if(n1==null&amp;&amp;n2==null)&#123; return true &#125; if(n1==null||n2==null)&#123; return false &#125; return n1.val==n2.val &amp;&amp; isM(n1.left,n2.right) &amp;&amp; isM(n1.right,n2.left)&#125; 执行用时 :88 ms, 在所有 JavaScript 提交中击败了72.72%的用户 内存消耗 :35.4 MB, 在所有 JavaScript 提交中击败了53.38%的用户 104. 二叉树的最大深度1234567891011121314var maxDepth = function(root) &#123; let depth=0,i=0 function deep(root,i)&#123; if(root!=null)&#123; i++ depth=Math.max(depth,i) return deep(root.left,i)||deep(root.right,i) &#125;else&#123; i=0 &#125; &#125; deep(root,i) return depth&#125;; 执行用时 :76 ms, 在所有 JavaScript 提交中击败了90.76%的用户 内存消耗 :37 MB, 在所有 JavaScript 提交中击败了70.72%的用户 1var maxDepth = root =&gt; root? Math.max(maxDepth(root.left),maxDepth(root.right))+1 : 0 递归+箭头函数 执行用时 :72 ms, 在所有 JavaScript 提交中击败了94.44%的用户 内存消耗 :37.1 MB, 在所有 JavaScript 提交中击败了52.78%的用户 121. 买卖股票的最佳时机低进高出 12345678910111213var maxProfit = function(prices) &#123; let low = prices[0],high = prices[0],profit = 0; prices.forEach((ele)=&gt;&#123; if(ele&lt;low)&#123; low = ele high = ele &#125;else if(ele&gt;high)&#123; high = ele profit = Math.max(profit,high-low) &#125; &#125;) return profit&#125;; for of 比 forEach更耗空间一些，时间上有随机的可能 执行用时 :72 ms, 在所有 JavaScript 提交中击败了98.04%的用户 内存消耗 :35 MB, 在所有 JavaScript 提交中击败了92.95%的用户 122. 买卖股票的最佳时机 II多笔交易 12345678910111213141516var maxProfit = function(prices) &#123; let low = prices[0],high = prices[0],profit = 0,total = 0; for(let ele of prices)&#123; if(ele&gt;high)&#123; high = ele profit = Math.max(profit,high-low) &#125;else&#123; total +=profit; profit = 0; low = ele high = ele &#125; &#125; total +=profit return total&#125;; 执行用时 :88 ms, 在所有 JavaScript 提交中击败了51.61%的用户 内存消耗 :36.3 MB, 在所有 JavaScript 提交中击败了7.56%的用户 123. 买卖股票的最佳时机 III限制交易次数 状态转移方程每天都有三种「选择」：买入、卖出、无操作 这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/ 123456789101112dp[i][k][0 or 1]0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= Kn 为天数，大 K 为最多交易数此问题共 n × K × 2 种状态，全部穷举就能搞定。for(let i=0; i&lt;n; i++)&#123; for(let k=K; k&gt;=1; k--)&#123; for(let s=0; s&lt;2; s++)&#123; dp[i][k][s] = max(buy, sell, rest) &#125; &#125;&#125; 我们想求的最终答案是 dp 【n - 1】【 K】【0】，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是dp 【n - 1】【 K】【1】？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。 现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程： 1234567891011121314dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max(选择 rest,选择 sell)解释：今天我没有持有股票，有两种可能：要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max(选择 rest,选择 buy)解释：今天我持有着股票，有两种可能：要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell的时候减 1。 还差最后一点点，就是定义 base case，即最简单的情况。 123base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity 12345678910111213141516171819var maxProfit = function(prices) &#123; if(prices.length==0)&#123; return 0 &#125; let n = prices.length,K = 2; let dp = new Array(n).fill([[0,0],[0,0],[0,0]]) for(let i=0; i&lt;n; i++)&#123; for(let k=K; k&gt;0; k--)&#123; if(i==0)&#123; dp[i][k][0] = 0; dp[i][k][1] = 0-prices[i]; continue; &#125; dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i]) &#125; &#125; return dp[n-1][K][0]&#125;; 123456789//[3,3,5,0,0,3,1,4][ [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ], [ [ 0, 0 ], [ 4, 0 ], [ 6, 2 ] ] ] 12345678910111213141516var maxProfit = function(prices) &#123; if(prices.length===0)&#123; return 0 &#125; // 设置基础条件 var dp10=0,dp20=0 var dp11=-prices[0], dp21 = -prices[0] for(let i=1;i&lt;prices.length;i++)&#123; dp11=Math.max(dp11,-prices[i]) dp10=Math.max(dp10,dp11+prices[i]) //此行完成状态转移 dp21=Math.max(dp21,dp10-prices[i]) dp20=Math.max(dp20,dp21+prices[i]) &#125; return dp20&#125;; 循环执行避免创建数组的耗时 执行用时 :96 ms, 在所有 JavaScript 提交中击败了63.11%的用户 内存消耗 :36.4 MB, 在所有 JavaScript 提交中击败了53.33%的用户 144. 二叉树的前序遍历123456789101112var preorderTraversal = function(root) &#123; let arr=[] function order(root)&#123; if(root!=null)&#123; arr.push(root.val) order(root.left) order(root.right) &#125; &#125; order(root) return arr&#125;; 执行用时 :64 ms, 在所有 JavaScript 提交中击败了92.44%的用户 内存消耗 :33.7 MB, 在所有 JavaScript 提交中击败了29.53%的用户 145. 二叉树的后序遍历123456789101112var postorderTraversal = function(root) &#123; let arr=[] function order(root)&#123; if(root!=null)&#123; order(root.left) order(root.right) arr.push(root.val) &#125; &#125; order(root) return arr&#125;; 执行用时 :64 ms, 在所有 JavaScript 提交中击败了91.12%的用户 内存消耗 :34.1 MB, 在所有 JavaScript 提交中击败了5.74%的用户 155. 最小栈123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * initialize your data structure here. */var MinStack = function() &#123; this.stack = new Array()&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.stack[this.stack.length]=x&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123; this.stack[this.stack.length-1]=null this.stack.length--&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123; return this.stack[this.stack.length-1]&#125;;/** * @return &#123;number&#125; */MinStack.prototype.getMin = function() &#123; return Math.min(...this.stack)&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */ 执行用时 :356 ms, 在所有 JavaScript 提交中击败了10.05%的用户 内存消耗 :44.3 MB, 在所有 JavaScript 提交中击败了38.10%的用户 123456789101112131415161718192021222324var MinStack = function() &#123; this.val = []; this.min = Infinity; this.top;&#125;;MinStack.prototype.push = function(x) &#123; this.val.push(x); this.min = this.min &gt; x ? x : this.min; this.topVal = x;&#125;;MinStack.prototype.pop = function() &#123; var popVal = this.val.pop(); if(this.min === popVal) &#123; this.min = Math.min(...this.val); &#125; this.topVal = this.val[this.val.length - 1]; return popVal;&#125;;MinStack.prototype.top = function() &#123; return this.topVal;&#125;;MinStack.prototype.getMin = function() &#123; return this.min;&#125;; 在push是确定最小可提升getMin 性能 162. 寻找峰值峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 1234567891011121314151617181920212223242526/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findPeakElement = function(nums) &#123; nums.push(-Infinity) let temp = 0,len = nums.length; if(len&lt;2)&#123; return 0 &#125; for(let i=1;i&lt;len;i++)&#123; if(nums[i]&gt;nums[i-1])&#123; temp=1 &#125;else if(nums[i]&lt;nums[i-1])&#123; if(temp===1)&#123; return i-1 &#125;else&#123; temp=0 &#125; &#125;else&#123; temp=0 &#125; &#125; return 0&#125;; 线性扫描 执行用时 :56 ms, 在所有 JavaScript 提交中击败了98.48%的用户 内存消耗 :34.1 MB, 在所有 JavaScript 提交中击败了38.46%的用户 12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findPeakElement = function(nums) &#123; let len = nums.length-1 for(let i=0;i&lt;len;i++)&#123; if (nums[i] &gt; nums[i + 1]) return i &#125; &#125; return len&#125; 执行用时 :60 ms, 在所有 JavaScript 提交中击败了97.97%的用户 内存消耗 :33.6 MB, 在所有 JavaScript 提交中击败了80.77%的用户 165. 比较版本号12345678910111213141516171819202122/** * @param &#123;string&#125; version1 * @param &#123;string&#125; version2 * @return &#123;number&#125; */var compareVersion = function(version1, version2) &#123; arr1 = version1.split(".").map((item)=&gt;&#123; return parseInt(item) &#125;) arr2 = version2.split(".").map((item)=&gt;&#123; return parseInt(item) &#125;) let length = Math.max(arr1.length,arr2.length); for(let i=0;i&lt;length;i++)&#123; if(arr1[i]===undefined)arr1[i]=0 if(arr2[i]===undefined)arr2[i]=0 if(arr1[i]&lt;arr2[i])return -1 if(arr1[i]&gt;arr2[i])return 1 &#125; return 0 &#125;; 执行用时 :64 ms, 在所有 JavaScript 提交中击败了90.44%的用户 内存消耗 :33.7 MB, 在所有 JavaScript 提交中击败了26.09%的用户 169. 求众数众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 123456789101112131415161718var majorityElement = function(nums) &#123; let map = new Map(),length = nums.length; for(let i = 0;i&lt;length;i++)&#123; if(map.has(nums[i]))&#123; map.set(nums[i],map.get(nums[i])+1) &#125;else&#123; map.set(nums[i],1) &#125; &#125; let maxValue,maxKey for(let [key,value] of map)&#123; if(!maxValue || maxValue &lt; value) &#123; maxValue = value maxKey = key &#125; &#125; return maxKey&#125;; 执行用时 :132 ms, 在所有 JavaScript 提交中击败了20.61%的用户 内存消耗 :37.7 MB, 在所有 JavaScript 提交中击败了29.33%的用户 哈希表法 12345678910111213141516var majorityElement = function (nums) &#123; if (nums.length === 1) &#123; return nums[0]; &#125; const map = new Map(); for (let num of nums) &#123; if (!map.get(num)) &#123; map.set(num, 1); &#125; else &#123; map.set(num, map.get(num) + 1); if (map.get(num) &gt; nums.length / 2) &#123; return num; &#125; &#125; &#125;&#125;; 栈 位运算 异位相消 188. 买卖股票的最佳时机 IV1234567891011121314151617181920212223var maxProfit = function (k, prices) &#123; let n = prices.length; if(n==0)&#123; return 0 &#125; if(k&gt;n/2)&#123; let ans = 0 for(let i=0;i&lt;n-1;i++)&#123; ans = Math.max(ans,ans+prices[i+1]-prices[i]) &#125; return ans &#125;else&#123; let dp0 = new Array(k+1).fill(0) let dp1 = new Array(k+1).fill(-prices[0]) for(let i = 1;i&lt;n;i++)&#123; for(let j = 1;j&lt;k+1;j++)&#123; dp0[j]=Math.max(dp0[j],dp1[j]+prices[i]) dp1[j]=Math.max(dp1[j],dp0[j-1]-prices[i]) &#125; &#125; return dp0[k] &#125;&#125;; k&gt;n/2跟不限次数交易一样 执行用时 :88 ms, 在所有 JavaScript 提交中击败了93.75%的用户 内存消耗 :35.2 MB, 在所有 JavaScript 提交中击败了100.00%的用户 200. 岛屿数量给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 输入:11110110101100000000 输出: 1 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;character[][]&#125; grid * @return &#123;number&#125; */var numIslands = function(grid) &#123; if(grid.length==0||grid[0].length==0)&#123; return 0 &#125; let count=0; for(let i=0;i&lt;grid.length;i++)&#123; for(let j=0;j&lt;grid[0].length;j++)&#123; if(grid[i][j]==1)&#123; count++ islandClean(i,j,grid) &#125; &#125; &#125; function islandClean(i,j)&#123; grid[i][j]=0 if(j+1&lt;grid[0].length&amp;&amp;grid[i][j+1]==1)&#123; islandClean(i,j+1) &#125; if(i+1&lt;grid.length&amp;&amp;grid[i+1][j]==1)&#123; islandClean(i+1,j) &#125; if(j-1&gt;=0&amp;&amp;grid[i][j-1]==1)&#123; islandClean(i,j-1) &#125; if(i-1&gt;=0&amp;&amp;grid[i-1][j]==1)&#123; islandClean(i-1,j) &#125; &#125; return count&#125;; 感染法，把计数岛屿部分全部归零 执行用时 :84 ms, 在所有 JavaScript 提交中击败了93.77%的用户 内存消耗 :37.8 MB, 在所有 JavaScript 提交中击败了50.50%的用户 215. 数组中的第K个最大元素1234567891011var findKthLargest = function(nums, k) &#123; let arr = nums.slice(0,k),len = nums.length; arr.sort((a,b)=&gt;a-b) for(let i=k;i&lt;len;i++)&#123; if(nums[i]&gt;arr[0])&#123; arr[0]=nums[i] arr.sort((a,b)=&gt;a-b) &#125; &#125; return arr[0]&#125;; 执行用时 :372 ms, 在所有 JavaScript 提交中击败了7.31%的用户 内存消耗 :38.4 MB, 在所有 JavaScript 提交中击败了7.19%的用户 292. Nim 游戏你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。 123var canWinNim = function(n) &#123; if(n%4==0)&#123;return false&#125;else&#123;return true&#125;&#125;; 执行用时 :76 ms, 在所有 JavaScript 提交中击败了59.01%的用户 内存消耗 :33.8 MB, 在所有 JavaScript 提交中击败了22.35%的用户 12return n % 4 == 0 ? false : true更快 319. 灯泡开关初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 于是转而观察某个位置，看看某个位置是怎样变化的，什么条件下会翻转 第18个灯泡会在1,2,3,6,9,18轮翻转。第36个灯泡会在1,2,3,4,6,9,13,18,36轮翻转。 规律显而易见，只有在轮数是该位置因数的时候才会执行翻转操作。 于是我们回答了那个问题：只要找到该位置的所有因数个数，我们就知道该位置翻转了多少次。 更进一步的，除了完全平方数，因数都是成对出现的，这意味着实际起到翻转作用(0-&gt;1)的，只有完全平方数而已。 此时任务已经大大简化，因为n个灯泡翻转n轮，我们只要看看到n位置，一共有多少个完全平方数即可。 parseInt()比Math.floor()快 123var bulbSwitch = function(n) &#123; return Math.floor(Math.sqrt(n))&#125;; 执行用时 :72 ms, 在所有 JavaScript 提交中击败了79.17%的用户 内存消耗 :33.8 MB, 在所有 JavaScript 提交中击败了12.50%的用户 718. 最长重复子数组777. 在LR字符串中交换相邻字符在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如”RXXLRXRXL”）中进行移动操作。一次移动操作指用一个”LX”替换一个”XL”，或者用一个”XR”替换一个”RX”。现给定起始字符串start和结束字符串end，请编写代码，当且仅当存在一系列移动操作使得start可以转换成end时， 返回True。 123456789101112131415161718192021222324252627var canTransform = function(start, end) &#123; let i=0,j=0; while(i&lt;start.length&amp;&amp;j&lt;start.length)&#123; while(start.charAt(i)==&quot;X&quot;)&#123; i++ &#125; while(end.charAt(j)==&quot;X&quot;)&#123; j++ &#125; if(start[i]!=end[j])&#123; return false &#125;//LR不能互相穿过 if(start[i]==&quot;R&quot;)&#123; if(i&gt;j)&#123; return false &#125; &#125;//R只能右移 if(start[i]==&quot;L&quot;)&#123; if(i&lt;j)&#123; return false &#125; &#125;//L只能左移 i++ j++ &#125; return true&#125;; 执行用时 :92 ms, 在所有 JavaScript 提交中击败了72.73%的用户 内存消耗 :35.7 MB, 在所有 JavaScript 提交中击败了100.00%的用户 1033. 移动石子直到连续三枚石子放置在数轴上，位置分别为 a，b，c。 每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 1234567891011121314151617var numMovesStones = function(a, b, c) &#123; [a,b,c]=[a,b,c].sort((a,b)=&gt;a-b) let arr=[0,0]; if(b-a==1&amp;&amp;c-b==1)&#123; return arr &#125;else if(b-a==1)&#123; arr[0]=1 &#125;else if(c-b==1)&#123; arr[0]=1 &#125;else if(b-a==2||c-b==2)&#123; arr[0]=1 &#125;else&#123; arr[0]=2 &#125; arr[1]=c-a-2 return arr&#125;; 执行用时 :76 ms, 在所有 JavaScript 提交中击败了90.20%的用户 内存消耗 :33.9 MB, 在所有 JavaScript 提交中击败了100.00%的用户]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南_JavaScript]]></title>
    <url>%2F2019%2F04%2F16%2Finterview_JavaScript%2F</url>
    <content type="text"><![CDATA[梳理JS知识 前端学习指南_JavaScript类型基本类型undefined null boolean string String 的意义并非“字符串”，而是字符串的 UTF16编码，最大长度是 2^53 - 1 number 有18437736874454810627(即 2^64-2^53+3)个值 12console.log( 0.1 + 0.2 == 0.3);//false//浮点运算带来精度问题console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);//true//检查等式左右两边差的绝对值是否小于最小精度 symbol symbol引用类型object typeof装箱拆箱把基本数据类型转换为对应的引用类型的操作称为装箱，把引用类型转换为基本的数据类型称为拆箱。 在《javascript高级程序设计》中有这样一句话： 1`每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。` 12var s1 = &quot;some text&quot;;var s2 = s1.substring(2); 如上所视，变量s1是一个基本类型值，它不是对象，所以它不应该有方法。但是js内部为我们完成了一系列处理（即我们称之为装箱），使得它能够调用方法,实现的机制如下： （1）创建String类型的一个实例； （2）在实例上调用指定的方法； （3）销毁这个实例； 这个过程也可以用代码来展现： 123var s1 = new String(&quot;some text&quot;);var s2 = s1.substring(2);s1 = null; 拆箱： 将引用类型对象转换为对应的值类型对象，它是通过引用类型的valueOf()或者toString()方法来实现的。如果是自定义的对象，你也可以自定义它的valueOf()/tostring()方法，实现对这个对象的拆箱。 123456789var objNum = new Number(123); var objStr = new String(&quot;123&quot;); console.log( typeof objNum ); //objectconsole.log( typeof objStr ); //objectconsole.log( typeof objNum.valueOf() ); //numberconsole.log( typeof objStr.valueOf() ); //stringconsole.log( typeof objNum.toString() ); // string 11 console.log( typeof objStr.toString() ); // string 内存空间在学习内存空间之前，我们需要对三种数据结构有一个直观的认知。他们分别是堆(heap)，栈(stack)与队列(queue)。 变量对象与基础数据类型JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JavaScript的基础数据类型往往都会保存在变量对象中。 严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。 基础数据类型都是一些简单的数据段，JavaScript中有5种基础数据类型，分别是Undefined、Null、Boolean、Number、String、Symbol。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际的值。 引用数据类型与堆内存与其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。 为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。 123456var a1 = 0; // 变量对象var a2 = 'this is string'; // 变量对象var a3 = null; // 变量对象var b = &#123; m: 20 &#125;; // 变量b存在于变量对象中，&#123;m: 20&#125; 作为对象存在于堆内存中var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中 上例图解 因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。 引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。 深浅复制浅拷贝 浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。 123456789101112let obj = &#123; name: &apos;Yvette&apos;, age: 18, hobbies: [&apos;reading&apos;, &apos;photography&apos;]&#125;let obj2 = Object.assign(&#123;&#125;, obj);let obj3 = &#123;...obj&#125;;obj.name = &apos;Jack&apos;;//基本类型不改变obj.hobbies.push(&apos;coding&apos;);//引用类型改变console.log(obj);//&#123; name: &apos;Jack&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125;console.log(obj2);//&#123; name: &apos;Yvette&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125;console.log(obj3);//&#123; name: &apos;Yvette&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125; 深拷贝 深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。 1.深拷贝最简单的实现是: JSON.parse(JSON.stringify(obj)) JSON.parse(JSON.stringify(obj)) 是最简单的实现方式，但是有一些缺陷： 对象的属性值是函数时，无法拷贝。 原型链上的属性无法拷贝 不能正确的处理 Date 类型的数据 不能处理 RegExp 会忽略 symbol 会忽略 undefined 2.实现一个 deepClone 函数 如果是基本数据类型，直接返回 如果是 RegExp 或者 Date 类型，返回对应类型 如果是复杂数据类型，递归。 考虑循环引用的问题 1234567891011121314151617181920function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj); if (obj instanceof Date) return new Date(obj); if (obj === null || typeof obj !== &apos;object&apos;) return obj; //如果不是复杂数据类型，直接返回 if (hash.has(obj)) &#123; return hash.get(obj); &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor(); hash.set(obj, t); for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123;//是否是自身的属性 t[key] = deepClone(obj[key], hash); &#125; &#125; return t;&#125; 内存空间管理垃圾回收标记清除 这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。 垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。 引用计数法 另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减1，当这个值的引用次数为0的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为0的这些值。 用引用计数法会存在内存泄露，下面来看原因： 123456function problem() &#123; var objA = new Object(); var objB = new Object(); objA.someOtherObject = objB; objB.anotherObject = objA;&#125; 在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为0，这样的相互引用如果大量存在就会导致内存泄露。 执行上下文（execute context，EC）每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文指代码正式执行之前进入的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval（不建议使用，可忽略） 因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。全局上下文在浏览器窗口关闭后出栈。 创建流程： 1.创建变量对象（变量提升） 1）变量 2）函数及函数参数 2.确认this指向（VO-&gt;AO） 1）全局 this-&gt;window 2）局部 指向调用它的对象 3.创建作用域链 父级作用域链+当前变量对象 执行流程： 变量赋值 函数引用 执行代码 出栈 JS执行上下文栈简称执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。 规则如下： 首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。 作用域作用域是变量以及通过名称访问这些变量的规则的集合 变量提升变量只提升声明 let 导致 TDZ 函数整体提升 作用域链作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 变量对象（Variable Object）变量对象的创建，依次经历了以下几个过程。 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。 12345678910// demo01function test() &#123; console.log(a); console.log(foo()); var a = 1; function foo() &#123; return 2; &#125;&#125;test(); 全局作用域中运行test()时，test()的执行上下文开始创建。 12345678910111213// 创建过程testEC = &#123; // 变量对象 VO: &#123;&#125;, scopeChain: &#123;&#125;&#125;// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明// VO 为 Variable Object的缩写，即变量对象VO = &#123; arguments: &#123;...&#125;, //注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理 foo: &lt;foo reference&gt; // 表示foo的地址引用 a: undefined&#125; 未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。 变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于函数调用栈栈顶的执行上下文中的变量对象，才会变成活动对象。 12345678// 执行阶段VO -&gt; AO // Active ObjectAO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, a: 1, this: Window&#125; 因此，上面的例子demo1，执行顺序就变成了这样 12345678910function test() &#123; function foo() &#123; return 2; &#125; var a; console.log(a); console.log(foo()); a = 1;&#125;test(); 1234567891011121314151617181920212223242526272829303132333435// demo2function test() &#123; console.log(foo); console.log(bar); var foo = 'Hello'; console.log(foo); var bar = function () &#123; return 'world'; &#125;//var 声明只提升var bar function foo() &#123; return 'hello'; &#125;&#125;test();//ƒ foo() &#123;// return 'hello';// &#125;//VM157:3 undefined//VM157:6 Hello// 创建阶段VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, bar: undefined&#125;// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖// 执行阶段VO -&gt; AOVO = &#123; arguments: &#123;...&#125;, foo: 'Hello', bar: &lt;bar reference&gt;, this: Window&#125; thisthis的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。除此之外，在函数执行过程中，this一旦被确定，就不可更改了。运行后会报错 隐式绑定&lt;显式绑定&lt;new绑定 使用call，apply显示指定this JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。 箭头函数不适用this的四种标准规则，而是根据外层（函数或则全局）作用域来决定this，箭头函数的绑定无法被修改（new也不行） 123456789function foo()｛ return (a) =&gt; &#123; console.log(this.a); &#125;&#125;var obj1 = &#123;a:2&#125;;var obj2 = &#123;a:3&#125;;var bar = foo.call(obj1);//foo()内部创建的箭头函数会捕获调用时foo()的thisbar.call(obj2);//2，不是3,由于foo()的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1 闭包（Closure）什么是闭包 闭包是函数和声明该函数的词法环境的组合。–MDN 闭包条件 函数嵌套 内部函数引用外部函数的局部变量 优点 延长外部函数局部变量的生命周期 缺点 内存泄漏 解决 用原型代替 ​ 及时销毁 123456var add = (function()&#123; var counter = 0; return function()&#123; return(++counter); &#125;&#125;)() 闭包是在函数被调用执行的时候才被确认创建的。 闭包的形成，与作用域链的访问顺序有直接关系。 只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。 柯里化函数函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 函数柯里化的主要作用： 参数复用 提前返回 – 返回接受余下的参数且返回结果的新函数 延迟执行 – 返回新函数，等待执行 123456789101112131415161718192021222324const curry = (fn, ...args) =&gt; args.length &lt; fn.length //参数长度不足时，递归调用柯里化，等待接受新参数 ? (...arguments) =&gt; curry(fn, ...args, ...arguments) //参数长度满足时，执行函数 : fn(...args);function curry(fn,...args)&#123; if(args.length&lt;fn.length)&#123; return function(...arguments)&#123; return curry(fn,...args,...arguments) &#125; &#125;else&#123; fn(...args) &#125;&#125;function sumFn(a, b, c) &#123; return a + b + c;&#125;var sum = curry(sumFn);console.log(sum(2)(3)(5));//10console.log(sum(2, 3, 5));//10console.log(sum(2)(3, 5));//10console.log(sum(2, 3)(5));//10 普通思维下我们可以这样来封装。 123456function getNewArray(array) &#123; return array.map(function(item) &#123; return item * 100 + '%' &#125;)&#125;getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%']; 而如果借助柯里化来二次封装这样的逻辑，则会如下实现： 123456789function _map(func, array) &#123; return array.map(func);&#125;var _getNewArray = createCurry(_map);var getNewArray = _getNewArray(function(item) &#123; return item * 100 + '%'&#125;)getNewArray([1, 2, 3, 0.12]); // ['100%', '200%', '300%', '12%'];getNewArray([0.01, 1]); // ['1%', '100%'] 如果我们的项目中的固定操作是希望对数组进行一个过滤，找出数组中的所有Number类型的数据。借助柯里化思维我们可以这样做。 12345678910111213141516171819202122232425function _filter(func, array) &#123; return array.filter(func);&#125;var _find = createCurry(_filter);var findNumber = _find(function(item) &#123; if (typeof item == 'number') &#123; return item; &#125;&#125;)findNumber([1, 2, 3, '2', '3', 4]); // [1, 2, 3, 4]// 当我们继续封装另外的过滤操作时就会变得非常简单// 找出数字为20的子项var find20 = _find(function(item, i) &#123; if (typeof item === 20) &#123; return i; &#125;&#125;)find20([1, 2, 3, 30, 20, 100]); // 4// 找出数组中大于100的所有数据var findGreater100 = _find(function(item) &#123; if (item &gt; 100) &#123; return item; &#125;&#125;)findGreater100([1, 2, 101, 300, 2, 122]); // [101, 300, 122] 无限参数的柯里化1234// 实现一个add方法，使计算结果能够满足如下预期：add(1)(2)(3) = 6;add(1, 2, 3)(4) = 10;add(1)(2)(3)(4)(5) = 15; add方法的实现仍然会是一个参数的收集过程。当add函数执行到最后时，仍然返回的是一个函数，但是我们可以通过定义toString/valueOf的方式，让这个函数可以直接参与计算，并且转换的结果是我们想要的。而且它本身也仍然可以继续执行接收新的参数。实现方式如下。 123456789101112131415161718192021222324252627282930313233343536373839404142function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () &#123; var _adder = function() &#123; // [].push.apply(_args, [].slice.call(arguments)); _args.push(...arguments); return _adder; &#125;; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder; &#125; // return adder.apply(null, _args); return adder(..._args);&#125;var a = add(1)(2)(3)(4); // f 10var b = add(1, 2, 3, 4); // f 10var c = add(1, 2)(3, 4); // f 10var d = add(1, 2, 3)(4); // f 10// 可以利用隐式转换的特性参与计算console.log(a + 10); // 20console.log(b + 20); // 30console.log(c + 30); // 40console.log(d + 40); // 50// 也可以继续传入参数，得到的结果再次利用隐式转换参与计算console.log(a(10) + 100); // 120console.log(b(10) + 100); // 120console.log(c(10) + 100); // 120console.log(d(10) + 100); // 120// 其实上栗中的add方法，就是下面这个函数的柯里化函数，只不过我们并没有使用通用式来转化，而是自己封装function add(...args) &#123; return args.reduce((a, b) =&gt; a + b);&#125; 模块化模块是闭包最强大的一个应用场景 1234567891011(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。 面向对象继承 构造函数的prototype与所有实例对象的__proto__都指向原型对象。而原型对象的constructor指向构造函数。 ES5new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。 1. 原型链继承原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 假设我们将此方法添加到构造函数本身。 也许不是每个实例都需要这种方法。这会浪费大量内存空间，因为它们仍然具有该属性，这占用了每个实例的内存空间。 相反，如果我们只将它添加到原型中，我们只需将它放在内存中的一个位置，但它们都可以访问它！ 123456789101112131415161718192021function SuperType() &#123; this.name = &apos;Yvette&apos;; this.colors = [&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.getName = function () &#123; return this.name;&#125;function SubType() &#123; this.age = 22;&#125;SubType.prototype = new SuperType();SubType.prototype.getAge = function() &#123; return this.age;&#125;SubType.prototype.constructor = SubType;let instance1 = new SubType();instance1.colors.push(&apos;yellow&apos;);console.log(instance1.getName()); //&apos;Yvette&apos;console.log(instance1.colors);//[ &apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos; ]let instance2 = new SubType();console.log(instance2.colors);//[ &apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos; ] 缺点： 通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。 在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。 2. 借用构造函数借用构造函数的技术，其基本思想为: 在子类型的构造函数中调用超类型构造函数。 1function SuperType(name) &#123; this.name = name; this.colors = [&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;function SubType(name) &#123; SuperType.call(this, name);&#125;let instance1 = new SubType(&apos;Yvette&apos;);instance1.colors.push(&apos;yellow&apos;);console.log(instance1.colors);//[&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;, yellow]let instance2 = new SubType(&apos;Jack&apos;);console.log(instance2.colors); //[&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;] 优点: 可以向超类传递参数 解决了原型中包含引用类型值被所有实例共享的问题 缺点: 方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。 3. 组合继承(原型链 + 借用构造函数)组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路： 使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。 1function SuperType(name) &#123; this.name = name; this.colors = [&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;function SuberType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SuberType.prototype = new SuperType();SuberType.prototype.constructor = SuberType;SuberType.prototype.sayAge = function () &#123; console.log(this.age);&#125;let instance1 = new SuberType(&apos;Yvette&apos;, 20);instance1.colors.push(&apos;yellow&apos;);console.log(instance1.colors); //[ &apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos; ]instance1.sayName(); //Yvettelet instance2 = new SuberType(&apos;Jack&apos;, 22);console.log(instance2.colors); //[ &apos;pink&apos;, &apos;blue&apos;, &apos;green&apos; ]instance2.sayName();//Jack 缺点: 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 优点: 可以向超类传递参数 每个实例都有自己的属性 实现了函数复用 4. 原型式继承原型继承的基本思想： 借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。 1function object(o) &#123; function F() &#123; &#125; F.prototype = o; return new F();&#125; 在 object() 函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例，从本质上讲，object() 对传入的对象执行了一次浅拷贝。 ECMAScript5通过新增 Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。 1var person = &#123; name: &apos;Yvette&apos;, hobbies: [&apos;reading&apos;, &apos;photography&apos;]&#125;var person1 = Object.create(person);person1.name = &apos;Jack&apos;;person1.hobbies.push(&apos;coding&apos;);var person2 = Object.create(person);person2.name = &apos;Echo&apos;;person2.hobbies.push(&apos;running&apos;);console.log(person.hobbies);//[ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos;, &apos;running&apos; ]console.log(person1.hobbies);//[ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos;, &apos;running&apos; ] 在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。 缺点: 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。 5. 寄生式继承寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 1function createAnother(original) &#123; var clone = object(original);//通过调用函数创建一个新对象 clone.sayHi = function () &#123;//以某种方式增强这个对象 console.log(&apos;hi&apos;); &#125;; return clone;//返回这个对象&#125;var person = &#123; name: &apos;Yvette&apos;, hobbies: [&apos;reading&apos;, &apos;photography&apos;]&#125;;var person2 = createAnother(person);person2.sayHi(); //hi 基于 person 返回了一个新对象 -—— person2，新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。 缺点： 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。 6. 寄生组合式继承(一般这种)所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路： 不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示： 12345function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType;//增强对象 subType.prototype = prototype;//指定对象&#125; 第一步：创建超类型原型的一个副本 第二步：为创建的副本添加 constructor 属性 第三步：将新创建的对象赋值给子类型的原型 至此，我们就可以通过调用 inheritPrototype 来替换为子类型原型赋值的语句： 12345678910function SuperType(name) &#123; this.name = name; this.colors = [&apos;pink&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;//...codefunction SuberType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SuberType.prototype = new SuperType();inheritPrototype(SuberType, SuperType);//...code 优点: 只调用了一次超类构造函数，效率更高。避免在SuberType.prototype上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。 因此寄生组合继承是引用类型最理性的继承范式。 ES6classextendssuper通过super()调用父类构造函数，如果有super方法，需要时构造函数中第一个执行的语句，this关键字在调用super之后才可用 constructorstatic静态方法，在类定义的外部只能通过类名调用，内部可以通过this调用，并且静态函数是会被继承的。 区别大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 1234class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的: 123456class A &#123;&#125;class B &#123;&#125;// B的实例继承A的实例Object.setPrototypeOf(B.prototype, A.prototype);// B继承A的静态属性Object.setPrototypeOf(B, A); Object.setPrototypeOf的简单实现如下： 1234Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 因此，就得到了上面的结果。 1234567Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.__proto__ = A.prototype;Object.setPrototypeOf(B, A);// 等同于B.__proto__ = A; 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 123Object.create(A.prototype);// 等同于B.prototype.__proto__ = A.prototype; 不足 不支持静态属性（除函数）。 class中不能定义私有变量和函数。class中定义的所有函数都会被放倒原型当中，都会被子类继承，而属性都会作为实例属性挂到this上。如果子类想定义一个私有的方法或定义一个private 变量，便不能直接在class花括号内定义，这真的很不方便！ 总结一下，和es5相比，es6在语言层面上提供了面向对象的部分支持，虽然大多数时候只是一个语法糖，但使用起来更方便，语意化更强、更直观，同时也给javascript继承提供一个标准的方式。还有很重要的一点就是－es6支持原生对象继承。 new 声明一个中间对象； 将该中间对象的原型指向构造函数的原型； 将构造函数的this，指向该中间对象； 返回该中间对象，即返回实例对象。 1234567891011121314function _new()&#123; let target = &#123;&#125;;//创建空对象 let [constructor,...args] = [...arguments] //执行原型连接；target是 constructor的实例 target._proto_=constructor.prototype //执行构造函数，将属性或方法添加到空对象上 let result = constructor.apply(target，args); //构造函数中的this指向空对象 if(result&amp;&amp;(typeof (result)==&quot;object&quot;||typeof(result)==&quot;function&quot;))&#123; return result //如果构造函数执行的结构返回的是一个对象或方法，则返回 &#125; return target//不是则返回新对象&#125; 封装封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。 多态同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。 虚函数和模版（java中的范型）是支持多态的主要方式，因为javascript中没有模版，所以下面我们只讨论虚函数，下面先看一个例子： 1234567891011121314151617181920212223function Person(name,age)&#123; this.name=name this.age=age&#125;Person.prototype.toString=function()&#123; return "I am a Person, my name is "+ this.name&#125;function Man(name,age)&#123; Person.apply(this,arguments)&#125;Man.prototype = Object.create(Person.prototype);Man.prototype.toString=function()&#123; return "I am a Man, my name is"+this.name;&#125;var person=new Person("Neo",19)var man1=new Man("Davin",18)var man2=new Man("Jack",19)&gt; person+""&gt; "I am a Person, my name is Neo"&gt; man1+""&gt; "I am a Man, my name isDavin"&gt; man1&lt;man2 //期望比较年龄大小 1&gt; false 上面例子中，我们分别在子类和父类实现了toString方法，其实，在js中上述代码原理很简单，对于同名函数，子类会覆父类的，这种特性其实就是虚函数，只不过js中不区分参数个数，也不区分参数类型，只看函数名称，如果名称相同就会覆盖。现在我们来看注释1，我们期望直接用比较运算符比较两个man的大小（按年龄），怎么实现？在c++中有运算符重载，但java和js中都没有，所幸的是，js可以用一种变通的方法来实现： 123456789101112131415161718192021222324252627function Person(name,age)&#123; this.name=name this.age=age&#125;Person.prototype.valueOf=function()&#123; return this.age&#125;function Man(name,age)&#123; Person.apply(this,arguments)&#125;Man.prototype = Object.create(Person.prototype);var person=new Person("Neo",19)var man1=new Man("Davin",18)var man2=new Man("Jack",19)var man3=new Man("Joe",19)&gt;man1&lt;19//1&gt;true&gt;person==19//2&gt;true&gt;man1&lt;man2//3&gt;true&gt;man2==man3 //4 注意&gt;true&gt;person==man2//5&gt;false 其中1、2、3、5在所有js vm下结果都是确定的。但是4并不一定！javascript规定，对于比较运算符，如果一个值是对象，另一个值是数字时，会先尝试调用valueOf，如果valueOf未指定，就会调用toString；如果是字符串时，则先尝试调用toString，如果没指定，则尝试valueOf，如果两者都没指定，将抛出一个类型错误异常。如果比较的两个值都是对象时，则比较的时对象的引用地址，所以若是对象，只有自身＝＝＝自身，其它情况都是false。现在我们回过头来看看示例代码，前三个都是标准的行为。而第四点取决于浏览器的实现，如果严格按照标准，这应该算是chrome的一个bug ,但是，我们的代码使用时双等号，并非严格相等判断，所以浏览器的相等规则也会放宽。值得一提的是5，虽然person和man2 age都是19，但是结果却是false。总结一下，chrome对相同类的实例比较策略是先会尝试转化，然后再比较大小，而对非同类实例的比较，则会直接返回false，不会做任何转化。 所以我的建议是：如果数字和类实例比较，永远是安全的，可以放心玩，如果是同类实例之间，可以进行非等比较，这个结果是可以保证的，不要进行相等比较，结果是不能保证的，一般相等比较，变通的做法是： 12var equal= !(ob1&lt;ob2||ob1&gt;ob2) //不小于也不大于，就是等于，前提是比较操作符两边的对象要实现valueOf或toString 当然类似toString、valueOf的还有toJson方法，但它和重载没有什么关系，故不冗述。 DOM增删查改增12345678document.createElement(&apos;div&apos;);document.createTextNode(&apos;hello world!&apos;);ele.appendChild(el);ele.insertBefore(newElement, referenceElement);//insertAfter是jQuery方法insertAdjacentHTML insertAdjacentHTML() 将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。 1ele.insertAdjacentHTML(position, text); position是相对于元素的位置，并且必须是以下字符串之一： beforebegin: 元素自身的前面。 afterbegin: 插入元素内部的第一个子节点之前。 beforeend: 插入元素内部的最后一个子节点之后。 afterend: 元素自身的后面。text是要被解析为HTML或XML,并插入到DOM树中的字符串。 位置名称的可视化： 1234567&lt;!-- beforebegin --&gt; &lt;p&gt; &lt;!-- afterbegin --&gt; foo &lt;!-- beforeend --&gt;&lt;/p&gt;&lt;!-- afterend --&gt; 注意： beforebegin和afterend位置,仅在节点在树中且节点具有一个parent元素时工作. 删1ele.removeChild(el); 查123456789101112131415161718192021222324document.querySelector(&quot;.myclass&quot;);document.querySelectorAll(&quot;div.note, div.alert&quot;);document.getElementById(&apos;xxx&apos;);document.getElementsByClassName(&apos;highlight&apos;);document.getElementsByTagName(&apos;td&apos;);var parent = ele.parentElement;var parent = ele.parentNode;// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断var nodes = ele.children; // 查询子元素var els = ele.getElementsByTagName(&apos;td&apos;);var els = ele.getElementsByClassName(&apos;highlight&apos;);// 当前元素的第一个/最后一个子元素节点var el = ele.firstChild;var el = ele.firstElementChild;var el = ele.lastChild;var el = ele.lastElementChild;// 下一个/上一个兄弟元素节点var el = ele.nextSibling;var el = ele.nextElementSibling;var el = ele.previousSibling;var el = ele.previousElementSibling; 改12345678ele.replaceChild(el1, el2);ele.innerHTML//如果你的项目将要经过各种形式的安全检查的话，使用 innerHTML 可能导致代码被拒绝。ele.innerTextinnerHTML：内部HTML，content&lt;br/&gt;；outerHTML：外部HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；innerText：内部文本，content ；outerText：内部文本，content ； 事件流、事件模型JSDOM标准事件流的触发的先后顺序为：先捕获再冒泡，点击DOM节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播 DOM节点添加事件监听方法addEventListener，中参数capture可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为false是事件冒泡，为true是事件捕获，并非所有的事件都支持冒泡，比如focus，blur等等，我们可以通过event.bubbles来判断 事件模型有三个常用方法： event.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播， event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器， event.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播， event.target：指向触发事件的元素，在事件冒泡过程中这个值不变 event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target才会等于currentTarget， 最后，对于执行顺序的问题，如果DOM节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡 事件代理/事件委托不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。 由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件代理或叫事件委托（Event Delegation）。 1.优点 减少内存消耗，提高性能 假设有一个列表，列表之中有大量的列表项，我们需要在点击每个列表项的时候响应一个事件： 1234567&lt;ul id="myList"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; ...... &lt;li&gt;Item n&lt;/li&gt;&lt;/ul&gt; 如果给每个列表项都绑定一个函数，假如此时列表项很多，那无疑对内存的消耗是非常大的，并且效率上需要消耗很多性能。借助事件代理，我们只需要给父容器 ul 绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。 动态绑定事件 在很多时候，我们需要通过用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。 2.如何实现 接下来我们来实现上例中父层元素 #myList 下的 li 元素的事件委托到它的父层元素上： 123456789101112131415161718192021222324// 取得容器var myList = document.getElementById('myList');// 让父层 myList 来监听 click 事件myList.addEventListener('click', function(e)&#123; // 判断目标元素若是 li 则执行 console.log if( e.target.tagName.toLowerCase() === 'li' )&#123; console.log(e.target.textContent); &#125;&#125;, false);// 建立新的 &lt;li&gt; 元素var newList = document.createElement('li');// 建立 textNode 文字节点var textNode = document.createTextNode("Hello world!");// 通过 appendChild 将 textNode 加入至 newListnewList.appendChild(textNode);// 通过 appendChild 将 newList 加入至 myListmyList.appendChild(newList); 我们把click事件改由父层的myList来监听，利用事件传递的原理，判断e.target是我们想要的目标节点时，才去执行后续的动作。 这样的好处是你的事件管理会非常轻松，而且后续加上的newList也会有click的效果，无需另外再去绑定click事件。 BOM事件循环EventLoop详细步骤如下： 1、所有同步任务都在主线程上执行，形成一个执行栈 2、主线程之外，还存在一个”消息队列”。只要异步操作执行完成，就到消息队列中排队 3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 4、主线程不断重复上面的第三步 宏微任务事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。 常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。 常见的 micro-task 比如: process.nextTick、new Promise().then(回调)、MutationObserver(html5 新特性) 等。 宏任务每次执行栈执行的代码就是一个宏任务队列，第一个宏任务队列只有一个任务：执行主线程的js代码 浏览器为了能够使得JS内部Macrotask与DOM任务能够有序的执行，会在一个Macrotask执行结束后，在下一个Macrotask 执行开始前，对页面进行重新渲染，流程如下： 1Macrotask -&gt;渲染-&gt; Macrotask -&gt;... Macrotask主要包含： - script(整体代码) - setTimeout - setInterval - I/O - UI交互事件 - postMessage - MessageChannel - setImmediate(Node.js 环境) 微任务可以理解是在当前 task 执行结束后立即执行的任务。在当前Macrotask后，渲染与下一个Macrotask之前执行。 只有一个微任务队列，上一个宏任务队列执行完毕后如果有微任务队列就执行其中所有微任务，再执行下一个宏任务队列 异步generator promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 Promise的三种状态 Promise的执行顺序当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 promise一旦新建，就会立即执行，无法取消 1234567891011121314function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error(&apos;Could not load image at &apos; + url)); &#125;; image.src = url; &#125;);&#125; // new Promise 使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。// resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 实现面试够用版 来源：实现一个完美符合Promise/A+规范的Promise 1234567891011121314151617181920212223242526function myPromise(constructor)&#123; let self=this; self.status="pending" //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 function resolve(value)&#123; //两个==="pending"，保证了状态的改变是不可逆的 if(self.status==="pending")&#123; self.value=value; self.status="resolved"; &#125; &#125; function reject(reason)&#123; //两个==="pending"，保证了状态的改变是不可逆的 if(self.status==="pending")&#123; self.reason=reason; self.status="rejected"; &#125; &#125; //捕获构造异常 try&#123; constructor(resolve,reject); &#125;catch(e)&#123; reject(e); &#125;&#125; 同时，需要在 myPromise的原型上定义链式调用的 then方法： 123456789101112myPromise.prototype.then=function(onFullfilled,onRejected)&#123; let self=this; switch(self.status)&#123; case "resolved": onFullfilled(self.value); break; case "rejected": onRejected(self.reason); break; default: &#125;&#125; 大厂专供版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108const PENDING = "pending";const FULFILLED = "fulfilled";const REJECTED = "rejected";function Promise(excutor) &#123; let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) &#123; // value成功态时接收的终值 if(value instanceof Promise) &#123; return value.then(resolve, reject); &#125; // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() =&gt; &#123; // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) &#123; // 只能由pending状态 =&gt; fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value)); &#125; &#125;); &#125; function reject(reason) &#123; // reason失败态时接收的拒因 setTimeout(() =&gt; &#123; // 调用reject 回调对应onRejected函数 if (that.status === PENDING) &#123; // 只能由pending状态 =&gt; rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason)); &#125; &#125;); &#125; // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) =&gt; &#123; // throw new Error('error in excutor') // &#125;) try &#123; excutor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;Promise.prototype.then = function(onFulfilled, onRejected) &#123; const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === "function" ? onRejected : reason =&gt; &#123; throw reason; &#125;; if (that.status === FULFILLED) &#123; // 成功态 return newPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try&#123; let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 &#125; catch(e) &#123; reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); &#125; &#125;); &#125;) &#125; if (that.status === REJECTED) &#123; // 失败态 return newPromise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if (that.status === PENDING) &#123; // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return newPromise = new Promise((resolve, reject) =&gt; &#123; that.onFulfilledCallbacks.push((value) =&gt; &#123; try &#123; let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); that.onRejectedCallbacks.push((reason) =&gt; &#123; try &#123; let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125;&#125;; then12345promise.then(function(value) &#123; // success value from resolve(value)&#125;, function(error) &#123;// failure error from reject(error)&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); catchPromise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 1Promise.prototype.catch=(fn(err)) =&gt;&#123; return Promise.prototype.then(null, fn(err));&#125; finally用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 123456789//实现Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; all用于将多个 Promise 实例，包装成一个新的 Promise 实例 Promise.all(iterable) 返回一个新的 Promise 实例。此实例在 iterable 参数内所有的 promise 都 fulfilled 或者参数中不包含 promise 时，状态变成 fulfilled；如果参数中 promise 有一个失败rejected，此实例回调失败，失败原因的是第一个失败 promise 的返回结果。 1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.all 的特点 Promise.all 的返回值是一个 promise 实例 如果传入的参数为空的可迭代对象，Promise.all 会 同步 返回一个已完成状态的 promise 如果传入的参数中不包含任何 promise,Promise.all 会 异步 返回一个已完成状态的 promise 其它情况下，Promise.all 返回一个 处理中（pending） 状态的 promise. Promise.all 返回的 promise 的状态 如果传入的参数中的 promise 都变成完成状态，Promise.all 返回的 promise 异步地变为完成。 如果传入的参数中，有一个 promise 失败，Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组 Promise.all 实现 1Promise.all = function (promises) &#123; //promises 是可迭代对象，省略参数合法性检查 return new Promise((resolve, reject) =&gt; &#123; //Array.from 将可迭代对象转换成数组 promises = Array.from(promises); if (promises.length === 0) &#123; resolve([]); &#125; else &#123; let result = []; let index = 0; for (let i = 0; i &lt; promises.length; i++ ) &#123; //考虑到 i 可能是 thenable 对象也可能是普通值 Promise.resolve(promises[i]).then(data =&gt; &#123; result[i] = data; if (++index === promises.length) &#123; //所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态 resolve(result); &#125; &#125;, err =&gt; &#123; reject(err); return; &#125;); &#125; &#125; &#125;);&#125; racePromise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 1const p = Promise.race([ fetch(&apos;/resource-that-may-take-a-while&apos;), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000) &#125;)]);p.then(console.log).catch(console.error); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 async/awaitasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 正常情况下，await命令后是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。 await只能用在async函数中，不能用在普通函数中 await后面可能存在reject，需要进行try…catch代码块中 优点： 处理 then 的调用链，能够更清晰准确的写出代码； 能优雅地解决回调地狱问题； 适用性更广泛，async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值； 语义性更强，使得异步代码读起来像同步代码，async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 缺点： 多个没有依赖性的异步代码使用 await时， 会导致性能上的降低。 使用 async 声明异步函数。这个函数返回一个 AsyncFunction 对象。AsyncFunction 对象表示该函数中包含的代码的异步函数。 调用使用 async 声明函数时，它返回一个 Promise。当这个函数返回一个值时，这个值只是一个普通值而已，这个函数内部将自动创建一个承诺，并使用函数返回的值进行解析。当这个函数抛出异常时，Promise 将被抛出的值拒绝。 使用 async 声明函数时可以包含一个 await 符号，await 暂停这个函数的执行并等待传递的 Promise 的解析完成，然后恢复这个函数的执行并返回解析后的值。 async/wait 的目的是简化使用Promise的行为 让看看下面的例子: 1234567function getNumber1() &#123; return Promise.resolve(&apos;374&apos;);&#125;// 这个函数与getNumber1相同async function getNumber2() &#123; return 374;&#125; 类似地，抛出异常的函数等价于返回被拒绝的 Promise 的函数: 123456function f1() &#123; return Promise.reject(&apos;Some error&apos;);&#125;async function f2() &#123; throw &apos;Some error&apos;;&#125; await 关键字只能在异步函数中使用，并允许同步等待 Promise。如果在 async 函数之外使用 Promise，仍然需要使用 then 回调: 1234567891011121314151617181920212223242526function loadData() &#123; return getJSON() .then(function(response) &#123; if (response.needsAnotherRequest) &#123; return makeAnotherRequest(response) .then(function(anotherResponse) &#123; console.log(anotherResponse) return anotherResponse &#125;) &#125; else &#123; console.log(response) return response &#125; &#125;)&#125;async function loadData() &#123; var response = await getJSON(); if (response.needsAnotherRequest) &#123; var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse &#125; else &#123; console.log(response); return response; &#125;&#125; AJAX什么是AJAX? AJAX即一种异步请求，可以实现页面局部刷新； AJAX实现的步骤： 创建请求对象 与服务端创建连接，执行open方法； 发送请求，执行send方法； 为请求对象绑定onreadystate事件，当readyState为4 且 status为200时处理数据； 关于readystate五个状态总结如下： readyState 状态说明 (0)未初始化 此阶段确认XMLHttpRequest对象是否创建，并为调用open()方法进行未初始化作好准备。值为0表示对象已经存在，否则浏览器会报错－－对象不存在。 (1)载入 此阶段对XMLHttpRequest对象进行初始化，即调用open()方法，根据参数(method,url,true)完成对象状态的设置。并调用send()方法开始向服务端发送请求。值为1表示正在向服务端发送请求。 (2)载入完成 此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为2表示已经接收完全部响应数据。并为下一阶段对数据解析作好准备。 (3)交互 此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。状态3表示正在解析数据。 (4)完成 此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为4表示数据解析完毕，可以通过XMLHttpRequest对象的相应属性取得数据。 概而括之，整个XMLHttpRequest对象的生命周期应该包含如下阶段：创建－初始化请求－发送请求－接收数据－解析数据－完成 staus状态码： 200 - 成功 404 - 未找到 5** - 服务器错误 原生 Ajax 1234567891011121314151617181920212223242526272829var xhr = new XMLHttpRequest();xhr.open(&apos;post&apos;,&apos;www.xxx.com&apos;,true)//true 开启异步 // 接收返回值xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;// 处理请求参数postData = &#123;&quot;name1&quot;:&quot;value1&quot;,&quot;name2&quot;:&quot;value2&quot;&#125;;postData = (function(value)&#123; var dataString = &quot;&quot;; for(var key in value)&#123; dataString += key+&quot;=&quot;+value[key]+&quot;&amp;&quot;; &#125;; return dataString;&#125;(postData));// 设置HTTP请求头，此方法必须在open()方法和send()之间调用xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);// 异常处理xhr.onerror = function() &#123; console.log(&apos;Network request failed&apos;)&#125;// 默认会携带同源请求的cookie，而跨域请求则不会携带cookie，设置xhr的withCredentials的属性为true将允许携带跨域cookie。xhr.withCredentials = true;// 发出请求xhr.send(postData);//send后HTTP请求才会被真正发出 AJAX封装 1function Ajax(options) &#123; var xhr = null; var params = formsParams(options.data); // 第一步： 创建请求对象 if(window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; // 兼容IE6 xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; // 第二步： 连接，执行open和send方法； if(options.type == &apos;GET&apos;) &#123; xhr.open(options.type, options.url + &apos;?&apos; + params, options.async); xhr.send(); &#125; else if(options.type == &apos;POST&apos;) &#123; xhr.open(options.type, options.url, options.async); xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); xhr.send(params); &#125; // 绑定onreadystatechange事件 xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; options.success(xhr.responseText); &#125; &#125; function formsParams(data) &#123; var arr = []; for(var i in data) &#123; arr.push(i + &apos;=&apos; + data[i]); &#125; arr.join(&apos;&amp;&apos;); &#125;&#125; 使用方法： 1Ajax(&#123; type: &apos;GET&apos;, url: &apos;a.php&apos;, async: true, data: &#123; name: &apos;zhangsan&apos;, age: 10 &#125;, success: function(data) &#123; console.log(data); &#125;&#125;); AJAX的优缺点： 优点： 实现局部刷新 减轻服务器端压力 缺点： 破坏浏览器前进和后退机制； 一个页面ajax请求过多，会造成页面加载缓慢； 数据安全问题不太好，可以采用数据加密的方式； 将原生的ajax封装成promise 123456789101112131415var myNewAjax=function(url)&#123; return new Promise(function(resolve,reject)&#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;,url); xhr.send(data); xhr.onreadystatechange=function()&#123; if(xhr.status==200&amp;&amp;readyState==4)&#123; var json=JSON.parse(xhr.responseText); resolve(json) &#125;else if(xhr.readyState==4&amp;&amp;xhr.status!=200)&#123; reject(&apos;error&apos;); &#125; &#125; &#125;)&#125; 方法节流/防抖1234567891011121314151617181920212223//节流function throttle(fn,delay)&#123; let lastTime = 0; //通过闭包保存lastTime return ()=&gt;&#123; let nowTime = Date.now(); if(nowTime - lastTime &gt; delay)&#123; //修正this指向问题 fn.call(this) lastTime = nowTime &#125; &#125;&#125;//防抖function debounce(fn,delay)&#123; let timer = null return ()=&gt;&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; fn.apply(this) &#125;,delay) &#125; &#125; 数组去重123456789101112//先排序再对比相邻是否相同，只做了一次排序和一次循环，所以效率比较高function distinct(arr) &#123; arr = arr.sort() let result = [arr[0]] for (let i=1, len=arr.length; i&lt;len; i++) &#123; arr[i] !== arr[i-1] &amp;&amp; result.push(arr[i]) &#125; return result&#125;arr.filter((item,index,self)=&gt;&#123; return index===self.indexOf(item)&#125;) 1使用 ES6 中的 Array.filter() 遍历数组，并结合 indexOf 来排除重复项function distinct(arr) &#123; return arr.filter((item, index)=&gt; &#123; return arr.indexOf(item) === index &#125;)&#125;indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置 1function distinct(arr) &#123; return [...new Set(arr)]&#125; 嵌套的数组扁平化例如: 1flattenDeep([1, [2, [3, [4]], 5]]); //[1, 2, 3, 4, 5] 利用 Array.prototype.flat ES6 为数组实例新增了 flat 方法，用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数组没有影响。 flat 默认只会 “拉平” 一层，如果想要 “拉平” 多层的嵌套数组，需要给 flat 传递一个整数，表示想要拉平的层数。 1function flattenDeep(arr, deepLength) &#123; return arr.flat(deepLength);&#125;console.log(flattenDeep([1, [2, [3, [4]], 5]], 3)); 当传递的整数大于数组嵌套的层数时，会将数组拉平为一维数组，JS能表示的最大数字为 Math.pow(2, 53) - 1，因此我们可以这样定义 flattenDeep 函数 1function flattenDeep(arr) &#123; //当然，大多时候我们并不会有这么多层级的嵌套 return arr.flat(Math.pow(2,53) - 1); &#125;console.log(flattenDeep([1, [2, [3, [4]], 5]])); 利用 reduce 和 concat 1function flattenDeep(arr)&#123; return arr.reduce((acc, val) =&gt; Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);&#125;console.log(flattenDeep([1, [2, [3, [4]], 5]])); 使用 stack 无限反嵌套多层嵌套数组 1function flattenDeep(input) &#123; const stack = [...input]; const res = []; while (stack.length) &#123; // 使用 pop 从 stack 中取出并移除值 const next = stack.pop(); if (Array.isArray(next)) &#123; // 使用 push 送回内层数组中的元素，不会改动原始输入 original input stack.push(...next); &#125; else &#123; res.push(next); &#125; &#125; // 使用 reverse 恢复原数组的顺序 return res.reverse();&#125;console.log(flattenDeep([1, [2, [3, [4]], 5]])); 格式化日期1234567891011121314151617181920212223242526// 对Date的扩展，将 Date 转化为指定格式的String// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， // 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) // 例子： // (new Date()).Format(&quot;yyyy-MM-dd hh:mm:ss.S&quot;) ==&gt; 2006-07-02 08:09:04.423 // (new Date()).Format(&quot;yyyy-M-d h:m:s.S&quot;) ==&gt; 2006-7-2 8:9:4.18 Date.prototype.Format = function (fmt) &#123; //author: meizz var o = &#123; &quot;M+&quot;: this.getMonth() + 1, //月份 &quot;d+&quot;: this.getDate(), //日 &quot;h+&quot;: this.getHours(), //小时 &quot;m+&quot;: this.getMinutes(), //分 &quot;s+&quot;: this.getSeconds(), //秒 &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度 &quot;S&quot;: this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125; call/bind/applycall 和 apply 的功能相同，都是改变 this 的执行，并立即执行函数。区别在于传参方式不同。 func.call(thisArg, arg1, arg2, ...)：第一个参数是 this 指向的对象，其它参数依次传入。 func.apply(thisArg, [argsArray])：第一个参数是 this 指向的对象，第二个参数是数组或类数组。 call 在 call 方法中获取调用call()函数 如果第一个参数没有传入，那么默认指向 window / global(非严格模式) 传入 call 的第一个参数是 this 指向的对象，根据隐式绑定的规则，我们知道 obj.foo(), foo() 中的 this 指向 obj;因此我们可以这样调用函数 thisArgs.func(...args) 返回执行结果 12345678910111213Function.prototype.call = function() &#123; let [thisArg, ...args] = [...arguments]; if (!thisArg) &#123; //context为null或者是undefined thisArg = typeof window === &apos;undefined&apos; ? global : window; &#125; //this的指向的是当前函数 func (func.call) thisArg.func = this; //执行函数 let result = thisArg.func(...args); delete thisArg.func; //thisArg上并没有 func 属性，因此需要移除 return result;&#125; apply 12345678910111213141516171819Function.prototype.apply = function(thisArg, rest) &#123; let result; //函数返回结果 if (!thisArg) &#123; //context为null或者是undefined thisArg = typeof window === &apos;undefined&apos; ? global : window; &#125; //this的指向的是当前函数 func (func.call) thisArg.func = this; if(!rest) &#123; //第二个参数为 null / undefined result = thisArg.func(); &#125;else &#123; result = thisArg.func(...rest); &#125; delete thisArg.func; //thisArg上并没有 func 属性，因此需要移除 return result;&#125; bind 通过apply或者call方法来实现。 (1)初始版本 1234567891011121314151617181920212223242526Function.prototype.bind=function(obj,arg)&#123; var arg=Array.prototype.slice.call(arguments,1); var context=this; return function(newArg)&#123; arg=arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); &#125;&#125;Function.prototype.bind=function (context) &#123; if(typeof this !==&apos;function&apos;)&#123; throw new Error(`$&#123;this.name&#125; is not a function`) &#125; const srcFun=this// 保存原始函数 const arg=Array.prototype.slice.call(arguments,1)// 把arguments类数组转为真实数组 let noop=function()&#123;&#125; const fBound= function () &#123; if(this instanceof noop)&#123; context=this &#125; // 合并新旧参数 return srcFun.apply(context,arg.concat(Array.prototype.slice.call(arguments,0))) &#125; if(this.prototype)&#123; noop.prototype=this.prototype//维护原型关系，指向原始函数 &#125; fBound.prototype=new noop()//新函数的prototype的__proto__指向noop.prototype return fBound&#125; (2) 官方实现 通过设置一个中转构造函数F，使绑定后的函数与调用bind()的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的bind()实现。 1234567891011121314151617181920if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== &quot;function&quot;) &#123; // closest thing possible to the ECMAScript 5 internal IsCallable function throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply( this instanceof fNOP &amp;&amp; oThis? this: oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;; &#125; deepCopy1234567891011121314function deepCopy(obj)&#123; //判断是否是简单数据类型， if(typeof obj == "object")&#123; //复杂数据类型 var result = obj.constructor == Array ? [] : &#123;&#125;; for(let i in obj)&#123; result[i] = typeof obj[i] == "object" ? deepCopy(obj[i]) : obj[i]; &#125; &#125;else &#123; //简单数据类型 直接 == 赋值 var result = obj; &#125; return result;&#125; once传入函数参数只执行一次，闭包 12345678910function ones(func)&#123; var tag=true; return function()&#123; if(tag==true)&#123; func.apply(null,arguments); tag=false; &#125; return undefined &#125;&#125; instanceOf123456789function instanceOf(left,right) &#123; let proto = left.__proto__; let prototype = right.prototype while(true) &#123; if(proto == null) return false if(proto == prototype) return true proto = proto.__proto__; &#125;&#125; 简化资源路径栈 1234567891011121314var simplifyPath = function(path) &#123; var result = &apos;&apos; var tempPath = [] var paths = path.split(&apos;/&apos;) paths.map(val =&gt; &#123; if(val &amp;&amp; val === &apos;..&apos;) &#123; tempPath.pop() &#125;else if(val &amp;&amp; val !== &apos;.&apos;) &#123; tempPath.push(val) &#125; &#125;) tempPath.length ? result = &apos;/&apos;+tempPath.join(&apos;/&apos;) : result = &apos;/&apos; return result&#125;; JSON JSON.stringify(value[,replacer[,space]])： Boolean|Number|String 类型会自动转换成对应的原始值。 undefined、任意函数以及 symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。 1234567891011121314151617181920212223242526function jsonStringify(obj) &#123; let type = typeof obj; if (type !== "object" || type === null) &#123; if (/string|undefined|function/.test(type)) &#123; obj = '"' + obj + '"'; &#125; return String(obj); &#125; else &#123; let json = [] arr = (obj &amp;&amp; obj.constructor === Array); for (let k in obj) &#123; let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) &#123; v = '"' + v + '"'; &#125; else if (type === "object") &#123; v = jsonStringify(v); &#125; json.push((arr ? "" : '"' + k + '":') + String(v)); &#125; return (arr ? "[" : "&#123;") + String(json) + (arr ? "]" : "&#125;") &#125;&#125;jsonStringify(&#123;x : 5&#125;) // "&#123;"x":5&#125;"jsonStringify([1, "false", false]) // "[1,"false",false]"jsonStringify(&#123;b: undefined&#125;) // "&#123;"b":"undefined"&#125;" JSON.parse(text[,reviver]) 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。 3.1 第一种：直接调用 eval 123456789function jsonParse(opt) &#123; return eval('(' + opt + ')');&#125;jsonParse(jsonStringify(&#123;x : 5&#125;))// Object &#123; x: 5&#125;jsonParse(jsonStringify([1, "false", false]))// [1, "false", falsr]jsonParse(jsonStringify(&#123;b: undefined&#125;))// Object &#123; b: "undefined"&#125; 避免在不必要的情况下使用 eval，eval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用 eval()运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。 它会执行JS代码，有XSS漏洞。 如果你只想记这个方法，就得对参数json做校验。 1234567891011121314var rx_one = /^[\],:&#123;&#125;\s]*$/;var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g;var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;var rx_four = /(?:^|:|,)(?:\s*\[)+/g;if ( rx_one.test( json .replace(rx_two, "@") .replace(rx_three, "]") .replace(rx_four, "") )) &#123; var obj = eval("(" +json + ")");&#125; 第二种：Function 来源 神奇的eval()与new Function() 核心： Function与 eval有相同的字符串参数特性。 12&gt; varfunc=newFunction(arg1,arg2,...,functionBody);&gt; 在转换JSON的实际应用中，只需要这么做。 12var jsonStr = '&#123; "age": 20, "name": "jack" &#125;'var json = (new Function('return ' + jsonStr))(); eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。 解析 URL Params 为对象123456789let url = 'http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled';parseParam(url)/* 结果&#123; user: 'anonymous', id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型 city: '北京', // 中文需解码 enabled: true, // 未指定值得 key 约定为 true&#125;*/ 1234567891011121314151617181920212223function parseParam(url) &#123; const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来 const paramsArr = paramsStr.split('&amp;'); // 将字符串以 &amp; 分割后存到数组中 let paramsObj = &#123;&#125;; // 将 params 存到对象中 paramsArr.forEach(param =&gt; &#123; if (/=/.test(param)) &#123; // 处理有 value 的参数 let [key, val] = param.split('='); // 分割 key 和 value val = decodeURIComponent(val); // 解码 val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字 if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值 paramsObj[key] = [].concat(paramsObj[key], val); &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值 paramsObj[key] = val; &#125; &#125; else &#123; // 处理没有 value 的参数 paramsObj[param] = true; &#125; &#125;) return paramsObj;&#125; 模板引擎实现123456let template = '我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;';let data = &#123; name: '姓名', age: 18&#125;render(template, data); // 我是姓名，年龄18，性别undefined 123456789function render(template, data) &#123; const reg = /\&#123;\&#123;(\w+)\&#125;\&#125;/; // 模板字符串正则 if (reg.test(template)) &#123; // 判断模板里是否有模板字符串 const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段 template = template.replace(reg, data[name]); // 将第一个模板字符串渲染 return render(template, data); // 递归的渲染并返回渲染后的结构 &#125; return template; // 如果模板没有模板字符串直接返回&#125; 其他Babel与PolyfillBabel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码。注意：Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API。 12345678910111213//使用babel转码前的代码require(&apos;babel-polyfill&apos;);(x =&gt; x * 2)(1);var b = Array.of(1,2,4);//使用babel转码后的代码&apos;use strict&apos;;require(&apos;babel-polyfill&apos;);(function (x) &#123; return x * 2;&#125;)(1);var b = Array.of(1, 2, 4);//Babel转换了ES6的箭头函数句法，但对于Array.of并没有转换，因为Array.of是ES6的API。 Polyfill用于实现浏览器并不支持的原生API的代码。 但ES6的API对于不支持ES6的浏览器，我们通过引入babel-polyfill使其支持ES6的API http://es6.ruanyifeng.com/#docs/promise https://www.nowcoder.com/questionTerminal/cea0cf46505a412d9f635a06806122f4 https://github.com/forthealllight/blog/issues/4 http://es6.ruanyifeng.com/#docs/promise https://zhuanlan.zhihu.com/p/52731370 https://zhuanlan.zhihu.com/p/57548254 https://www.jianshu.com/p/5cb692658704 https://blog.csdn.net/iot_pro/article/details/78511090 https://www.bilibili.com/video/av59639585/?p=17 https://www.jianshu.com/p/996671d4dcc4]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>学习指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化]]></title>
    <url>%2F2019%2F04%2F04%2Foptimization%2F</url>
    <content type="text"><![CDATA[前端页面性能优化技巧 性能优化 关键渲染路径 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。(CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。) 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局。 将各个节点绘制到屏幕上。当DOM或者CSSOM发生变化的时候，浏览器就需要再次执行一次上面的步骤。 当HTML解析过程中遇到一个script标记时，它会暂停DOM构建，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。也就是说，执行内联的JavaScript会阻塞页面的首次渲染。 对JS优化 引用JS方式async，完全的异步操作，HTML解析遇到该标签后，发出网络请求，但不阻止HTML解析和其后面的渲染操作，当JavaScript请求返回后立刻执行，且不等待HTML解析或其他操作的完成。所以，如果脚本中有DOM操作，就并不适合。defer，HTML的解析和对JavaScript资源的网络请求是并行的，但它会等待HTML解析完成之后，才执行脚本。 passive 事件修饰符 流水线的执行方式，后面的工作必须等待前面工作执行完成才能处理，无法将相互独立的工作并行处理。 内核线程负责的工作太多且耗时，一旦遇上内核在执行耗时较长的工作，用户的输入事件将无法立即得到响应。 很多移动端的页面都会监听 touchstart 等 touch 事件，由于 touchstart 事件对象的 cancelable 属性为 true，也就是说它的默认行为可以被监听器通过 preventDefault() 方法阻止，那它的默认行为是什么呢，通常来说就是滚动当前页面（还可能是缩放页面），如果它的默认行为被阻止了，页面就必须静止不动。但浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。 视频里也说了，即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。有 80% 的滚动事件监听器是不会阻止默认行为的，也就是说大部分情况下，浏览器是白等了。所以，passive 监听器诞生了，passive 的意思是“顺从的”，表示它不会对事件的默认行为说 no，浏览器知道了一个监听器是 passive 的，它就可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了。passive设置为true可以大幅提高移动端的滑动流畅度 12345document.addEventListener(type, listener, &#123; capture: false, // 等价于以前的 useCapture 参数 passive: false, // Firefox 和 Chrome 已经实现 once: false // 表明该监听器是一次性的，执行一次后就被自动 removeEventListener 掉，还没有浏览器实现它&#125;) 开启多线程使用Web Worker为JS创造多线程环境，主线程创建Worker线程，将一些计算密集型或高延迟的任务分配给后者运行 Web AssemblyWeb Assembly特别适合那些需要非常高性能的Web产品，提供了一种转换机制，把高级语言（C、C++、Go）编译为Web Assembly字节码，以便在浏览器中运行，能够大幅提高运行效率。使用WebAssembly对浏览器API进行任何调用时，目前还需要JS进行交互，用JS作为入口。未来WebAssembly可能被浏览器内置支持，并使其能够直接调用DOM，Web Workers或其他浏览器API等 注意事项：同源限制、DOM 限制、不能读取本地文件、使用消息通信、不能使用alert、confirm、prompt Canvas 优化 避免浮点数的坐标点，用整数取而代之 在离屏canvas上预渲染相似的图形或重复的对象 不要在用drawImage时缩放图像 使用多层画布去画一个复杂的场景 用CSS设置大的背景图 不需要透明度时关闭alpha通道 渲染画布中的不同点，而非整个新状态 谨慎使用大型物理库 对CSS优化 尽早和按需的加载CSS 内联CSS来提高渲染性能 写样式尽量使用class和id，保证层级扁平，减少过度层叠 避免使用CSS表达式举个css表达式的例子 font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF” : “#AAAAAA” );这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。 不同浏览器首屏渲染策略不同。chrome等CSS加载完再渲染，Firefox先生成HTML再附上CSS (1) 选择器优化注意优先级，慎用!important，样式系统从最右边的选择符开始向左进行匹配规则。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。写法注意点： id选择器肯定是最快，但是不要在ID选择器使用的同时再使用标签或类选择器了 不要使用类选择器时用标签选择器 特别是for循环中js编写html代码时直接定义样式类名到所需要作用的元素，之后尽量用一个选择器写样式，可以大幅提高渲染效率 如果明确dom结构，优先使用子选择器，减少后代选择器使用 使用类选择器替代后代选择器和子选择器 避免使用通配符选择器（*）和属性选择器 (2) 谨慎使用 CSS3 特性CSS3一些新特性能带来酷炫的视觉效果，但对设备性能有一定要求 border-radius gradient box-shadow box-reflect text-stroke，text-fill 减少HTTP请求 尽量少使用外链的JS和CSS文件以前CSS的@import 雪碧图，尽量合并图片、CSS、JS 渲染必备CSS内联到HTML中 缓存策略 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 可缓存的AJAX异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存 123456$.ajax(&#123; url : &apos;url&apos;, dataType : &quot;json&quot;, cache: true, success : function(son, status)&#123; &#125; 减少Cookie的大小Cookie里面别塞那么多东西，因为每个请求都得带着他跑 使用无cookie的域比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。 减少资源的大小 压缩、去注释 JavaScript 和 CSS 使用gzip压缩内容gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。 延迟JavaScript非阻塞资源加载 删除未使用的代码 异步懒加载代码 懒加载屏幕外图片 预先加载关键请求 HTTP的传输层协议是TCP，TCP协议有一个慢启动的过程，即它在第一次传递数据时，只能同时传递14kb的数据块，所以当数据超多14kb时，TCP协议传递数据实际是多次的往返（roundtrip）。如果能够将渲染所需要的资源控制在14kb之内，那么就能TCP协议启动时，一次完成数据的传递。 CDN使用CDN网站上静态资源即css、js、图片全都使用cdn分发 使用DNS prefech DNS预解析使浏览器试图在用户访问链接之前解析域名,在head中添加对应属性即可，如下 DNS预解析是浏览器试图在用户访问链接之前解析域名，这是计算机的正常DNS解析机制。 域名解析后，如果用户确实访问该域名，那么DNS解析时间将不会有延迟。 最明显的例子，DNS预解析在某个页面中包含非常多的域名非常有效，如搜索结果页。遇到网页中的超链接，DNS prefetching从中提取域名并将其解析为IP地址，这些工作在用户浏览网页时，使用最少的CPU和网络在后台进行解析。当用户点击这些已经预解析的域名，可以平均减少200毫秒耗时（假设用户最近还未访问过该域名），更重要的是用户不会遇到DNS解析最坏的情况（往往超过1秒）。 DNS Prefetch，即DNS预获取，是前端优化的一部分。一般来说，在前端优化中与 DNS 有关的有两点： 一个是减少DNS的请求次数， 另一个就是进行DNS预获取 。 DNS 作为互联网的基础协议，其解析的速度似乎很容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。 DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能 减少用户的等待时间，提升用户体验 。 DNS Prefetch 应该尽量的放在网页的前面，推荐放在 &lt;meta charset=&quot;UTF-8&quot;&gt; 后面 预解析的实现： 1、用meta信息来告知浏览器, 当前页面要做DNS预解析:&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt; 2、在页面header中使用link标签来强制对DNS预解析: &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt; 预解析的实现： 1、用meta信息来告知浏览器, 当前页面要做DNS预解析: 2、在页面header中使用link标签来强制对DNS预解析: 如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签： 1&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt; 图像JPG/JPEG优点JPG的压缩方式（有损压缩）是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求 缺陷处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会明显不支持透明度处理 使用场景背景图、轮播图或 Banner 图 PNG优点PNG是一种无损压缩的高保真的图片格式。8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。 缺点 体积太大。 使用场景小的 Logo、颜色简单且对比强烈的图片或背景 SVG优点SVG 指可伸缩矢量图形 ，属于对图像的形状描述，本质上是文本文件，体积较小，且不管放大多少倍都不会失真。 缺点绘制太复杂 使用场景LOGO 使用方法 直接插入网页，成为 DOM 的一部分 12345678&lt;svg id=&quot;mysvg&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 800 600&quot; preserveAspectRatio=&quot;xMidYMid meet&quot;&gt; &lt;circle id=&quot;mycircle&quot; cx=&quot;400&quot; cy=&quot;300&quot; r=&quot;50&quot; /&gt;&lt;svg&gt; 写在一个独立文件中，然后用、、、等标签插入网页 1234&lt;img src=&quot;circle.svg&quot;&gt;&lt;object id=&quot;object&quot; data=&quot;circle.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;&lt;embed id=&quot;embed&quot; src=&quot;icon.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;icon.svg&quot;&gt;&lt;/iframe&gt; 转为 BASE64 编码，然后作为 Data URI 写入网页。 1&lt;img src=&quot;data:image/svg+xml;base64,[data]&quot;&gt; 重要属性 123fill：填充色stroke：描边色stroke-width：边框宽度 WebP优点与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。WebP 是谷歌引入的一种相对较新的格式，它的目标是通过以无损和有损格式编码图像来提供更小的文件大小，使其成为 JPEG 和 PNG 的一个很好的替代方案。WebP 图像的清晰度通常可以与 JPEG 和 PNG相提并论，而且文件大小要小得多。 缺点浏览器支持度不够 使用方式一旦有了 WebP 图像，可以使用以下标记将它们提供给可以使用它们的浏览器，同时向不兼容 WebP 的浏览器使用 png 或者 jpeg。 12345&lt;picture&gt; &lt;source srcset=&quot;sample_image.webp&quot; type=&quot;image/webp&quot;&gt; &lt;source srcset=&quot;sample_image.jpg&quot; type=&quot;image/jpg&quot;&gt; &lt;img src=&quot;sample_image.jpg&quot; alt=&quot;&quot;&gt;&lt;/picture&gt; 理解 image/webp 媒体类型的浏览器将下载 Webp 图片并显示它，而其他浏览器将下载 JPEG 图片。任何不支持 的浏览器都将跳过所有 source 标签，并加载底部 img 标签。因此，我们通过提供对所有浏览器类的支持，逐步增强了我们的页面。*可以根据不同的条件加载不同的图像，这些条件可以是视窗当前的高度（viewport），宽度（width），方向（orientation），像素密度（dpr） 网络字体在网络加载比较慢的情况下，用户可能会感受到字体或者图形的变化（Icon Font）。其实，浏览器在渲染树构建完成之后，会指示需要哪些字体在网页上渲染指定文本，然后分派字体请求，浏览器执行布局并将内容绘制到屏幕上，如果字体尚不可用，浏览器可能不会渲染任何文本像素，待字体可用之后，再绘制文本像素，当然，不同浏览器之间实际行为有所差异 123@font-face&#123; font-display:wrap;&#125; Font display 可帮助你根据交换所需的时间来决定网络字体的渲染或退阶方式。 其他 避免空的src和href当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。 避免跳转有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http://baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 http://baidu.com/（注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。另一种是不用域名之间的跳转， 比如访问 http://baidu.com/bbs 跳转到http://bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。 减少DOM元素数量就会减少浏览器的解析负担 避免404比如外链的css或者js文件出现问题返回404时，会破坏浏览器对文件的并行加载。并且浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。 不要使用滤镜IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 参考资料https://zhuanlan.zhihu.com/p/58419577http://www.ruanyifeng.com/blog/2018/08/svg.htmlhttps://zhuanlan.zhihu.com/p/38548289《高性能网站建设指南（第二版》 https://zhuanlan.zhihu.com/p/81090955]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL操作一览]]></title>
    <url>%2F2019%2F02%2F23%2FMySQL%2F</url>
    <content type="text"><![CDATA[SQL基本操作指令 MySQL操作一览 BY wid一、概念 SQL即为Structured Query Language(结构化查询语言) MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格: 表头(header): 每一列的名称; 列(column): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息,每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\物的方法,键的值在当前列中具有唯一性。一、安装信息配置的端口：3306 用户：Root:539450;CatcherInSky:zxc123 Windows Service Name: MySQL57 服务：控制面板-&gt;系统与安全-&gt;管理工具-&gt;服务 可停用、重启与卸载MySQL服务 路径：C:\Program Files\MySQL\MySQL Server 5.7\bin 二、基础操作1.用户行为 2.1.1.登录cmd进入安装路径，输入 mysql -D 数据库名 -h 主机名 -u 用户名 -p； 2.库的操作 2.2.1创建数据库 create database 数据库名 其它选项； 2.2.2查看数据库 show databases； 2.2.3登录数据库 use 数据库名（库声明）; 声明如： character set gbk 可将数据库字符编码指定为 gbk 2.2.4删除数据库 drop database 数据库名; .表的操作 2.3.1创建数据库表 create table 表名称(列声明); 对于一些较长的语句在命令提示符下可能容易输错,因此我们可以通过任何文本编辑器将语句输入好后保存为 createtable.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。 mysql -D samp_db -u root -p &lt; createtable.sql； (提示: 1.如果连接远程主机请加上 -h 指令; 2. 该文件若不在当前工作目录下需指定文件的完整路径。) 列声明首项为列的名称后面为数据类型描述。 2.3.2查看数据库表 查看所有表名称 show tables; 查看某个表的详细信息 describe 表名; 2.3.4删除数据库表 drop table 表名; 2.3.5重命名数据库表 alter table 表名 rename 新表名; 2.3.6修改数据库表alter table 语句用于创建后对表的修改, 基础用法如下: 2.3.6.1添加列 alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例:在表的最后追加列 address: alter table students add address char(60); 示例：在名为 age 的列后插入列 birthday: alter table students add birthday date after age; 2.3.6.2修改列 alter table 表名 change 列名称 列新名称 新数据类型; 示例：将表 tel 列改名为 telphone alter table students change tel telphone char(13) default “-“; 示例：将 name 列的数据类型改为 char(16) alter table students change name name char(16) not null; 2.3.6.3删除列 alter table 表名 drop 列名称; 示例:删除 birthday 列: alter table students drop birthday; 4.值的操作 2.4.1插入数据 insert [into] 表名 [(列名1, 列名2, …)] values (值1, 值2, …); 从第一列数据开始写全部数据 insert into students values(NULL, “王刚”, “男”, 20,”13811371377”); 从某列开始写部分数据 insert into students (name, sex, age) values(“孙丽华”, “女”, 21); 2.4.2查询表中的数据 select 列名称 from 表名称 where 特定条件; 也可以使用通配符 * 查询表中所有的内容。where 子句不仅仅支持 “where 列名 = 值” 这种名等于值的查询形式,对一般的比较运算的运算符都是支持的, 例如 =、&gt;、&lt;、&gt;=、&lt;、!=以及一些扩展运算符 is [not] null、in、like 等等。 还可以对查询条件使用 or 和 and 进行组合查询 示例:查询年龄在21岁以上的所有人信息: select * from students where age &gt; 21; 示例:查询名字中带有 “王” 字的所有人信息: select * from students where name like “%王%”; 示例:查询id小于5且年龄大于20的所有人信息: select * from students where id20; 2.4.3更新表中的数据 update 表名称 set 列名称=新值 更新条件; 2.4.4删除表中数据 delete from 表名称 where 删除条件; 不加条件删除所有数据]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>DataBase</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js]]></title>
    <url>%2F2019%2F02%2F23%2FNodejs%2F</url>
    <content type="text"><![CDATA[Node.js学习记录 Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的 API，事件循环机制也是它里面的实现 轮询机制通过libuv库实现 uv_run函数分为六个阶段 timers 定时器阶段计时和执行到点的定时器回调函数 pending callbacks某些系统操作（如TCP错误类型）的回调函数 idle.prepare准备工作 poll 轮询阶段如果轮询队列不为空，依次同步取出轮询队列中第一个回调函数执行，直到轮询队列为空或达到系统最大限制；如果轮询队列为空：如果有setImmediate，直接进入下个check阶段； 如果没有就在poll阶段等待，直到轮询队列添加了新的回调函数或者定时器到点就去下个check阶段； check执行setImmediate设置的回调函数 close/callbacks 关闭阶段执行close事件回调函数 process.nextTick这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 外部输入数据–&gt;轮询阶段(poll)–&gt;检查阶段(check)–&gt;关闭事件回调阶段(close callback)–&gt;定时器检测阶段(timer)–&gt;I/O 事件回调阶段(I/O callbacks)–&gt;闲置阶段(idle, prepare) timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调 I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调 idle, prepare 阶段：仅 node 内部使用 poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里 check 阶段：执行 setImmediate() 的回调 close callbacks 阶段：执行 socket 的 close 事件回调 日常开发中的绝大部分异步任务都是在timers、poll、check`这 3 个阶段处理的。 (1) timer timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。 (2) poll poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情 回到 timer 阶段执行回调 执行 I/O 回调 并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制 如果 poll 队列为空时，会有两件事发生 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。 (3) check 阶段 setImmediate()的回调会被加入 check 队列中，从 event loop 的阶段图可以知道，check 阶段的执行顺序在 poll 阶段之后。 注意 setImmediate 设计在 poll 阶段完成时执行，即 check 阶段； setTimeout 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行 简单实现Node的Events模块参考回答：简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 node中的Events模块就是通过观察者模式来实现的： 123456var events=require(&apos;events&apos;);var eventEmitter=new events.EventEmitter();eventEmitter.on(&apos;say&apos;,function(name)&#123;console.log(&apos;Hello&apos;,name);&#125;)eventEmitter.emit(&apos;say&apos;,&apos;Jony yu&apos;); 这样，eventEmitter发出say事件，通过On接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个Events模块的EventEmitter。 (1)实现简单的Event模块的emit和on方法 12345678910111213141516171819function Events()&#123;this.on=function(eventName,callBack)&#123;if(!this.handles)&#123;this.handles=&#123;&#125;;&#125;if(!this.handles[eventName])&#123;this.handles[eventName]=[];&#125;this.handles[eventName].push(callBack);&#125;this.emit=function(eventName,obj)&#123;if(this.handles[eventName])&#123;for(var i=0;o&lt;this.handles[eventName].length;i++)&#123;this.handles[eventName][i](obj);&#125;&#125;&#125;return this;&#125; 这样我们就定义了Events，现在我们可以开始来调用： 12345var events=new Events();events.on(&apos;say&apos;,function(name)&#123;console.log(&apos;Hello&apos;,nama)&#125;);events.emit(&apos;say&apos;,&apos;Jony yu&apos;); //结果就是通过emit调用之后，输出了Jony yu (2)每个对象是独立的 因为是通过new的方式，每次生成的对象都是不相同的，因此： 12345678910var event1=new Events();var event2=new Events();event1.on(&apos;say&apos;,function()&#123;console.log(&apos;Jony event1&apos;);&#125;);event2.on(&apos;say&apos;,function()&#123;console.log(&apos;Jony event2&apos;);&#125;)event1.emit(&apos;say&apos;);event2.emit(&apos;say&apos;); //event1、event2之间的事件监听互相不影响 //输出结果为’Jony event1’ ‘Jony event2’ https://zhuanlan.zhihu.com/p/54882306 实现Event(event bus)event bus既是node中各个模块的基石，又是前端组件通信的依赖手段之一，同时涉及了订阅-发布设计模式，是非常重要的基础。 简单版： 12345678910111213141516171819202122232425262728class EventEmeitter &#123; constructor() &#123; this._events = this._events || new Map(); // 储存事件/回调键值对 this._maxListeners = this._maxListeners || 10; // 设立监听上限 &#125;&#125;// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; // 从储存事件键值对的this._events中获取对应事件回调函数 handler = this._events.get(type); if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; // 将type事件以及对应的fn函数放入this._events中储存 if (!this._events.get(type)) &#123; this._events.set(type, fn); &#125;&#125;; 面试版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class EventEmeitter &#123; constructor() &#123; this._events = this._events || new Map(); // 储存事件/回调键值对 this._maxListeners = this._maxListeners || 10; // 设立监听上限 &#125;&#125;// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; // 从储存事件键值对的this._events中获取对应事件回调函数 handler = this._events.get(type); if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; // 将type事件以及对应的fn函数放入this._events中储存 if (!this._events.get(type)) &#123; this._events.set(type, fn); &#125;&#125;;// 触发名为type的事件EventEmeitter.prototype.emit = function(type, ...args) &#123; let handler; handler = this._events.get(type); if (Array.isArray(handler)) &#123; // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数 for (let i = 0; i &lt; handler.length; i++) &#123; if (args.length &gt; 0) &#123; handler[i].apply(this, args); &#125; else &#123; handler[i].call(this); &#125; &#125; &#125; else &#123; // 单个函数的情况我们直接触发即可 if (args.length &gt; 0) &#123; handler.apply(this, args); &#125; else &#123; handler.call(this); &#125; &#125; return true;&#125;;// 监听名为type的事件EventEmeitter.prototype.addListener = function(type, fn) &#123; const handler = this._events.get(type); // 获取对应事件名称的函数清单 if (!handler) &#123; this._events.set(type, fn); &#125; else if (handler &amp;&amp; typeof handler === "function") &#123; // 如果handler是函数说明只有一个监听者 this._events.set(type, [handler, fn]); // 多个监听者我们需要用数组储存 &#125; else &#123; handler.push(fn); // 已经有多个监听者,那么直接往数组里push函数即可 &#125;&#125;;EventEmeitter.prototype.removeListener = function(type, fn) &#123; const handler = this._events.get(type); // 获取对应事件名称的函数清单 // 如果是函数,说明只被监听了一次 if (handler &amp;&amp; typeof handler === "function") &#123; this._events.delete(type, fn); &#125; else &#123; let postion; // 如果handler是数组,说明被监听多次要找到对应的函数 for (let i = 0; i &lt; handler.length; i++) &#123; if (handler[i] === fn) &#123; postion = i; &#125; else &#123; postion = -1; &#125; &#125; // 如果找到匹配的函数,从数组中清除 if (postion !== -1) &#123; // 找到数组对应的位置,直接清除此回调 handler.splice(postion, 1); // 如果清除后只有一个函数,那么取消数组,以函数形式保存 if (handler.length === 1) &#123; this._events.set(type, handler[0]); &#125; &#125; else &#123; return this; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F12%2F24%2FcrossOrigin%2F</url>
    <content type="text"><![CDATA[常用跨域方法汇总 什么是跨域同源策略同源指 协议 域名 端口 相同为同源，即便两个不同的域名指向同一个 ip 地址，也非同源。浏览器的同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。 触发跨域错误浏览器端的限制（服务端收到了请求并正确返回）发送的是 XMLHttpRequest 请求（使用 img 标签发送的请求为 json 类型，并不会报错）请求了不同域的资源 CSRF服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中。如果没有同源策略的限制，盗用cookie进行请求进行CSRF攻击。 方法JSONPJSONP，是 JSON with Padding 的简称，它是 json 的一种补充使用方式，利用 script 标签来解决跨域问题。JSONP 是非官方协议，他只是前后端一个约定，如果请求参数带有约定的参数，则后台返回 javascript 代码而非 json 数据，返回代码是函数调用形式，函数名即约定值，函数参数即要返回的数据。 首先在客户端 js 中定义一个函数（假设名为 handler），然后动态创建一个 script 标签插入页面中，script 标签的 src 属性即要调用的地址，同时，在调用的 url 中加入一个服务端约定的参数（假设名为 callback，参数值为已定义的函数名 handler），服务端收到请求，如果发现请求的 url 中带有约定的参数，那么就返回一段函数调用形式的 javascript 代码，该段代码的函数名即为 callback 参数的值 handler，函数的参数即为待返回的数据。这样，客户端拿到返回结果后就会执行 handler 函数，对返回的数据进行处理。 存在以下缺陷：1.只能发送 GET 请求2.发送的不是 XHR 请求，这样导致 XHR 请求中的很多事件都无法进行处理3.服务端需要改动 ## 1234567891011function jsonp(url, callback, success) &#123; var script = document.createElement(&apos;script&apos;); script.src = url; script.async = true; script.type = &apos;text/javascript&apos;; window[callback] = function(data) &#123; success &amp;&amp; success(data); &#125; document.body.appendChild(script);&#125; ### 空iframe加formJSONP只能发GET请求，因为本质上script加载资源就是GET，用这个方法发POST请求 后端写个小接口 12345678910// 处理成功失败返回格式的工具const &#123;successBody&#125; = require(&apos;../utli&apos;)class CrossDomain &#123; static async iframePost (ctx) &#123; let postData = ctx.request.body console.log(postData) ctx.body = successBody(&#123;postData: postData&#125;, &apos;success&apos;) &#125;&#125;module.exports = CrossDomain 前端 12345678910111213141516171819202122232425262728293031323334353637const requestPost = (&#123;url, data&#125;) =&gt; &#123; // 首先创建一个用来发送数据的iframe. const iframe = document.createElement(&apos;iframe&apos;) iframe.name = &apos;iframePost&apos; iframe.style.display = &apos;none&apos; document.body.appendChild(iframe) const form = document.createElement(&apos;form&apos;) const node = document.createElement(&apos;input&apos;) // 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话. iframe.addEventListener(&apos;load&apos;, function () &#123; console.log(&apos;post success&apos;) &#125;) form.action = url // 在指定的iframe中执行form form.target = iframe.name form.method = &apos;post&apos; for (let name in data) &#123; node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode()) &#125; // 表单元素需要添加到主文档中. form.style.display = &apos;none&apos; document.body.appendChild(form) form.submit() // 表单提交后,就可以删除这个表单,不影响下次的数据发送. document.body.removeChild(form)&#125;// 使用方式requestPost(&#123; url: &apos;http://localhost:9871/api/iframePost&apos;, data: &#123; msg: &apos;helloIframePost&apos; &#125;&#125;) postMessage 跨域postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 123456789101112131415161718192021//捕获iframevar domain = "http://scriptandstyle.com";var iframe = document.getElementById("myIFrame").contentWindow;//发送消息setInterval(function() &#123; var message = "Hello! The time is: " + new Date().getTime(); console.log("blog.local: sending message: " + message); //send the message and target URI iframe.postMessage(message, domain);&#125;, 6000);//响应事件window.addEventListener( "message", function(event) &#123; if (event.origin !== "http://davidwalsh.name") return; console.log("message received: " + event.data, event); event.source.postMessage("holla back youngin!", event.origin); &#125;, false); postMessage跨域适用于以下场景：同浏览器多窗口间跨域通信、iframe间跨域通信。 CORS”跨域资源共享”（Cross-origin resource sharing）需要浏览器和后端同时支持服务端设置 Access-Control-Allow-Origin 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 Access-Control-Allow-Origin简单说，允许跨域访问的host，必须设置，否则不允许跨域。 // 如需允许所有资源都可以访问您的资源，您可以如此设置：Access-Control-Allow-Origin: * // 如需允许https://developer.mozilla.org访问您的资源，您可以设置：Access-Control-Allow-Origin: https://developer.mozilla.orgAccess-Control-Allow-Credentials如果想跨域传输cookies,需要Access-Control-Allow-Credentials与XMLHttpRequest.withCredentials 或Fetch API中的Request() 构造器中的credentials 选项结合使用。Credentials必须在前后端都被配置（即the Access-Control-Allow-Credentials header 和 XHR 或Fetch request中都要配置）才能使带credentials的CORS请求成功。 Access-Control-Request-Method允许跨域的请求的方法。 Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headersresponse的header中Access-Control-Allow-Headers 用于 preflight request （即会在实际请求发送之前先发送一个option请求）中，列出了将会在正式请求的 Access-Control-Expose-Headers 字段中出现的首部信息。 简单首部，如 simple headers、Accept、Accept-Language、Content-Language、Content-Type （只限于解析后的值为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 三种MIME类型（不包括参数）），它们始终是被支持的，不需要在这个首部特意列出。 preflight request–options请求很多人在抓包时会很郁闷怎么会无端端多出了一个OPTIONS请求，请不要奇怪，这只是CORS策略的预检请求，就像你要去跟别人借个东西，要先问问对方肯不肯一样。 什么情况下会发送OPTIONS请求？简单的说，就是有自定义headers，Content-Type的值不属于下列之一:application/x-www-form-urlencoded，multipart/form-data，text/plain的请求会触发OPTIONS请求。如果产生OPTIONS请求，需要后台去响应它，允许它跨域。 简单请求：只要同时满足以下两大条件，就属于简单请求条件 1：使用下列方法之一： GET HEAD POST 条件 2：Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded document.domain 的值可以设置为其当前域或其当前域的父域，来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值。 Nginx代理 https://segmentfault.com/a/1190000015597029 https://zhuanlan.zhihu.com/p/53545472 https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy https://zhuanlan.zhihu.com/p/67489101 https://zhuanlan.zhihu.com/p/57991633]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Console 对象]]></title>
    <url>%2F2018%2F11%2F24%2Fconsole%2F</url>
    <content type="text"><![CDATA[了解console.log对象可以更好地调试代码 Console 对象用于 JavaScript 调试。JavaScript 原生中默认是没有 Console 对象,这是宿主对象（也就是游览器）提供的内置对象。 用于访问调试控制台, 在不同的浏览器里效果可能不同。 Console 对象常见的两个用途： 显示网页代码运行时的错误信息。 提供了一个命令行接口，用来与网页代码互动。 Chrome和大部分浏览器都可以通过F12调出这个窗口 在console面板输入 for(var i in console){console.log(i)} 可列出所有Console方法 log()console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）: 占位符 作用 %s 字符串 %d or %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串 在console.log里使用CSS： info() warn() error() assert()assert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 clear()清除当前控制台的所有输出，将光标回置到第一行。 count()用于计数，输出它被调用了多少次。 group() /groupCollapsed()/ groupEnd()用于将显示的信息分组，可以把信息进行折叠和展开。 与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 table()将复合类型的数据转为表格显示 time()计时 trace()追踪函数的调用过程 dirxml()用来显示网页的某个节点（node）所包含的html/xml代码。 profile() 性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在。 123456789101112131415function All() &#123; for (var i = 0; i &lt; 10; i++) &#123; funcA(1000); &#125; funcB(10000); &#125;function funcA(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125; &#125;function funcB(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125; &#125;console.profile(&apos;性能分析器&apos;);All(); console.profileEnd(); dir()console.dir()方法用来对一个对象进行检查，并以易于阅读和打印的格式显示。类似于log()，但可以显示一个对象所有的属性和方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp正则表达式]]></title>
    <url>%2F2018%2F07%2F13%2Fregexp%2F</url>
    <content type="text"><![CDATA[JS中常用正则表达式操作 正则表达式 定义正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、RegExp或RE），计算机科学的一个概念。在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 测试Javascript正则表达式在线测试工具[https://www.regexpal.com/][https://regexr.com/] 作用：在字符串操作中常用于： 验证（给定的字符串是否符合正则表达式的过滤逻辑） 验证输入是否符合规范 查找（可以通过正则表达式，从字符串中获取我们想要的特定部分） 查找所需字符段落 替换成自己想要的内容 还有一些特殊的操作 在HTML中可以这样使用 12345&lt;style&gt;input:invalid &#123; border-color: red; &#125; input, input:valid &#123; border-color: #ccc; &#125;&lt;/style&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; placeholder=&quot;tel&quot; pattern=&quot;\d&#123;11&#125;&quot;&gt; 声明123var expression = / pattern / flags;var expression = new RegExp(&quot; patterns &quot; , &quot; flags &quot;);//patterns为pattern中每个元字符前加一个\组成或者由字符串加变量组成 expression：正则表达式的名称 pattern：正则表达式的模式 flags：标志，包括 g:global,应用于所有字符串，而非在发现第一个匹配项时立即停止 i:case-insesitive,忽略大小写 m:multiline,多行检测 u:Unicode,用来正确处理大于\uFFFFd Unicode字符注意：点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码位大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符 y:sticky,y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 实例属性 属性 数据类型 意义 global boolean 是否有g标志 ignoreCase boolean 是否有i标志 multiline boolean 是否有m标志 lastIndex int 从第几个字符开始匹配 source str 正则表达式的字符串表示 flags str 正则表达式的修饰符 sticky boolean 是否有y标签 RegExp实例方法regObj.test(strObj)用于测试字符串中是否存在符合正则表达式模式的部分，如果存在则返回true，否则返回false。123456789var test = function()&#123; var PhoneNumber = /^\d&#123;11&#125;$/; var number1 = &quot;17802015408&quot;; var number2 = &quot;1530775669&quot;; var number3 = &quot;178020154080&quot;; console.log(&quot;number1 is a &quot; + PhoneNumber.test(number1) + &quot; phone number.&quot;); console.log(&quot;number2 is a &quot; + PhoneNumber.test(number2) + &quot; phone number.&quot;); console.log(&quot;number3 is a &quot; + PhoneNumber.test(number3) + &quot; phone number.&quot;);&#125;() regObj.exec(strObj)方法用于正则表达式模式在字符串中运行查找，如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。 调用非全局的 RegExp对象的 exec() 时，返回数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个分组相匹配的文本（如果有的话），第 2 个元素是与 RegExp对象的第 2 个分组相匹配的文本（如果有的话），以此类推。 调用全局的RegExp对象的 exec() 时，它会在 RegExp实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExp实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。1234567891011121314151617181920212223242526272829//无g标志var execs = function()&#123; var text = &quot;abababab&quot;; var pattern = /ab(ab)/; console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex);&#125;()//有g标志var execg = function()&#123; var text = &quot;AbAbBCAb&quot;; var pattern = /Ab|BC/g; //pattern.lastIndex = 1; //改变lastIndex属性 console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex);&#125;() 字符串方法strObj.search(RegObj)search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。没有匹配则返回-1。 12345678910var search = function()&#123; var text = &quot;asdfasAAAAAA&quot;; var pattern = /AA/g; var te = &quot;AA&quot; console.log(text.search(pattern)); console.log(text.indexOf(te)); var example = &quot;adfasd9ad1s1f&quot;; var pattern2 = /\d/g; console.log(example.charAt(example.search(pattern2)))；&#125;() strObj.match(RegObj)字符串对象的match方法与正则对象的exec方法比较类似，但是如果正则表达式带有g修饰符，那么match方法就可以以数组的方式返回所有成功匹配的结果，但是exec方法只返回了一个。如果不带g，则是返回其分组结果。 12345var match = function()&#123; var text=&quot;asdfasdasdfasdfadsf&quot; var pattern = /a(sd)/g; console.log(text.match(pattern))&#125;() strObj.replace(regObj,replaceStr|function(){})1stringObject.replace(regexp/substr,replacement) 字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 \$1、\$2、…、\$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 \$&amp; 与 regexp 相匹配的子串。 \$` 位于匹配子串左侧的文本。 \$’ 位于匹配子串右侧的文本。 \$$ 直接量符号。 注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。1234567891011121314//不使用正则var replace = function()&#123; var text = &apos;1&lt;%2%&gt;34&lt;%567%&gt;89&apos;; text = text.replace(&apos;&lt;&apos;,&apos;@&apos;); text = text.replace(&apos;%&apos;,&apos;#&apos;); text = text.replace(&apos;&gt;&apos;,&apos;@&apos;); console.log(text);&#125;()//使用正则var replace = function()&#123; var text = &apos;1&lt;%2%&gt;34&lt;%567%&gt;89&apos;; text = text.replace(/&lt;%(\d+)%&gt;/g,&apos;@#$1#@&apos;); console.log(text);&#125;() strObj.split(regObj)1stringObject.split(separator,howmany) 一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。返回的数组中的字串不包括 separator 自身。 但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。123456var split = function()&#123; text = &apos;a1b2c3d&apos; console.log(text.split(/\d/)); name = &quot;asfasdf,fadf./asdf.asdf[asdf&quot; console.log(name.split(/\W/));&#125;() 语法元字符( [ { \ ^ $ | ) ? * + . 预定义的特殊字符 字符 描述 \t 制表符 \n 换行符 \r 回车符 \f 换页符 \a alert字符 \e escape字符 \cX / 与X相对应的控制字符 \b 与回退字符 \v 垂直制表符 \0 空字符 分枝条件继续在分组上做文章。在分组中插入管道符（“|”），把它划分为两个或多个候多项。1234var reg = /(red|black|yellow)!!/;alert(reg.test(&quot;red!!&quot;))//truealert(reg.test(&quot;black!!&quot;))//truealert(reg.test(&quot;yellow!!&quot;))//true 边界一个要与字符类合用的东西。 边界|正则 |名称| 描述||—|—|—||^| 开头| 注意不能紧跟于左中括号的后面||$| 结尾||\b| 单词边界| 指[a-zA-Z_0-9]之外的字符||\B |非单词边界 |单词边界举例。要匹配的东西的前端或未端不能为英文字母阿拉伯字数字或下横线。12var str = &quot;12w-eefd&amp;efrew&quot;;alert(str.match(/\b\w+\b/g))//12w,eefd,efrew 字符类简单类原则上正则的一个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。如12345alert(/abc/.test(&quot;abc&quot;));//truealert(/[abc]/.test(&quot;a&quot;));//truealert(/[abc]/.test(&quot;b&quot;));//truealert(/[abc]/.test(&quot;c&quot;));//truealert(&quot;a bat ,a Cat,a fAt bat ,a faT cat&quot;.match(/[bcf]at/gi));//bat,Cat,fAt,bat,faT,cat 负向类在[]前面加个元字符^进行取反，表示匹配不能为括号里面的字符。1234alert(/[^abc]/.test(&quot;a&quot;));//falsealert(/[^abc]/.test(&quot;b&quot;));//falsealert(/[^abc]/.test(&quot;6&quot;));//truealert(/[^abc]/.test(&quot;gg&quot;));//true 范围类还是在那个中括号里面做文章。有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以用它。特征就是在中间加了个横线。12345alert(/[a-f]/.test(&quot;b&quot;));//truealert(/[a-f]/.test(&quot;g&quot;));//falsealert(/[a-z]/.test(&quot;h&quot;));//truealert(/[0-9]/.test(&quot;8&quot;));//truealert(/[0-9]/.test(&quot;a&quot;));//false 组合类中括号内可以组合使用不同类型的单个字符。1234567alert(/[^H-Y]/.test(&quot;G&quot;));//truealert(/[^7-9]/.test(&quot;6&quot;));//truealert(/[a-m1-5\n]/.test(&quot;a&quot;))//truealert(/[a-m1-5\n]/.test(&quot;3&quot;))//truealert(/[a-m1-5\n]/.test(&quot;\n&quot;))//truealert(/[a-m1-5\n]/.test(&quot;r&quot;))//false 预定义类使用反义字符代替某些常用的组合集 字符 等同于 描述 . [^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [ \t\n\x0B\f\r] 空白字符 \S [^ \t\n\x0B\f\r] 非空白字符 \w [a-zA-Z_0-9] 单词字符(所有的字母) \W [^a-zA-Z_0-9] 非单词字符 量词（限定符） 代码 描述 ? 出现零次或一次 * 出现零次或多次(任意次) + 出现一次或多次（至少一次） {n} 对应零次或者n次 {n,m} 至少出现n次但不超过m次 {n,} 至少出现n次(+的升级版) 1234567891011alert(/...../.test(&quot;正则表达式&quot;))//truealert(/正则表达式/.test(&quot;正则表达式&quot;))//truealert(/[\u4e00-\u9fa5]&#123;5&#125;/.test(&quot;正则表达式&quot;))//truealert(/[\u4e00-\u9fa5]&#123;4&#125;/.test(&quot;正则表达式55&quot;))//truealert(/^[\u4e00-\u9fa5]+$/.test(&quot;正则表达式&quot;))//truealert(/^[\u4e00-\u9fa5]+$/.test(&quot;正则表达式#&quot;)) //falsealert(/\d&#123;6&#125;/.test(&quot;123456&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;ee&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;ex&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;xx&quot;))//true 1/[\u4e00-\u9fa5]/ //用于匹配单个汉字。这两个unicode值正好是Unicode表中的汉字的头和尾。 贪婪量词，懒惰量词与支配性量词贪婪量词: 当正则表达式中包含能接受重复量词时，默认的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。1alert(&quot;aabab&quot;.match(/a.*b/g))//aabab 懒惰量词:在量词后加？，也就是匹配尽可能少的字符。其工作方式与贪婪量词相反。123alert(&quot;abaab&quot;.match(/a.*?b/g))//为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。 表5.懒惰限定符|代码| 描述||—|—||*? |重复任意次，但尽可能少重复||+?| 重复1次或更多次，但尽可能少重复||??| 重复0次或1次，但尽可能少重复||{n,m}?| 重复n到m次，但尽可能少重复||{n,}? |重复n次以上，但尽可能少重复| 支配性量词，在简单量词后加+。支配性量词只尝试一次。但是javascript不支持。 分组到目前为止，我们接触到中括号表示范围内选择，大括号表示重复。小括号就可以表示分组，用作多字符的重复。 123456789//分组+量词alert(/(dog)&#123;2&#125;/.test(&quot;dogdog&quot;))//true//分组+范围alert(&quot;baddad&quot;.match(/([bd]ad?)*?/g))//baddad,dad//分组+分组alert(&quot;mon and dad&quot;.match(/(mon( and dad)?)/))//mon and dad,mon and dad, and dad//man and dad 是符合正则模式的，而 and dad 是正则的一个分组] 捕获性分组所有分组默认都是捕获性分组，当使用match或者exec方法不带全局属性的时候，就可以在返回数组的第1位开始捕获到符合分组的内容。123456789101112131415161718192021222324 var reg = /test(\d+)/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;001&quot;, index: 0, input: &quot;test001&quot;] var reg = /test(\d+)/g; var str = &apos;test001 test002&apos;; console.log(str.match(reg)); //[&quot;test001&quot;, &quot;test002&quot;] var reg = /test(\d)+/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;1&quot;, index: 0, input: &quot;test001&quot;] var reg = /test(\d)+/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;1&quot;, index: 0, input: &quot;test001&quot;]var reg = /test(\d)+?/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test0&quot;, &quot;0&quot;, index: 0, input: &quot;test001&quot;] 反向引用捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。 反向引用标识由正则表达式中的匹配组捕获性分组。每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法进行引用。（MDN不推荐使用）123456789var color = &quot;#990000&quot;;/#(\d+)/.test(color);alert(RegExp.$1);//990000 alert(/(dog)\1/.test(&quot;dogdog&quot;))//true var num = &quot;1234 5678&quot;;var newNum = num.replace(/(\d&#123;4&#125;) (\d&#123;4&#125;)/,&quot;$2 $1&quot;);alert(newNum) 你也可以自己指定分组的组名。要指定一个分组的组名，请使用这样的语法：(?&lt; name &gt;exp)这样就把这部分表达式的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\${name}来调用匹配到的内容 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：|代码| 说明||—|—||(exp) |匹配exp,并捕获文本到自动命名的组里||(?&lt; name >exp)| 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)||(?:exp)| 匹配exp,不捕获匹配的文本，也不给此分组分配组号| 非捕获性分组并不是所有分组都能创建反向引用，有一种特别的分组称之为非捕获性分组，它是不会创建反向引用。反之，就是捕获性分组。要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号就行了。使用match、exec方法的时候就不会捕获到分组的内容。1234var reg = /test(?:\d)+/; var str = &apos;test001&apos;; console.log(str.match(reg));//[&quot;test001&quot;, index: 0, input: &quot;test001&quot;] 零宽断言 断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容.意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1. 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。 正则 名称 描述 (?=exp) 正向前瞻 匹配exp前面的位置 (?!exp) 负向前瞻 匹配后面不是exp的位置 (?&lt;=exp) 正向后瞻 匹配exp后面的位置 JavaScript不支持 (?&lt;!exp) 负向后瞻 匹配前面不是exp的位置 JavaScript不支持 正向前瞻用来检查接下来的出现的是不是某个特定的字符集。而负向前瞻则是检查接下来的不应该出现的特定字符串集。零宽断言是不会被捕获的。 123456789101112var str1 = &quot;bedroom&quot;;var str2 = &quot;bedding&quot;;var reBed = /(bed(?=room))///在我们捕获bed这个字符串时，抢先去看接下来的字符串是不是roomalert(reBed.test(str1));//truealert(RegExp.$1)//bedalert(RegExp.$2 === &quot;&quot;)//truealert(reBed.test(str2))//falsevar str1 = &quot;bedroom&quot;;var str2 = &quot;bedding&quot;;var reBed = /(bed(?!room))/ //要来它后面不能是roomalert(reBed.test(str1))//falsealert(reBed.test(str2))//true 小练习检验QQ号码： [1-9][0-9]{4,14} 手机号码：^(13[0-9]|14[57]|15[0-35-9]|18[0-35-9])\d{8}$ 身份证：^([0-9]){7,18}(x|X)?$ 密码：^[a-zA-Z]\w{5,17}$ 字母开头，长度在6~18之间，只能包含字母、数字和下划线 强密码：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间电话号码验证码/^[a-zA-z0-9]{4}$]/IP地址邮箱网址 单词首字母大写1234567var a = &quot;asdf&quot;; String.prototype.capitalize = function () &#123; return this.replace(/^\w/, function (s) &#123; return s.toUpperCase(); &#125;); &#125;alert(a.capitalize())//Asdf 12345678910111213var replace = function()&#123; var text = &quot;javascript Tutorial&quot;; console.log(text.replace(/\S/ig, &apos;($&amp;)&apos;));&#125;() var replace = function()&#123; var name = &quot;Doe, John&quot;; console.log(name.replace(/(\w+)\s*, \s*(\w+)/, &quot;$2 $1&quot;)); var str = &apos;aaa bbb ccc&apos;; console.log(str.replace(/\b\w+\b/g, function(word)&#123; return word.substring(0,1).toUpperCase()+word.substring(1);&#125; )) &#125;() 月日年变日月年12345&quot;04-22-2018&quot;.replace(/(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)-(?&lt;year&gt;\d&#123;4&#125;)/, (...args) =&gt; &#123; const groups = args.slice(-1)[0] const &#123;day, month, year&#125; = groups return `$&#123;day&#125;-$&#123;month&#125;-$&#123;year&#125;`&#125;) // &quot;25-04-2017&quot; 题目，移除所有标签，只留下innerText!123var html = &quot;&lt;p&gt;&lt;a href=&apos;http://www.cnblogs.com/rubylouvre/&apos;&gt;Ruby Louvre&lt;/a&gt;by &lt;em&gt;正则表达式&lt;/em&gt;&lt;/p&gt;&quot;;var text = html.replace(/&lt;(.|\s)*?&gt;/g, &quot;&quot;);alert(text)//Ruby Louvreby 正则表达式 官方教程微软：.NET 正则表达式MSDNW3CSCHOOL 正则表达式基本语法 参考资料正则表达式30分钟入门教程JavaScript 正则表达式上——基本语法JavaScript正则表达式下——相关方法js正则表达式/replace替换变量方法65条最常用正则表达式 你要的都在这里了JavaScript replace() 方法JavaScript split() 方法、javascript正则表达式JS 正则中的命名捕获分组javascript正则表达式中分组详解pattern–HTML5的表单验证属性 https://zhuanlan.zhihu.com/p/83876910?utm_source=qq&amp;utm_medium=social&amp;utm_oi=549346247203553280]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常用设计模式]]></title>
    <url>%2F2018%2F06%2F17%2FdesignPattern%2F</url>
    <content type="text"><![CDATA[施工中…… 设计模式软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。 什么是设计模式UML类图·类图结构为&lt;&gt;，表示为一个抽象类；·继承类和抽象类之间的关系为实现关系，使用带空心箭头的虚线表示；·继承类与实例之间是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；·实例与实例部件之间是组合关系，使用带实心箭头的实线表示；·实例与用户之间是一种依赖关系，使用带箭头的虚线表示；·用户与用户群之间是聚合关系，使用带空心箭头的实线表示；·用户与身份证明之间为关联关系，使用一根实线表示； 类之间的关系继承关系实例-&gt;继承类-&gt;抽象类 泛化 实现 个体和集体的关系聚合 弱依赖组合 强依赖 不同类对象之间关系关联是静态强关联关系，描述不同类的对象之间的结构关系，对象常通过成员变量实现，依赖是临时性关系，描述一个对象运行期间会要到另一个对象的关系，尽量单向依赖 时序图时序图是显示对象之间交互的图，这些对象是按时间顺序排列的。时序图中显示的是参与交互的对象及其对象之间消息交互的顺序。 时序图（Sequence Diagram）包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。 六大设计原则1)单一职责原则该原则是针对类来说的，即一个类应该只负责一项职责。如类T负责两个不同职责：职责P1，职责P2。当职责P1需求变更而改变T时，可能造成职责P2发生故障，所以需要将类T的粒度分解为T1，T2。遵循单一职责的优点： a)降低类的复杂度，一个类只负责一项职责。 b)提高类的可读性，可维护性 v)降低变更引起的风险。 2)里氏替换原则如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。 由定义可知，在使用继承时，遵循里氏替换原则，在子类中尽量不要重写和重载父类的方法。继承包含这样一层含义：父类中凡是已经实现好的方法（相对抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。继承作为面向对象三大特性之一，在给程序设计带来巨大遍历的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。 3)依赖倒转原则程序要依赖于抽象接口，不要依赖于具体实现。高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体，具体应该依赖于抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。 4)接口隔离原则客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 5)迪米特法则一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。 6)开闭原则开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则都是实现开闭原则的一种手段。对于扩展是开放的，对于修改是关闭的，这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。 创建型模式创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。 简单工厂模式在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式包含如下角色：Factory：工厂角色工厂角色负责实现创建所有实例的内部逻辑Product：抽象产品角色抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口ConcreteProduct：具体产品角色具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 模式分析将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式的优点工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 简单工厂模式的缺点由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 工厂方法模式工厂方法模式包含如下角色：Product：抽象产品ConcreteProduct：具体产品Factory：抽象工厂ConcreteFactory：具体工厂]]></content>
      <categories>
        <category>designPattern</category>
      </categories>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种方式进行网页布局]]></title>
    <url>%2F2018%2F05%2F03%2Flayouts%2F</url>
    <content type="text"><![CDATA[各类常用网页布局方式：静态、自适应、流式、弹性、网格布局。 网页布局 静态布局意思就是只是针对某个屏幕下设计的网页，当屏幕大小改变时，页面布局不会发生变化，就像经常所看到的滚动条。 自适应布局特点是分别为不同的屏幕设置布局格式，当屏幕大小改变时，会出现不同的布局，意思就是在这个屏幕下这个元素块在这个地方，但是在那个屏幕下，这个元素块又会出现在那个地方。只是布局改变，元素不变。可以看成是不同屏幕下由多个静态布局组成的。 使用了媒体查询1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 流式布局特点是随着屏幕的改变，页面的布局没有发生大的变化，可以进行适配调整，这个正好与自适应布局相补。 PC端常见布局 浮动布局floatBFC 即 Block Formatting Contexts (块级格式化上下文)Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 特性 同一个 BFC 下外边距会发生折叠 BFC 可以包含浮动的元素（清除浮动，使浮动在BFC盒子内） BFC 可以阻止元素被浮动元素覆盖（清除浮动，BFC盒子内不受外部浮动影响） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;float&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .float .left&#123; width:300px; float:left; &#125; .float .right&#123; width:25%; float:right; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;float&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;FL&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;FR&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;FM&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位布局position123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;position&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .position .left&#123; width:300px; position: absolute; left:8px; &#125; .position .right&#123; width:25%; position: absolute; right:8px; &#125; .position .mid&#123; margin:0 25% 0 300px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;position&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;PL&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;PR&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;PM&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 表格布局table缺点： table比其它html标记占更多的字节。(造成下载时间延迟,占用服务器更多流量资源) table会阻挡浏览器渲染引擎的渲染顺序。(会延迟页面的生成速度,让用户等待更久的时间) table里显示图片时需要你把单个、有逻辑性的的图片切成多个图。(增加设计的复杂度,增加页面加载时间,增加http会话数) 在某些浏览器中,table里的文字的拷贝会出现问题。(会让用户不悦) table会影响其内部的某些布局属性的生效(比如里的元素的height:100%) (限制页面设计的自由性) 一旦学了CSS的知识,你会发现使用table做页面布局会变得更麻烦。(先花时间学一些CSS知识,会省去你以后大量的时间) ‘table对’对于页面布局来说,从语义上看是不正确的。(它描述的是表现,而不是内容) table代码会让阅读者抓狂。(不但无法利用CSS,而且会不知所云,尤其在进行页面改版或内容抽取的时候) table一旦设计完成就变成死的,很难通过CSS让它展现新的面貌。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;table&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; table&#123; width:100%; &#125; table .left&#123; width:300px; &#125; table .mid&#123; margin:0 25%; &#125; table .right&#123; width:25%; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;top&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;left&quot;&gt;TL&lt;/td&gt; &lt;td class=&quot;mid&quot;&gt;TM&lt;/td&gt; &lt;td class=&quot;right&quot;&gt;TR&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;bottom&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 弹性布局flex弹性布局重点在单一横排和单一竖排的样式应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;flex&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .flex&#123; display:flex; flex-direction: column; &#125; .flex .top,.flex .bottom&#123; flex:1; &#125; .flex .main&#123; display: flex; &#125; .flex .mid&#123; flex:1; &#125; .flex .left&#123; width:300px; min-width: 100px; &#125; .flex .right&#123; width:25%; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;left&quot;&gt;FL&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;FM&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;FR&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 网格布局gridgrid-area是应用的重点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;grid&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .top&#123; grid-area: top; &#125; .left&#123; grid-area: left; &#125; .mid&#123; grid-area: mid; &#125; .right&#123; grid-area: right; &#125; .bottom&#123; grid-area: bottom; &#125; .grid&#123; display: grid; grid-template-columns: 300px 3fr 1fr; grid-template-rows:auto; grid-template-areas: &quot;top top top&quot; &quot;left mid right&quot; &quot;bottom bottom bottom&quot; ; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;grid&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;GL&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;GM&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;GR&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局就是分别为不同的屏幕设计的布局方式，可以理解成自适应布局和流程布局的结合。 媒体查询+各类流式布局 12@media (max-width: 1200px) &#123;&#125; 在响应式编程中，比较难处理的就是图片。需要针对不同设备的分辨率进行适配，同时要保持较好的兼容性。在处理图片时，有以下的小技巧： 为图像使用相对尺寸，防止它们意外溢出容器。 如果您要根据设备特性（亦称艺术指导）指定不同图像，则使用 picture 元素。 在 img 元素中使用 srcset 及 x 描述符，引导浏览器从不同密度图像中选择、使用最佳的一张。 如果您的页面仅有一两个图像，且这些图像没有在您的网站上的其他地方使用，可考虑使用内联图像以减少文件请求。 我们一个一个来说这些技巧。首先是为图像使用相对尺寸，跟前面的为元素使用相对尺寸一样，防止在小屏幕设备上溢出容器，可以使用 max-width: 100% 来保证图像及其他内容不会从父容器上溢出。同时，为了提高可访问性，需要为img元素添加有意义的alt描述。 其次是img元素的srcset属性，这个属性非常有用，可以针对不同设备特性提供多种图片文件。如果浏览器支持srcset属性，则会在进行任何请求之前对逗号分隔的图像/条件列表进行解析，并且只会下载和显示最合适的图像。在使用时，为了能够兼容不支持srcset属性的浏览器，还需要为img元素指定src。就像下面这样：1&lt;img src=&quot;lighthouse.jpg&quot;srcset=&quot;lighthouse.jpg , lighthouse-2x.jpg 2x&quot;&gt; 另一个很有用的元素是picture，其能根据设备特性更改图像，picture元素定义了一个声明性解决办法，可根据设备大小、设备分辨率、屏幕方向等不同特性来提供一个图像的多个版本，就像video元素一样，可以指定多个源。为了保持兼容以及默认的情况，还可以在picture元素里面嵌套img，非常好用。12345&lt;picture&gt; &lt;source media=&quot;(min-width: 800px)&quot; srcset=&quot;head.jpg, head-2x.jpg 2x&quot;&gt; &lt;source media=&quot;(min-width: 450px)&quot; srcset=&quot;head-small.jpg, head-small-2x.jpg 2x&quot;&gt; &lt;img src=&quot;head-fb.jpg&quot; srcset=&quot;head-fb-2x.jpg 2x&quot; alt=&quot;a head carved out of wood&quot;&gt;&lt;/picture&gt; 同时，在处理图片时，为了减少请求，我们还可以内联图片资源。常见的方案是base64及内联SVG，内联SVG除了能够减少请求外，还能够保持页面缩放时，图片不失真。]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HopeLibrarySystem项目总结]]></title>
    <url>%2F2017%2F12%2F16%2FHopeLibrarySystem%2F</url>
    <content type="text"><![CDATA[记录此项目中一些技术要点 HopeLibrarySystem 项目总结框架express+ejs123// view engine setupapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;ejs&apos;); Express里有个中间件（middleware）的概念。所谓中间件，就是在收到请求后和发送响应之前这个阶段执行的一些函数。 要在一条路由的处理链上插入中间件，可以使用express对象的use方法。该方法原型如下： 1app.use([path,] function [, function...]) 当app.use没有提供path参数时，路径默认为“/”。当你为某个路径安装了中间件，则当以该路径为基础的路径被访问时，都会应用该中间件。比如你为“/abcd”设置了中间件，那么“/abcd/xxx”被访问时也会应用该中间件。 中间件函数的原型如下： 1function (req, res, next) 第一个参数是Request对象req。第二个参数是Response对象res。第三个则是用来驱动中间件调用链的函数next，如果你想让后面的中间件继续处理请求，就需要调用next方法。 给某个路径应用中间件函数的典型调用是这样的： 1234app.use(&apos;/abcd&apos;, function (req, res, next) &#123; console.log(req.baseUrl); next();&#125;) 组件express-session基于express框架专门用于处理session的中间件 只需要用express app的use方法将session挂载在‘/’路径即可，这样所有的路由都可以访问到session。可以给要挂载的session传递不同的option参数，来控制session的不同特性 一旦我们将express-session中间件用use挂载后，我们可以很方便的通过req参数来存储和访问session对象的数据。req.session是一个JSON格式的JavaScript对象，我们可以在使用的过程中随意的增加成员，这些成员会自动的被保存到option参数指定的地方，默认即为内存中去 123456app.use(session(&#123; secret:&apos;hope&apos;,// 对session id 相关的cookie 进行签名 cookie:&#123;maxAge:1000*60*60*24*30&#125;,// 设置 session 的有效时间，单位毫秒,免密码一个月内自动登录 resave: false,// 是否每次都重新保存会话，建议false saveUninitialized: true,// 是否保存未初始化的会话&#125;)); 默认存在内存，store开启存在服务器，如下app会自动替我们把session存入到mongodb数据，而非内存中。 1234567session(&#123; store: new MongoStore(&#123; //创建新的mongodb数据库 host: &apos;localhost&apos;, //数据库的地址，本机的话就是127.0.0.1，也可以是网络主机 port: 27017, //数据库的端口号 db: &apos;test-app&apos; //数据库的名称。 &#125;)&#125;) 由于session是存在服务器端数据库的，所以的它的生命周期可以持久化，而不仅限于浏览器关闭的时间。具体是由cookie.maxAge 决定：如果maxAge设定是1个小时，那么从这个因浏览器访问服务器导致session创建开始后，session会一直保存在服务器端，即使浏览器关闭，session也会继续存在。如果此时服务器宕机，只要开机后数据库没发生不可逆转的破坏，maxAge时间没过期，那么session是可以继续保持的。 当maxAge时间过期后，session会自动的数据库中移除，对应的还有浏览器的cookie。不过，由于connect-mongo的特殊机制（每1分钟检查一次过期session），session的移除可能在时间上会有一定的滞后。 Morganhttp 请求日志记录中间件 使用 app.use(logger(&#39;dev&#39;)); 可以将请求信息打印在控制台，便于开发调试，但实际生产环境中，通常需要将日志记录在日志文件里 将所有的请求记录在 log/ 目录下按每日日期生成的文件中，需要使用 file-stream-rotator 模块： 12345678910111213141516171819202122232425var FileStreamRotator = require(&apos;file-stream-rotator&apos;);var express = require(&apos;express&apos;);var fs = require(&apos;fs&apos;);var logger = require(&apos;morgan&apos;); var app = express();var logDirectory = __dirname + &apos;/log&apos;; // ensure log directory exists fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory); // create a rotating write stream var accessLogStream = FileStreamRotator.getStream(&#123; date_format: &apos;YYYYMMDD&apos;, filename: logDirectory + &apos;/%DATE%.log&apos;, frequency: &apos;daily&apos;, verbose: false&#125;); // setup the logger app.use(logger(&apos;combined&apos;, &#123;stream: accessLogStream&#125;)); app.get(&apos;/&apos;, function (req, res) &#123; res.send(&apos;hello, world!&apos;);&#125;); body-parser处理程序之前，在中间件中对传入的请求体进行解析（response body） 123text 将所有的数据以文本格式字符串的返回 form表单中 text-plainurlencoded(&#123;extended:false&#125;);解析 x-www-form-urlencodedraw解析二进制数据 123456789// create application/json parservar jsonParser = bodyParser.json()// create application/x-www-form-urlencoded parservar urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;)app.post(&apos;/login.do&apos;, jsonParser, (req, res) =&gt; &#123; console.log(&apos;********************&apos;) console.log(req.body) res.end();&#125;) 加载到没有挂载路径的中间件1234// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json()) Cookie-parser方便操作客户端中的cookie值 Express完成cookie值的签名，cookie-parser实现签名cookie的解析。两者共用同一个秘钥。 签名前的cookie值为chyingp，签名后的cookie值为s%3Achyingp.uVofnk6k%2B9mHQpdPlQeOfjM8B5oa6mppny9d%2BmG9rD0，decode后为s:chyingp.uVofnk6k+9mHQpdPlQeOfjM8B5oa6mppny9d+mG9rD0。 出于安全的考虑，我们通常需要对cookie进行签名。 1234567891011121314151617181920var express = require(&apos;express&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var app = express();// 初始化中间件，传入的第一个参数为singed secret 签名app.use(cookieParser(&apos;secret&apos;));app.use(function (req, res, next) &#123; console.log(req.cookies.nick); // chyingp console.log(req.signedCookies.nick); // chyingp next();&#125;);app.use(function (req, res, next) &#123; // 传入第三个参数 &#123;signed: true&#125;，表示要对cookie进行摘要计算 res.cookie(&apos;nick&apos;, &apos;chyingp&apos;, &#123;signed: true&#125;); res.end(&apos;ok&apos;);&#125;);app.listen(3000); 例子改写如下，有几个注意点： cookieParser初始化时，传入secret作为签名的秘钥。 设置cookie时，将signed设置为true，表示对即将设置的cookie进行签名。 获取cookie时，可以通过req.cookies，也可以通过req.signedCookies获取。 “解析”签名cookie阶段，中间件主要做了两件事： 将签名cookie对应的原始值提取出来 验证签名cookie是否合法 cookie签名的作用 主要是出于安全考虑，防止cookie被篡改，增强安全性。 假设网站通过nick这个cookie来区分当前登录的用户是谁。在前面例子中，登录用户的cookie中，nick对应的值如下：(decode后的) 1s:chyingp.uVofnk6k+9mHQpdPlQeOfjM8B5oa6mppny9d+mG9rD0 此时，有人试图修改这个cookie值，来达到伪造身份的目的。比如修改成xiaoming： 1s:xiaoming.uVofnk6k+9mHQpdPlQeOfjM8B5oa6mppny9d+mG9rD0 当网站收到请求，对签名cookie进行解析，发现签名验证不通过。由此可判断，cookie是伪造的。 1hmac(&quot;xiaoming&quot;, &quot;secret&quot;) !== &quot;uVofnk6k+9mHQpdPlQeOfjM8B5oa6mppny9d+mG9rD0&quot; 签名就一定能够确保安全吗 当然不是。 上个小节的例子，仅通过nick这个cookie的值来判断登录的是哪个用户，这是一个非常糟糕的设计。虽然在秘钥未知的情况下，很难伪造签名cookie。但用户名相同的情况下，签名也是相同的。这种情况下，其实是很容易伪造的。 express.static设置静态文件路径的中间件 1app.use(express.static(&apos;public&apos;)); HLayer.jshttps://github.com/huruji/Hlayer https://www.jianshu.com/p/662908ec7713 made by Huruji, web弹层组件 重要部分1.express 中有两个对象可用于模板的渲染：app.locals 和 res.locals 除了get方法中使用render来向ejs模版传递参数，还可以用locals对象的属性为view提供变量。 在调用 res.render 的时候，express 合并（merge）了 3 处的结果后传入要渲染的模板，优先级：res.render 传入的对象&gt; res.locals 对象 &gt; app.locals 对象，所以 app.locals 和 res.locals 几乎没有区别，都用来渲染模板，使用上的区别在于：app.locals 上通常挂载常量信息（如博客名、描述、作者信息），res.locals 上通常挂载变量信息，即每次请求可能的值都不一样（如请求者信息，res.locals.user = req.session.user）。 2.RESTful API 接口规范 1）URI URI 表示资源，资源一般对应服务器端领域模型中的实体类。 URI规范 不用大写；用中杠-不用下杠_；参数列表要encode；URI中的名词表示资源集合，使用复数形式。 2）Request HTTP方法通过标准HTTP方法对资源CRUD 3）等等等等 登录系统流程第一步，用户访问网站(未登录)，生成空的session，通过cookie记录sessionid 1234if(!req.session.userID || !req.session.userSign)&#123; res.redirect(&quot;/hopelibrary/user/login&quot;); return;&#125; 第二步，用户跳转到登录页面：这个页面会向后端验证码接口发送一个请求，服务器根据此时用户的cookie中记录的sessionid找到前面生成的空session，生成一个验证码 1234session&#123; sessionId: checkcode:&#125; 第三步，用户填写完用户信息，点击提交，表单信息包括 会被发送到服务器，服务器首先根据用户请求中用户的cookie中的sessionid，找到设置的验证码，和前端发送的验证码进行比对，若一致，则继续进行账号密码验证登录，若不一致则返回错误 第四步，建立与mysql数据库的连接，查询用户库，返回结果存在则设置cookie和session并设置信息 123456789101112131415res.cookie(&quot;userId&quot;, rows[0].readerID, &#123; maxAge: 30 * 60 * 1000, path: &apos;/&apos;,&#125;);const message = &#123; code: 0, message: &quot;成功&quot;, userId: user.readerID&#125;;setSession(req, &#123;userID: user.readerID, userSign: true&#125;);function setSession(req,options) &#123; for(let a in options) &#123; req.session[a] = options[a]; &#125;&#125; 第五步，验证码验证通过，验证登录，将用户信息存入session，用户变为登录状态。 123456session&#123; sessionId: checkcode: userID: user.readerID userSign: true&#125; 如果存在session跳转到正常页面 1234if(req.session.userSign) &#123; res.redirect(&apos;/hopelibrary/user&apos;); return;&#125; 验证码captchapng组件 12345678910111213141516171819202122232425exports.captchap=function (req, res, next) &#123; //设置宽高 var width=!isNaN(parseInt(req.query.width))?parseInt(req.query.width):100; var height=!isNaN(parseInt(req.query.height))?parseInt(req.query.height):48; //生成随机数 var code = parseInt(Math.random()*9000+1000); //设置为session中的值 req.session.checkcode = code; //生成图片 var p = new captchapng(width,height, code); p.color(0, 0, 0, 0); p.color(80, 80, 80, 255); var img = p.getBase64(); var imgbase64 = new Buffer(img,&apos;base64&apos;); //响应头 响应类型图片 res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;image/png&apos; &#125;); res.end(imgbase64);&#125;const captchap=require(&quot;./checkcode&quot;).captchap;router.route(&quot;/checkcode&quot;).get(function(req, res) captchap(req,res);&#125;);//验证码 加密crypto组件进行md5加密 升级安全方面token 考虑到网站安全的问题，用户做任何操作的时候都要验证session。session的生命周期决定这种方式也不是绝对安全的，假如用户已经登录了，攻击者截取到了用户发送到服务器的请求，用请求里的sessionid,去做其他操作，只要被截取的用户在线，服务器上这个session没有过期，那操作都能成功 数据交互db-common.js 拼接mysql查询字符串 连接数据库 定义操作方法 123456789function operate(connect, table)&#123; this.table = table; this.connection = connect;&#125;operate.prototype.selectAll = function(callback) &#123; const action = &apos;SELECT * &apos; + &apos;FROM &apos; + this.table; console.log(&apos;action:&apos;+action); this.connection.query(action, callback)&#125;; hopeDB.js 继承operate，并绑定具体数据库 实现数据库方法库 12345678910111213const connection = mysqlUtil.DBConnection;const adminOperate = new dbCommon.operate(connection, &apos;hopeadmin&apos;);const adminDB = &#123; selectAll: (callback) =&gt; &#123; adminOperate.selectAll((err, rows, fields) =&gt; &#123; if(err)&#123; console.log(err); return; &#125; callback&amp;&amp;callback(rows); &#125;); &#125;,&#125; 具体页面 调用方法 12userDB.selectAll((rows) =&gt; &#123;&#125;) 封装当你需要隐藏一些属性和方法时，就可以将这些属性和方法封装起来，然后通过一个外部可以调用的特定接口（也可以说是一个公共的方法）进行调用。 防止代码冗余,也可以方便代码的调用,同时也可以防止不必要的错误。 安全？ 页面渲染ejs模板，res.render获得相关信息 1res.render(&quot;user/user-book&quot;,&#123;userName,userImg,userPermission,firstPath:&apos;borrow&apos;,secondPath:&apos;&apos;,book,bookCate,bookNum,bookPage:pageNum&#125;); 鉴权系统利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证 不同管理权限用户入口不同 1234&#123; adminID:admin.adminID, adminSign: true&#125; https://blog.csdn.net/weixin_40442219/article/details/83377530 附录：项目结构1. 目录结构HopeLibrarySystem-master 项目文件 bin pm2配置信息 git_images node_modules public 公共css、js、图片（图书封面、设备、用户头像和其他图片） css main.css 主要css img admin 用户头像 book 图书封面 equip 设备图片 user 用户头像 js admin-super adduser.js data charts.config.js hlayer hlayer.css hlayer.js layer public user favicon.ico routes api api-book-borrow.js api-book.js api-equip.js api-login.js api-user.js admin-book.js admin-equip.js admin-super.js admin.js book.js checkcode.js email-schedule.js equip.js mysql_util.js public.js user.js utils views 各页面ejs api.md app.js config.js hopeWechat.sql lib.log package-lock.json package.json README.md 2. 数据库结构bookborrow 记录借阅书籍情况 ​ borrowID 借阅序号 ​ borrowBookID 被借阅书ID ​ borrowUserID 借阅者ID ​ borrowTime 借阅时间 ​ returnWhe ​ returnBefore 预定归还时间 equipborrow 记录借用设备情况 ​ borrowID 借用序号 ​ borrowEquipID 被借用设备ID ​ borrowUserID 借用者ID ​ borrowTime 借用时间 ​ returnWhe ​ returnBefore 预定归还时间 ​ reservation 是否审核通过 ​ reservationText 借用理由 hopeadmin 记录管理员信息 ​ adminID 管理员ID ​ adminName 管理员名字 ​ adminPassword 管理员密码 ​ adminEmail 管理员邮件 ​ adminImgSrc 管理员头像路径 ​ adminPermissions 管理员权限 hopebook 记录书籍信息 ​ bookID 书ID ​ bookImgSrc 书封面路径 ​ bookName 书名 ​ bookHopeID 书Hope编号 ​ bookAuthor 书作者 ​ bookISBN 书ISBN ​ bookPress 书出版社 ​ bookCate 书类目 ​ bookLeft 是否被借阅 hopeequip 记录设备信息 ​ equipID 设备ID ​ equipHopeID 设备Hope编号 ​ equipName 设备名 ​ equipImgSrc 设备图片路径 ​ equipAdminID 设备管理员ID ​ equipLeft 是否被借用 hopereader 记录用户信息 ​ readerID 用户ID ​ readerName 用户名字 ​ readerPassword 用户密码 ​ readerSex 用户性别 ​ readerGroup 用户兴趣组 ​ studentNumber 用户学号 ​ readerMajor 用户专业 ​ readerPhone 用户电话 ​ readerEmail 用户邮箱 ​ readerBadNum ​ userImgSrc 用户头像路径 https://www.cnblogs.com/chenchenluo/p/4197181.html https://blog.csdn.net/q809198545/article/details/79692483 https://www.cnblogs.com/mingjiatang/p/7495321.html https://www.jianshu.com/p/ff6763c7d823 https://www.cnblogs.com/chyingp/p/express-cookie-parser-deep-in.html https://www.jianshu.com/p/136a95f5bdc6]]></content>
      <tags>
        <tag>FrontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express学习记录]]></title>
    <url>%2F2017%2F12%2F16%2Fexpress%2F</url>
    <content type="text"><![CDATA[施工中…… express构造的是Http.createServer的回调函数express是一个基于NodeJS的框架，先来看下如果不使用框架要创建一个最简单的web应用应该是怎么样 12345const http = require('http');const server = http.createServer(function(req, res)&#123; res.end('hello word!')&#125;);server.listen(8000); 实际上express是一个函数，运行后可以构造出上面代码中http.createServer的回调函数，express做的一切文章都是在这个回调函数上。来看下express3.x的源码express.js 12345678910111213141516171819202122232425262728293031//========== 你的应用 app.js ==================const http = require('http')const app = express()app.get('/', (req, res) =&gt; res.send('Hello World!'))const server = http.createServer(app)server.listen(8000);//========== express.js =============var connect = require('connect')function createApplication() &#123; var app = connect(); utils.merge(app, proto); app.request = &#123; __proto__: req &#125;; app.response = &#123; __proto__: res &#125;; app.init(); return app;&#125;module.exports = createApplication;//=========== express依赖的connect.js==============function createServer() &#123; function app(req, res, next)&#123; app.handle(req, res, next); &#125; // ... 省略 return app;&#125;module.exports = createServer; connect.js的具体内容先不关心，后面会重点介绍。可以看出connect是一个函数，运行返回一个app，app是一个形如function(req, res , next){ … } 的函数。express的createApplication返回即是此app，用于http.createServer的回调。并在这个函数上混入的许多能力，如req、res的处理、模板引擎、静态文件服务、router的能力。 用比较简单的伪代码表示如下 12345678910111213141516171819202122const app = express();// nodejs启动时，app函数内部被express增加了能力，如中间件的调用 app.use(middleware)； // 中间件 app.use(router)； // 路由 app.engine('ejs'); // 模板引擎 app.statifc('public') // 静态文件服务 // ... 还有代理以及其他许多属性与方法const server = http.createServer( function app(req, res)&#123; // 此app函数即为express所构造 // http请求时，req， res被混入许多属性与方法，做了很多处理 // 串行匹配运行按顺序注册的各注册的中间件如： // 1、日志、cookie、bodyparser等开发者自己注册的中间件 // 2、router中间件 // 3、静态文件服务 // 4、模板引擎处理 // 经过匹配的中间件处理后输出返回 &#125;);server.listen(8000); 上面的1、2、3、4顺序即为开发者注册时的顺序（故我们平时在开发时express注册中间件时是有先后顺序的）。express最主管理与运行中间件的能力，接下来深入内部看看connect这个中间件机制是怎么实现的。 最为核心的中间件框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//connect.js 的简要内容function createServer()&#123; // app是用于http.createServer的回调函数 function app(req, res, next)&#123; // 运行时调用handle函数 app.handle(req, res, next); &#125; mixin(app, proto, false); // 初始化一个stack数组 app.stack = []; return app;&#125;// use调用时往app的stack数组中push一个对象（中间件），标识path与回调函数proto.use = function(route, fn)&#123; var path = route, handle = fn; //... 省略其他 this.stack.push(&#123; route: path, handle &#125;);&#125;;// handle方法，串行取出stack数组中的中间件，逐个运行proto.handle = function(req, res, out)&#123; var index = 0; var stack = this.stack; var done = out || finalhandler(req, res, &#123; onerror: logerror &#125;); // 遍历stack，逐个取出中间件运行 function next(err)&#123; var layer = stack[index++]; // 遍历完成为止 if(layer === undefined)&#123; return done(); &#125; var route = pathFormat(layer.route); var pathname = pathFormat(urlParser(req.url).pathname || '/'); // 匹配中间件，不匹配的不运行 if(route !== '' &amp;&amp; pathname !== route)&#123; next(err); return; &#125; // 调用中间件 call(layer.handle, err, req, res, next); &#125; next();&#125;; 不难看出，app.use中间件时，只是把它放入一个数组中。当http请求时，app会从数组中逐个取出，进行匹配过滤，逐个运行。遍历完成后，运行finalhandler，结束一个http请求。可以从http请求的角度思考，一次请求它经历经历了多少东西。express的这个中间件架构就是负责管理与调用这些注册的中间件。中间件顺序执行，通过next来继续下一个，一旦没有继续next，则流程结束。 接下来提一下异步编程的串行控制，加强理解； 异步串行流程控制为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放 到一个数组中。如图，所示，这个数组将起到队列的作用:完成一个任务后按顺序从数组中取 出下一个 数组中的每个任务都是一个函数。任务完成后应该调用一个处理器函数，告诉它错误状态和 结果。如果有错误，处理器函数会终止执行;如果没有错误，处理器就从队列中取出下一个任务 执行它 下面是一个简单实现方案： 1234567891011121314151617181920212223242526// 数组var tasks = [ function A()&#123; //... next(); &#125;, function B()&#123; //... next() &#125;, function C()&#123; //... next() &#125; //...];function next(err, result)&#123; if(err) throw err; var currentTask = tasks.shift(); if(currentTask) currentTask(result) next();&#125;// 首次主动调用next(); 异步串行控制方案除了上面的这种以外，还可以用es6的promise的then链、async/await、yeild、社区工具等； 可以看到代码确实谈不上高级😂，串行导致的性能谈不上优秀，但是得益于此它足够简单易用。到此可以发现express的中间件架构就是一个中间件的的管理与数组遍历运行，这个方案就让社区形形色色各种各样的中间件很好的添加express能力，这点很简单也很重要，因为后续的路由、静态文件服务、代理等都是中间件，都在这个框架内运行。 Router是一个内置在app函数上的中间件来看下简化后的router.js 1234567891011121314151617181920212223242526272829//express创建时运行app.init = function()&#123; // ... 省略其它代码 this._router = new Router(); this.usedRouter = false; // app调用router时初始化router中间件 Object.defineProperty(this, 'router', &#123; configurable : true, enumerable : true, get: function () &#123; this.usedRouter = true; return this._router.middlewareInit.bind(this._router); &#125; &#125;)&#125;;// methods是一个数组，['get','post','put','delete',...]methods.forEach(method =&gt; &#123; app[method] = function (path) &#123; // 如果首次调用则放入路由中间价 if(!this.usedRouter)&#123; this.use(this.router); &#125; // 加入stack this._router.addRoute(method, path, Array.prototype.slice.call(arguments, 1)) &#125;&#125;); 上面的usedRouter是个开关，未开启则不加入router中间件，因为应用理论上也是可能不用到router的。当app[method] 如app.get(‘/user’, fn)调用后，则触发this.use(this.router) 使用router中间件，同时把usedRouter设置为true。之后往router对象中加入fn回调函数。 router实际上也是一个异步串行流程控制，简化版的代码如下 12345678910111213141516171819202122232425262728293031323334353637Router.prototype.addRoute = function(method, path, handles)&#123; let layer = &#123; path, handles &#125;; this.map[method] = this.map[method] || []; this.map[method].push(layer);&#125;;Router.prototype.middlewareInit = function(req, res, out)&#123; let index = 0; let method = req.method.toLowerCase() || 'get'; let stack = this.map[method]; function next(err) &#123; let layer = stack[index++]; let hasError = Boolean(err); // 如果没有了则结束中间件，走下一个中间件 if(!layer)&#123; return hasError ? out(err) : out(); &#125; let route = utils.pathFormat(layer.path); let pathname = utils.pathFormat(urlParser(req.url).pathname || '/'); // 进行过滤 if(route!== '' &amp;&amp; route !== pathname)&#123; return next(err); &#125; executeHandles(layer.handles, err, req, res, next); &#125; next();&#125;; router跟connect非常类似，上述理解了connect，router就很清晰了。一图以蔽之： 实际上router还有细分，某个router还是可以继续做类似的串行流程控制；与中间件相同，每个router一旦停止了next，流程就结束了。 request经过router可以请求一个数据，或者一个网页；网页的话是怎么返回的呢，接下来看下view的render； 视图-模板引擎模板引擎是根据对模板结合data进行运行处理，生产real html；这跟React、Vue、模板引擎是类似的。模板引擎不是express 实现的，实际上express仅仅只是做了调用；这里有个通用的支持各种模板引擎的模块consolidate.js 1234567var cons = require('consolidate') , name = 'swig';cons[name]('views/page.html', &#123; user: 'tobi' &#125;, function(err, html)&#123; if (err) throw err; console.log(html);&#125;); express要做的只是配置与调用； 1234567891011// express设置属性app.set = function(key, value)&#123; if(this.settings.hasOwnProperty(key))&#123; return this.settings[key]; &#125; this.settings[key] = value;&#125;;app.engine = function(engine)&#123; this.settings['engine'] = engine;&#125;; 通过这两个函数设置views视图所在的路径、模板引擎类型，之后express就可以结合router提供的render page，data，render callback的数据进行视图渲染 1234567891011121314151617181920212223242526272829303132333435363738app.render = function (name, options, fn) &#123; let cacheTemplate = this.cache[name]; let view = cacheTemplate || new View(name, &#123; root: process.cwd(), viewPath: this.settings['views'], engine: this.settings['engine'] &#125;); if(!cacheTemplate &amp;&amp; this.settings['view cache'])&#123; this.cache[name] = view; &#125; view.render(options, fn);&#125;;// View.js 简化function View(page, config)&#123; console.log('view 初始化'); this.engine = config.engine || 'ejs'; this.templatePath = path.join(config.root, config.viewPath, page); this.lookup();&#125;//检测模板是否存在View.prototype.lookup = function()&#123; if(!fs.existsSync(this.templatePath))&#123; console.log('模板没有找到'); throw new Error('模板没有找到'); &#125;&#125;;View.prototype.render = function (options, fn) &#123; let templatePath= this.templatePath; // 调用模板引擎完成渲染 return cons[this.engine](templatePath, options, fn);&#125;; 为了性能考虑还做了cache；关于模板引擎，实际上很简单，读者可以自定一个模板引擎规则。 静态文件服务静态文件服务也是一个中间件，express做的事情也仅仅是引用。require一个serve-static，内置在app函数上。 123app.static = function (dir) &#123; this.use(serveStatic(process.cwd() + '/' + dir), &#123;&#125;);&#125;; 当调用app.static时就会把静态文件服务中间件放入stack中，这里与express调用方式稍有不同，因为笔者觉得这么写更好更简单。 简单实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**仿照express实现中间件的功能 Created by haoxin on 2018/7/9.*/var http = require(&apos;http&apos;); var express = () =&gt; &#123; var funcs = []; // 待执行的函数数组 var app = (req, res) =&gt; &#123; var i = 0; var next = () =&gt; &#123; var task = funcs[i++]; // 取出函数数组里的下一个函数 if (!task) &#123; // 如果函数不存在,return return; &#125; task(req, res, next); // 否则,执行下一个函数 &#125; next(); &#125; /** * use方法就是把函数添加到函数数组中 * @param task */ app.use = (task) =&gt; &#123; funcs.push(task); &#125; return app; // 返回实例 &#125;// 下面是测试casevar app = express();http.createServer(app).listen(&apos;3000&apos;, () =&gt; &#123; console.log(&apos;listening 3000....&apos;);&#125;);const middlewareA = (req, res, next) =&gt; &#123; if(req.url!==&quot;/favicon.ico&quot;) &#123; //防止重复请求 console.log(&apos;middlewareA before next()&apos;); next(); console.log(&apos;middlewareA after next()&apos;); &#125; res.end();&#125;const middlewareB = (req, res, next) =&gt; &#123; console.log(&apos;middlewareB before next()&apos;); next(); console.log(&apos;middlewareB after next()&apos;);&#125;const middlewareC = (req, res, next) =&gt; &#123; console.log(&apos;middlewareC before next()&apos;); next(); console.log(&apos;middlewareC after next()&apos;);&#125;app.use(middlewareA);app.use(middlewareB);app.use(middlewareC); https://blog.csdn.net/ppx2017/article/details/80967690 https://zhuanlan.zhihu.com/p/56947560]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2F2017%2F12%2F16%2Fgit%2F</url>
    <content type="text"><![CDATA[简单记录Git用法以做记录 关于版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 本地版本控制系统文件夹备份法。复制整个项目目录来保存不同的版本，或许还会改名加上备份时间以示区别。 其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中化的版本控制系统（Centralized Version Control Systems）使用一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 这类系统，常见的有 CVS、Subversion 以及 Perforce 等，优点是有完善的权限系统，以及统一的服务端，适合商业软件的开发。缺点是如果出现中央服务器的单点故障，会有所有人无法工作甚至丢失文件的风险。 分布式版本控制系统(Distributed Version Control System)客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 在这类系统中，像 Git、Mercurial、Bazaar、BitKeeper 以及 Darcs 等，它们相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只有需要不同开发者合并代码时，才需要一个中转站来完成。 集成管理者工作流Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表`‘官方’’项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示 项目维护者推送到主仓库。 贡献者克隆此仓库，做出修改。 贡献者将数据推送到自己的公开仓库。 贡献者给维护者发送邮件，请求拉取自己的更新。 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。 维护者将合并后的修改推送到主仓库。 什么是GitGit是目前世界上最先进的分布式版本控制系统。最初由Linus Torvalds编写，用作Linux内核代码的管理。 直接记录快照，而非差异比较 Git 对待数据更像是一个 快照流。这是 Git 与几乎所有其它版本控制系统的重要区别。 近乎所有操作都是本地执行 Git 保证完整性 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git 一般只添加数据 所有Git 操作，几乎只往 Git 数据库中增加数据。以删除数据为例，删除一个文件只会是这次提交的版本中没有这个文件的快照，不会删除前几个版本中的这个文件。 三种状态 已提交（committed）、已修改（modified）和已暂存（staged） 什么是githubgithub是一个用git做版本控制系统的项目托管平台。 github上常见用语 Version Control（版本控制）: 任何一个能够让你了解文件的历史，以及该文件的发展进程的系统。 Git：一个版本控制程序，通过对变更进行注释，以创建一个易于遍历的系统历史。Commit（提交）：在指定时间点对系统差异进行的注释 “快照”。 Local（本地）：指任意时刻工作时正在使用的电脑。 Remote（远程）： 指某个联网的位置。 Repository (仓库，简称 repo)：配置了Git超级权限的特定文件夹，包含了你的项目或系统相关的所有文件。 Github：获取本地提交历史记录，并进行远程存储，以便你可以从任何计算机访问这些记录。 Pushing（推送）：取得本地Git提交（以及相关的所有工作），然后将其上传到在线Github。 Pulling（拉取）：从在线的Github上获取最新的提交记录，然后合并到本地电脑上。 Master (branch)：主分支，提交历史 “树”的 “树干”，包含所有已审核的内容/代码。 Feature branch（功能分支/特性分支）：一个基于主分支的独立的位置，在再次并入到主分支之前，你可以在这里安全地写工作中的新任务。 Pull Request（发布请求）：一个 Github 工具，允许用户轻松地查看某功能分支的更改 （the difference或 “diff”），同时允许用户在该分支合并到主分支之前对其进行讨论和调整。 Merging（合并）：该操作指获取功能分支的提交，加入到主分支提交历史的顶部。 Checking out（切换）：该操作指从一个分支切换到另一个分支。 一、基本操作1.设置用户信息 $ git config –global user.name “用户名” $ git config –global user.email “用户邮箱” 当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 很多 GUI 工具都会在第一次运行时帮助你配置这些信息。 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 $ git config –listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto… 你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 git config ： 来检查 Git 的某一项配置 $ git config user.nameJohn Doe 2.建库 $ git init 3.提交 $ git add 文件名 文件名 文件名 —&gt;从工作区提交文件到暂存区 $ git commit -m “更改说明” —&gt;从暂存区提交修改到版本库 4.查看 $ git status —&gt;查看仓库状态 $ git diff 文件名 —&gt;查看修改内容 $ git log —&gt;查看提交日志 查看日志具体信息[https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2] $ git reflog —&gt;查看命令日志 5.回退 $ git reset –hard HEAD^ —&gt;回到上次修改 $ git reset –hard commit_id —&gt;回到任意版本(提交码取前面7位就够了) 6.撤销 $ git checkout –文件名 —&gt;把版本库中的文件替换当前文件，撤销所有未add修改 $ git reset HEAD 文件名 —&gt;把上一次add撤销 7.删除 $ git rm 文件名 —&gt;从版本库中删除文件 $ git commit -m “更改说明” —&gt;删除也是需要提交的修改 $ git checkout –文件名 —&gt;把版本库中的文件替换当前文件，误删恢复 8.移动 git mv file_from file_to 二、标签先切换到需要打标签的分支上 $ git tag 标签名字 查看所有标签 $ git tag 给历史提交打标签 $ git tag 标签名字 commit_id 显示标签分支的信息 $ git show 标签名字 还可以通过-s用私钥签名一个标签： $ git tag -s v0.2 -m “signed version 0.2 released” fec145a 如果标签打错了，也可以删除 $ git tag -d 标签名字 因为创建的标签都只存储在本地，不会自动推送到远程。如果要推送某个标签到远程，使用命令 $ git push origin 标签名 一次性推送全部尚未推送到远程的本地标签 $ git push origin –tags 三、远程仓库1. 创建SSH Key $ ssh-keygen -t rsa -C “用户邮箱” 可在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 2. 绑定GitHub登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 3. 绑定库在GitHub上创建一个新库之后，本地用git上传内容 $ git remote add origin git@github.com:GitHub用户名/库名.git 添加上游 $git remote add upstream https://github.com/GitHub用户名/库名.git 查看远程库的信息 $ git remote -v 4.推送本地库内容把本地库的内容推送到远程，用git push命令把当前分支master推送到远程。 $ git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。 5.克隆远程库内容 $ git clone git@github.com:GitHub用户名/库名.git (文件名) 6.抓取远程库内容 $ git fetch 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 四、分支管理master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b dev 命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev $ git checkout dev 查看所有分支(当前分支前面会标一个*号) $ git branch 切换回master分支： $ git checkout master 把dev分支的工作成果合并到当前分支上： $ git merge -m “合并说明” dev 删除dev分支 $ git branch -d dev 查看分支合并图 $ git log –graph 以图形化的方式展现提交的日志 $gitk 暂时分支（当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。） $ git stash —&gt;创建暂时分支保存当前工作区内容 $ git stash apply —&gt;恢复暂时分支 $ git stash drop —&gt;删除暂时分支 $ git stash pop —&gt;恢复并删除暂时分支 $ git stash list —&gt;查看所有暂时分支 参考资料http://blog.jobbole.com/111187/https://zhuanlan.zhihu.com/p/45724857]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南_计算机网络]]></title>
    <url>%2F2017%2F12%2F16%2Finterview_web%2F</url>
    <content type="text"><![CDATA[梳理计算机网络的知识 计算机网络 大白话，就是URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI，本来设想的的使用两种方法定位：1，URL，用地址定位；2，URN 用名称定位。 通过URL找到资源是对网络位置进行标识，如：通过URI找到资源是通过对名称进行标识，这个名称在某命名空间中，并不代表网络地址，如：urn:issn:1535-3613 URI 是统一资源标识符，而 URL 是统一资源定位符。因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 URI 和 URL 概念上的不同反映在此类和 URL 类的不同中。 此类的实例代表由 RFC 2396 定义的语法意义上的一个 URI 引用。URI 可以是绝对的，也可以是相对的。对 URI 字符串按照一般语法进行解析，不考虑它所指定的方案（如果有）不对主机（如果有）执行查找，也不构造依赖于方案的流处理程序。相等性、哈希计算以及比较都严格地根据实例的字符内容进行定义。换句话说，一个 URI 实例和一个支持语法意义上的、依赖于方案的比较、规范化、解析和相对化计算的结构化字符串差不多。 作为对照，URL 类的实例代表了 URL 的语法组成部分以及访问它描述的资源所需的信息。URL 必须是绝对的，即它必须始终指定一个方案。URL 字符串按照其方案进行解析。通常会为 URL 建立一个流处理程序，实际上无法为未提供处理程序的方案创建一个 URL 实例。相等性和哈希计算依赖于方案和主机的 Internet 地址（如果有）；没有定义比较。换句话说，URL 是一个结构化字符串，它支持解析的语法运算以及查找主机和打开到指定资源的连接之类的网络 I/O 操作。 URI类不包含任何访问资源的方法，它唯一的作用就是解析。 相反的是，URL类可以打开一个到达资源的流。 URI—Uniform Resource Identifier通用资源标志符Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的URI一般由三部组成①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL—Uniform Resource Location统一资源定位符URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 OSI其中表示层和会话层用途如下： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 TCP/IP它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 基于TCP的应用层协议有：SMTP、TELNET、HTTP、FTP 基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、RIP（路由选择协议）、DHCP、BOOTP（是DHCP的前身）、IGMP（Internet组管理协议） DNS占用53号端口，同时使用TCP和UDP协议。DNS区域传输的时候使用TCP协议域名解析时使用UDP协议 各个协议的作用和关系以太网(Ethernet)协议:解决局域网内点对点通信IP协议: 解决多个局域网之间的通信TCP协议: TCP 是以太网协议和IP协议的上层协议，也是应用层协议的下层协议TCP 协议: 保证数据通信的完整性和可靠性，防止丢包。IP协议只是一个地址协议,并不保证数据包的完整。如果路由器丢包(比如缓存满了,新进来的数据包就会丢失),就需要发现丢了哪一个包,以及如何重新发送这个包.这就要依靠TCP协议。 传输层UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP 首部格式首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差的加权平均值。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 慢启动与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 应用层—HTTP一 、基础概念请求和响应报文 请求报文 Http请求报文由三部分组成：请求行，请求头，请求体 请求行：请求方法、请求地址、协议名称和版本号请求头：Referer、User-Agent、Accept、Cookie、Cache-Control、Content-Length等属性。Content-Length可用于服务端判断消息接受完的条件请求体：GET请求与POST请求传递方式不同(Message Body) Accept：浏览器可接受的MIME类型。Accept-Charset：浏览器可接受的字符集。Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。 Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。 Connection：表示是否需要持久连接。 Content-Length：表示请求消息正文的长度。 Cookie：这是最重要的请求头信息之一 From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。 Host：初始URL中的主机和端口。 If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。 Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。 Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。 POST 请求体类型分类form-data：就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。可以模拟填写表单，并且提交表单。可以选择文件类型，但不能保存历史记录x-www-form-urlencoded：就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对raw：原生任意格式的文本，text、json、xml、htmlbinary：相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。image, audio or video files.text files，也不能保存历史记录，每次选择文件，提交 响应报文 响应行：报文协议及版本，状态码及状态描述响应头：Referer、User-Agent、Accept、Cookie、Cache-Control等属性响应体：服务器返回的数据 Allow 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location 表示客户应当到哪里去提取文档。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=\”executives\””)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 二、HTTP 方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 GET 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 HEAD 获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。 更多 POST 与 GET 的比较请见第九章。 GET产生一个TCP数据包；POST产生两个TCP数据包。 长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 PUT 上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: &quot;e0023aa4e&quot;Content-Length: 100[description of changes] DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 1DELETE /file.html HTTP/1.1 OPTIONS 查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT 要求在与代理服务器通信时建立隧道 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 GET 和 POST 比较作用 GET 用于获取资源，而 POST 用于传输实体主体。 参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 1234GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 安全 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 幂等性 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的： 1234GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1 POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录： 123POST /add_row HTTP/1.1 -&gt; Adds a 1nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 3rd row DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样： 123DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 可缓存 如果要对响应进行缓存，需要满足以下条件： 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 而 GET 方法 Header 和 Data 会一起发送。 三、HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 1XX 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 四、具体应用连接管理 短连接与长连接 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 流水线 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。 流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。 五、HTTPSHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 非对称密钥加密 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 HTTPS 采用的加密方式 HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥），而服务器公钥只用于加密”Session Key “本身，这样就减少了加密运算的消耗时间。 如上图所示，整个SSL/TLS握手阶段一共有4次通信： 1.客户端发出请求（ClientHello）：随机数1，支持的协议，支持的加密方法 首先，客户端先向服务器发出加密通信的请求，并向服务器提供以下信息： 支持的协议版本，如TLS 1.0 一个客户端生成的随机数，稍后用于生成对话密钥 支持的加密方法，如RSA公钥加密 支持的压缩方法 2.服务器回应（ServerHello）：随机数2，确认协议和加密方法，证书 确认加密通信协议版本。如果浏览器与服务器支持的版本不一致，则服务器关闭加密通信 一个服务器生成的随机数，稍后用于生成对话密钥 确认加密方法 服务器证书 此处，如果服务器需要确认客户端的身份，如金融机构需要客户提供USB密钥（U盾），就会向客户端请求证书。 3.客户端回应：随机数3（加密 session key，根据前面随机数生成，证书中公钥加密），编码通知 一个随机数，稍后用于生成对话密钥，并且只用服务器的公钥加密，防止被窃听 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验 如果前一步要求了客户端证书，则会发送证书及相关信息。 4.服务器回应：编码通知 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验 至此，整个握手阶段全部结束。接下来，客户端与服务器进入HTTPS加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥“加密内容。 认证 通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 SSL起初是因为HTTP在传输数据时使用的是明文（虽然说POST提交的数据时放在报体里看不到的，但是还是可以通过抓包工具窃取到）是不安全的，为了解决这一隐患网景公司（Netscape）推出了SSL安全套接字协议层(Secure Socket Layer 安全套接层)，SSL是基于HTTP之下TCP之上的一个协议层，是基于HTTP标准并对TCP传输数据时进行加密，所以HPPTS是HTTP+SSL/TCP的简称。 由于HTTPS的推出受到了很多人的欢迎，在SSL更新到3.0时，IETF对SSL3.0进行了标准化，并添加了少数机制(但是几乎和SSL3.0无差异)，标准化后的IETF更名为TLS1.0(Transport Layer Security 安全传输层协议)，可以说TLS就是SSL的新版本3.1 SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 它利用对称加密、公私钥不对称加密及其密钥交换算法，CA系统进行加密且可信任的信息传输 在HTTP SSL中常用的对称加密算法有RC4,AES,3DES,Camellia等 SSL由从前的网景公司开发有1,2,3三个版本，但现在只使用版本3 SSL协议提供的服务主要有： 1）认证用户和服务器，确保数据发送到正确的客户机和服务器； 2）加密数据以防止数据中途被窃取； 3）维护数据的完整性，确保数据在传输过程中不被改变。 SSL协议的工作流程： 服务器认证阶段： 1）客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接； 2）服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息； 3）客服根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器； 4）服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。 TLS传输层安全（Transport Layer Security，TLS）是更为安全的升级版 SSL。由于 SSL 这一术语更为常用，因此我们仍然将我们的安全证书称作 SSL。 该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。 TLS 的最大优势就在于：TLS 是独立于应用协议。高层协议可以透明地分布在 TLS 协议上面。然而，TLS 标准并没有规定应用程序如何在 TLS 上增加安全性；它把如何启动 TLS 握手协议以及如何解释交换的认证证书的决定权留给协议的设计者和实施者来判断。 TLS/SSL是一种加密通道的规范 TLS是SSL的标准化后的产物有1.0 1.1 1.2三个版本默认使用1.0 TLS1.0和SSL3.0几乎没有区别 安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。 TLS握手过程 建立TCP连接后，开始建立TLS连接。下面抓包分析TLS握手过程，握手实际上是一种协商的过程，对协议所必需的一些参数进行协商。抓包图片来源于传输层安全协议抓包分析之SSL/TLS Client Hello客户端告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需 要跟服务端产生的随机数结合起来产生后面要讲到的Master Secret。 Server Hello服务端在接收到客户端的Client Hello之后，服务端将自己的证书发送给客户端。这个证书是对于服务端的一种认证。证书是需要申请，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端 自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被串改。另外，证书还有个有效期。 在服务端向客户端发送的证书中没有提供足够的信息的时候，还可以向客户端发送一个Server Key Exchange。 此外，对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出Cerficate Request消息，要求客户端发送证书对客户端的合法性进行验证。 跟客户端一样，服务端也需要产生一个随机数发送给客户端。客户端和服务端都需要使用这两个随机数来产生Master Secret。 最后服务端会发送一个Server Hello Done消息给客户端，表示Server Hello消息结束了。 Client Key Exchange如果服务端需要对客户端进行验证，在客户端收到服务端的Server Hello消息之后，首先需要向服务端发送客户端的证书，让服务端来验证客户端的合法性。 在此之前的所有TLS握手信息都是明文传送的。在收到服务端的证书等信息之后，客户端会使用一些加密算法(例如：RSA, Diffie-Hellman)产生一个48个字节的Key，这个Key叫PreMaster Secret，很多材料上也被称作PreMaster Key, 最终通过Master secret生成session secret， session secret就是用来对应用数据进行加解密的。PreMaster secret属于一个保密的Key，只要截获PreMaster secret，就可以通过之前明文传送的随机数，最终计算出sessionsecret，所以PreMaster secret使用RSA非对称加密的方式，使用服务端传过来的公钥进行加密，然后传给服务端。 接着，客户端需要对服务端的证书进行检查，检查证书的完整性以及证书跟服务端域名是否吻合。 ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件的状态，准备使用之前协商好的加密套件加密数据并传输了。 在ChangecipherSpec传输完毕之后，客户端会使用之前协商好的加密套件和session secret加密一段Finish的数据传送给服务端，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。 Server Finish服务端在接收到客户端传过来的PreMaster加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生 成session secret，一切准备好之后，会给客户端发送一个ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 session secret加密数据了。之后，服务端也会使用session secret加密后一段Finish消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。 根据之前的握手信息，如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功，接下来，双方可以使用上面产生的session secret对数据进行加密传输了。 应用数据传输在所有的握手阶段都完成之后，就可以开始传送应用数据了。应用数据在传输之前，首先要附加上MAC secret，然后再对这个数据包使用write encryption key进行加密。在服务端收到密文之后，使用Client write encryption key进行解密，客户端收到服务端的数据之后使用Server write encryption key进行解密，然后使用各自的write MAC key对数据的完整性包括是否被串改进行验证。 先非对称加密，获得一个session secret后用此进行对称加密 六、HTTP/1.1新特性 默认是长连接 支持流水线 支持同时打开多个 TCP 连接 支持虚拟主机 新增状态码 100 支持分块传输编码 新增缓存处理指令 max-age Entity tag，If-Unmodified-Since, If-Match, If-None-Match 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 七、HTTP/2.0HTTP/1.x 缺陷 HTTP/1.x 实现简单是以牺牲性能为代价的： 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。 连接无法复用：连接无法复用会导致客户端需要使用多个连接才能实现并发和缩短延迟，每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对大量小文件请求影响较大（没有达到最大窗口请求就被终止）。 HTTP/1.0 传输数据时，每次都需要重新建立连接，增加延迟。 HTTP/1.1 虽然加入 keep-alive 可以复用一部分连接，但域名分片等情况下仍然需要建立多个 connection，耗费资源，给服务器带来性能压力。 Head-Of-Line Blocking（HOLB，队头阻塞）：这会导致带宽无法被充分利用，以及后续健康请求被阻塞。HOLB 是指一系列包（package）因为第一个包被阻塞；当页面中需要请求很多资源的时候，HOLB 会导致在达到最大请求数量时，剩余的资源需要等待其它资源请求完成后才能发起请求。 HTTP 1.0：下个请求必须在前一个请求返回后才能发出，request-response对按序发生。显然，如果某个请求长时间没有返回，那么接下来的请求就全部阻塞了。 HTTP 1.1：尝试使用 pipeling 来解决，即浏览器可以一次性发出多个请求（同个域名、同一条 TCP 链接）。但 pipeling 要求返回是按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。所以，pipeling 只部分解决了 HOLB。 如上图所示，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间。 协议开销大： HTTP/1 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。 安全因素：HTTP/1 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。 谷歌公开了自行研发的 SPDY 协议，它主要解决 HTTP/1.1 效率不高的问题。SPDY 协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 二进制分帧层 HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。连接可以承载任意数量的双向数据流Stream。 相应地， 每个数据流以 消息的形式发送， 而消息由一 或多个帧组成， 这些帧可以乱序发送， 然后根据每个帧首部的流标识符重新组装。 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。一系列数据帧组成了一个完整的消息。比如一系列DATA帧和一个HEADERS帧组成了请求消息。 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。帧类型又可以分为： DATA：用于传输HTTP消息体；HEADERS：用于传输首部字段；SETTINGS：用于约定客户端和服务端的配置数据。比如设置初识的双向流量控制窗口大小；WINDOW_UPDATE：用于调整个别流或个别连接的流量PRIORITY： 用于指定或重新指定引用资源的优先级。RST_STREAM： 用于通知流的非正常终止。PUSH_ PROMISE： 服务端推送许可。PING： 用于计算往返时间，执行“ 活性” 检活。GOAWAY： 用于通知对端停止在当前连接中创建流。标志位用于不同的帧类型定义特定的消息标志。比如DATA帧就可以使用End Stream: true表示该条消息通信完毕。流标识位表示帧所属的流ID。优先值用于HEADERS帧，表示请求优先级。R表示保留位。下面是Wireshark抓包的一个DATA帧： 在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。 然后，HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。 HTTP 2.0 的二进制分帧机制解决了HTTP1.x中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。 有了新的分帧机制后，HTTP 2.0不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多帧,而这些帧可以交错，还可以分别优先级。HTTP2.0连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。 大多数HTTP 连接的时间都很短，而且是突发性的，但TCP 只在长时间连接传输大块数据时效率才最高。HTTP 2.0 通过让所有数据流共用同一个连接，可以更有效地使用TCP 连接 http1.0的队首阻塞 对于同一个tcp连接，所有的http1.0请求放入队列中，只有前一个请求的响应收到了，然后才能发送下一个请求。 可见，http1.0的队首组塞发生在客户端。 http1.1的队首阻塞 对于同一个tcp连接，http1.1允许一次发送多个http1.1请求，也就是说，不必等前一个响应收到，就可以发送下一个请求，这样就解决了http1.0的客户端的队首阻塞。但是，http1.1规定，服务器端的响应的发送要根据请求被接收的顺序排队，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送。也会造成队首阻塞。 可见，http1.1的队首阻塞发生在服务器端。 HTTP 1.x发起请求是串行的，image1返回后才能再发起image2，image2返回后才能再发起image3。 HTTP 2.0建立一条TCP连接后，并行传输着3个数据流，客户端向服务端乱序发送stream1~3的一系列的DATA帧，与此同时，服务端已经在返回stream 1的DATA帧 性能对比，高下立见。HTTP 2.0成功解决了HTTP 1.x的队首阻塞问题（TCP层的阻塞仍无法解决），同时，也不需要通过pipeline机制多 服务端推送 HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。 PUSH_PROMISE帧是服务端向客户端有意推送资源的信号。 如果客户端不需要服务端Push，可在SETTINGS帧中设定服务端流的值为0，禁用此功能PUSH_PROMISE帧中只包含预推送资源的首部。如果客户端对PUSH_PROMISE帧没有意见，服务端在PUSH_PROMISE帧后发送响应的DATA帧开始推送资源。如果客户端已经缓存该资源，不需要再推送，可以选择拒绝PUSH_PROMISE帧。PUSH_PROMISE必须遵循请求-响应原则，只能借着对请求的响应推送资源。 首部压缩 HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。 HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。 不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。压缩算法使用HPACK。可让报头更紧凑，更快速传输，有利于移动网络环境。 []( 基于HTTP的协商过程ALPN协议 支持HTTP 2.0的浏览器可以在TLS会话层自发完成和服务端的协议协商以确定是否使用HTTP 2.0通信。其原理是TLS 1.2中引入了扩展字段，以允许协议的扩展，其中ALPN协议（Application Layer Protocol Negotiation, 应用层协议协商, 前身是NPN）用于客户端和服务端的协议协商过程。服务端使用ALPN，监听443端口默认提高HTTP 1.1，并允许协商其他协议，比如SPDY和HTTP 2.0。比如，客户端在TLS握手Client Hello阶段表明自身支持HTTP 2.0 服务端收到后，响应Server Hello，表示自己也支持HTTP 2.0。双方开始HTTP 2.0通信。 HTTP Upgrade机制 HTTP Upgrade机制（OkHttp, nghttp2等组件均可实现，也可以自己编码完成）通过协调确定适当的协议： 1234567891011121314HTTP Upgrade requestGET / HTTP/1.1host: nghttp2.orgconnection: Upgrade, HTTP2-Settingsupgrade: h2c /*发起带有HTTP2.0 Upgrade头部的请求*/ http2-settings: AAMAAABkAAQAAP__ /*客户端SETTINGS净荷*/user-agent: nghttp2/1.9.0-DEVHTTP Upgrade response HTTP/1.1 101 Switching Protocols /*服务端同意升级到HTTP 2.0*/Connection: UpgradeUpgrade: h2cHTTP Upgrade success /*协商完成*/ HTTP/3虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。 上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。 因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。 那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了，因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。 基于这个原因，Google 就自己架起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，HTTP/3 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。 QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 QUIC 功能。 QUIC 功能 0RTT 通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。0RTT 建连可以说是 QUIC 相比 HTTP/2 最大的性能优势。那什么是 0RTT 建连呢？ 这里面有两层含义: 1、传输层 0RTT 就能建立连接。 2、加密层 0RTT 就能建立加密连接。 因为这里考虑到安全性，我们就拿加了 TLS 的“安全的 HTTP 协议”HTTPS 来对比。上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT，就算是会话复用也需要至少 2 个 RTT。 而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的会话记录单要高很多。 多路复用 QUIC 原生实现了多路复用功能，并且传输的单个数据流可以保证有序交付且不会影响其它数据流，这样的技术就解决了前边提到的 TCP 多路复用存在的问题。 同 HTTP/2 一样，同一个 QUIC 连接上可以创建多个 stream 来发送多个 HTTP 请求，但是，QUIC 是基于 UDP 的，因为一个连接上的多个 stream 之间没有依赖，所以不存在 HTTP/2 中的问题。比如下图中 stream2 丢了一个 UDP 包，不会影响后面跟着 Stream3 和 Stream4，不存在 TCP 队头阻塞。虽然 stream2 的那个包需要重新传，但是 stream3、stream4 的包无需等待就可以发给用户。 另外 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。而 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。 加密认证的报文 TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改、注入和窃听，比如修改序列号与滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。 相比之下，QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。 这样只要是针对 QUIC 报文进行了任何修改，接收端都能够及时发现，有效地降低了安全风险。 如上图所示，红色部分是 Stream Frame 的报文头部，有认证；绿色部分是报文内容，全部经过加密。 前向纠错机制 QUIC 协议有一个非常独特的特性，称为前向纠错（Forward Error Correction，FEC），每个数据包除了它本身的内容之外，还包括了部分其它数据包的数据，因此少量的丢包可以通过其它包的冗余数据直接组装而无需重传。 前向纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传次数。这会取得更好的效果，因为数据重传将会消耗更多的时间，包括确认数据包丢失、请求重传与等待新数据包等步骤。 假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包，当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。 https://www.xuebuyuan.com/3267330.html https://blog.csdn.net/zhuyiquan/article/details/69257126 https://zhuanlan.zhihu.com/p/68012355?utm_source=qq&amp;utm_medium=social&amp;utm_oi=549346247203553280]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>学习指南</tag>
      </tags>
  </entry>
</search>
