<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Typescript学习笔记]]></title>
    <url>%2F2019%2F06%2F12%2Ftypescript%2F</url>
    <content type="text"><![CDATA[Typescript学习笔记前言基础类型布尔值、数字同JS 字符串字符串字面量类型用来约束取值只能是某几个字符串中的一个。 1234567type EventNames = &apos;click&apos; | &apos;scroll&apos; | &apos;mousemove&apos;;function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById(&apos;hello&apos;), &apos;scroll&apos;); // 没问题handleEvent(document.getElementById(&apos;world&apos;), &apos;dbclick&apos;);/ 报错，event 不能为 &apos;dbclick&apos; 元组Tuple表示已知元素数量和类型的数组 1234// Declare a tuple typelet x: [string, number];// Initialize itx = [&apos;hello&apos;, 10]; 当访问一个越界的元素，会使用联合类型替代： 123x[3] = &apos;world&apos;; // OK, 字符串可以赋值给(string | number)类型x[6] = true; // Error, 布尔不是(string | number)类型console.log(x[5].toString()); // OK, &apos;string&apos; 和 &apos;number&apos; 都有 toString 枚举enum自定义索引的数组，为一组数值赋予友好的名字。用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等 12345enum Color &#123;Red, Green, Blue&#125;// 从0开始，0,1,2；Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;enum Color &#123;Red = 1, Green, Blue&#125;// 从1开始，1,2,3；enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;// 1,2,4；let c: Color = Color.Green;//2let colorName: string = Color[2];//由枚举的值得到它的名字 Green 字符串枚举字符串枚举的概念很简单，但是有细微的运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 123456enum Direction &#123; Up = "UP", Down = "DOWN", Left = "LEFT", Right = "RIGHT",&#125; 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。 任意值any使用any类型来标记不希望被类型检查器检查而直接通过编译阶段检查的变量。 允许你在编译时可选择地包含或移除类型检查。 你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法 123456let notSure: any = 4;notSure.ifItExists(); // okay, ifItExists might exist at runtimenotSure.toFixed(); // okay, toFixed exists (but the compiler doesn&apos;t check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property &apos;toFixed&apos; doesn&apos;t exist on type &apos;Object&apos;. 空值void 当一个函数没有返回值时，你通常会见到其返回值类型是void： 123function warnUser(): void &#123; console.log("This is my warning message");&#125; void类型的变量只能赋予为undefined和null： 1let unusable: void = undefined; Null 和 Undefined默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给number类型的变量。 123// Not much else we can assign to these variables!let u: undefined = undefined;let n: null = null; Nevernever类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。 下面是一些返回never类型的函数： 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error("Something failed");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 联合类型123456789101112131415let myFavoriteNumber: string | number;Dinner要么有 fish 要么有 bear// 🙁 Not good.interface Dinner1 &#123; fish?: number, bear?: number,&#125;// 🙂 Awesome!type Dinner2 = &#123; fish: number,&#125; | &#123; bear: number,&#125; 映射类型12type Keys = &apos;option1&apos; | &apos;option2&apos;;type Flags = &#123; [K in Keys]: boolean &#125;; 等价于 1234type Flags = &#123; option1: boolean; option2: boolean;&#125; 类型断言类型断言好比其它语言里的类型转换，把变量当做断言的类型，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。类型断言不是类型转换，只能断言成一个联合类型或any中的类型。 类型断言有两种形式。 其一是“尖括号”语法： 12let someValue: any = "this is a string";let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： 12let someValue: any = "this is a string";let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 123let ro: ReadonlyArray&lt;number&gt; = a;a = ro; // error! Readonlya = ro as number[];// 用类型断言重写 查找类型123456789interface Person &#123; name: string; age: number; location: string;&#125;type K1 = keyof Person; // "name" | "age" | "location"type K2 = keyof Person[]; // "length" | "push" | "pop" | "concat" | ...type K3 = keyof &#123; [x: string]: Person &#125;; // string in keyofkeyof产生联合类型,in` 则可以遍历枚举类型 keyof 可以用来取得一个对象接口的所有 key值. 12345interface Foo &#123; name: string; age: number&#125;type T = keyof Foo // -&gt; "name" | "age" in 则可以遍历枚举类型, 例如 1234type Keys = "a" | "b"type Obj = &#123; [p in Keys]: any&#125; // -&gt; &#123; a: any, b: any &#125; typeof123const a: number = 3// 相当于: const b: number = 4const b: typeof a = 4 isconst 断言12const x = &apos;x&apos;; // has the type &apos;x&apos; let y = &apos;x&apos;; // has the type string 接口变量类型123456789101112131415161718interface LabeledValue&#123; label:string; model:string=&apos;&apos;;//默认“” color?:string;//可选属性 readonly width:number;//只读属性,赋值后不能被改变&#125;function printLabel(labeledObj: LabeledValue) &#123;//引入接口 console.log(labeledObj.label);&#125;let myObj = &#123;color: &quot;red&quot;, label: &quot;Size 10 Object&quot;, width: 10&#125;;printLabel(myObj);type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;//keyof T 拿到 T 所有属性名, 然后 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值.type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;//将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个+? , 这个含义自然与-?之前相反, 它是用来把属性变成可选项的. readonly vs const做为变量使用的话用const，若做为属性则使用readonly。 函数类型使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 1234567891011121314interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125;// 函数的参数名不需要与接口里定义的名字相匹配,只要求对应位置上的参数类型是兼容的//等价mySearch = function(source: string, subString: string): boolean &#123; let result = source.search(subString); return result &gt; -1;&#125; 可索引的类型Typescript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用100（一个number）去索引等同于使用&quot;100&quot;（一个string）去索引，因此两者需要保持一致。 对数组的约束123456interface StringArray &#123; [index: number]: string;//表示定义的数组是key是number类型，value是string类型&#125;let myArray: StringArray;myArray = ["Bob", "Fred"];let myStr: string = myArray[0];//Bob 对对象的约束123456789101112131415interface UserObj &#123; [index: string]: string&#125;var arr: UserObj = &#123; name: &apos;张三&apos; &#125;;interface Dictionary&lt;T&gt; &#123; [index: string]: T;&#125;;interface NumericDictionary&lt;T&gt; &#123; [index: number]: T;&#125;;const data:Dictionary&lt;number&gt; = &#123; a: 3, b: 4&#125; 类类型接口强制一个类去符合某种契约。同时描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125; 继承一个接口可以继承多个接口，创建出多个接口的合成接口。 123456789interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125; 泛型泛型变量泛型就是：给类型传参 3个主要用途： 声明泛型容器或组件。比如：各种容器类Map、Array、Set等；各种组件，比如React.Component。 对类型进行约束。比如：使用extends约束传入参数符合某种特定结构。 生成新的类型。比如，上一章提到的ReturnType。 当使用 TypeScript 实现的时候，我们需要在执行前就定义好函数返回的类型，但是我们又不能确定这个对象到底是什么类型，这里就可以借助泛型来实现：这是一种使返回值的类型与传入参数的类型是相同的方法。 这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。 我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。 123456789function identity&lt;T&gt;(arg: T): T &#123;//1.声明泛型，2.参数泛型，3.返回值泛型 return arg;&#125;//事先不知道它是哪种类型，所以不能随意的操作它的属性或方法，表明泛型是个数组后可以使用.lengthfunction loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125; 多个类型参数定义泛型的时候，可以一次定义多个类型参数： 1234function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, &apos;seven&apos;]); // [&apos;seven&apos;, 7] 上例中，我们定义了一个 swap 函数，用来交换输入的元组。 索引访问操作符12345function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] &#123; return o[name]; // o[name] is of type T[K]&#125;getProperty(&#123;age:18&#125;, &apos;age&apos;)//K是T的key，T[K]是T的value 泛型约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 工具泛型Partial &amp; Pick将所有属性变成可选属性 12345678910111213141516//源码type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;;type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;;interface User &#123; id: number; age: number; name: string;&#125;;// 相当于: type PartialUser = &#123; id?: number; age?: number; name?: string; &#125;type PartialUser = Partial&lt;User&gt;// 相当于: type PickUser = &#123; id: number; age: number; &#125;type PickUser = Pick&lt;User, &quot;id&quot; | &quot;age&quot;&gt; RequiredRequired 的作用是将传入的属性变为必选项, 源码如下 1type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;; -?将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个+? ,把属性变成可选项的. Mutable (未包含)类似地, 其实还有对 + 和 -, 这里要说的不是变量的之间的进行加减而是对 readonly 进行加减.以下代码的作用就是将 T 的所有属性的 readonly 移除,你也可以写一个相反的出来. 123type Mutable&lt;T&gt; = &#123; -readonly [P in keyof T]: T[P]&#125; Readonly将传入的属性变为只读选项 1type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;; Record将 K 中所有的属性的值转化为 T 类型 1type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T &#125;; EEOExclude 接受两个类型，去除T中的U1234type Exclude&lt;T, U&gt; = T extends U ? never : T;// 相当于: type A = 'a'type A = Exclude&lt;'x' | 'a', 'x' | 'y' | 'z'&gt;Exclude&lt;'age'|'name','age'&gt; // 'name' Extract 同样接受两个类型，提取T中的U1Extract&lt;'age'|'name'|'height','age'|'weight'&gt; // 'age' Omit12345678type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;interface User &#123; id: number; age: number; name: string;&#125;;// 相当于: type PickUser = &#123; age: number; name: string; &#125;type OmitUser = Omit&lt;User, &quot;id&quot;&gt; ReturnType在阅读源码之前我们需要了解一下 infer 这个关键字, 在条件类型语句中, 我们可以用 infer 声明一个类型变量并且对它进行使用,我们可以用它获取函数的返回类型， 源码如下 12345type ReturnType&lt;T&gt; = T extends ( ...args: any[]) =&gt; infer R ? R : any; 其实这里的 infer R 就是声明一个变量来承载传入函数签名的返回值类型, 简单说就是用它取到函数返回值的类型方便之后使用.具体用法 1234function foo(x: number): Array&lt;number&gt; &#123; return [x];&#125;type fn = ReturnType&lt;typeof foo&gt;; AxiosReturnType (未包含)开发经常使用 axios 进行封装 API层 请求, 通常是一个函数返回一个 AxiosPromise&lt;Resp&gt;, 现在我想取到它的 Resp 类型, 根据上一个工具泛型的知识我们可以这样写. 12345import &#123; AxiosPromise &#125; from 'axios' // 导入接口type AxiosReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; AxiosPromise&lt;infer R&gt; ? R : any// 使用type Resp = AxiosReturnType&lt;Api&gt; // 泛型参数中传入你的 Api 请求函数 类公有私有TypeScript里，成员都默认为public。当成员被标记成private时，它就不能在声明它的类的外部访问。 TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有private或protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样一个private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于protected成员也使用这个规则。 123456class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal(&quot;Cat&quot;).name; // 错误: &apos;name&apos; 是私有的. 受保护protectedprotected修饰符与private修饰符的行为很相似，但有一点不同，protected`成员在派生类中仍然可以访问 1234567891011121314151617181920class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 只读readonly你可以使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 函数函数的完整类型 12let myAdd: (x:number, y:number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确，参数名旁使用?实现可选参数。lastName = “Smith” 把last name的默认值设置为&quot;Smith&quot;。 在函数和返回值类型之前使用(=&gt;)符号，使之清晰明了。如果函数没有返回任何值，也必须指定返回值类型为void而不能留空。 this匿名函数this12345678910111213141516171819202122interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123;//不指定this为any return () =&gt; &#123; //箭头函数能保存函数创建时的`this`值，而不是调用时的值。这里是Deck；如果是function()&#123; this 往往报错，为window或undefined let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125; 回调函数this当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的this会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，this将为undefined。 稍做改动，你就可以通过this参数来避免错误。 首先，库函数的作者要指定this的类型： 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; this: void意味着addClickListener期望onclick是一个函数且它不需要一个this类型。 然后，为调用代码里的this添加类型注解： 123456789class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used this here. using this callback would crash at runtime this.info = e.message; &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! 指定了this类型后，你显式声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到addClickListener要求函数带有this: void。 改变this类型来修复这个错误： 123456789class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use this here because it's of type void! console.log('clicked!'); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); 因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用this.info. 如果你两者都想要，你不得不使用箭头函数了： 1234class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message &#125;&#125; 这是可行的因为箭头函数使用外层的this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到Handler的原型链上。 它们在不同Handler对象间是共享的。 重载同一个函数提供多个函数类型定义来进行函数重载 对象对象的展开与剩余运算符TypeScript 2.1 带来了对 ES2017 展开与剩余运算符的支持. 和数组的展开类似, 展开一个对象可以很方便地获得它的浅拷贝: 1let copy = &#123; ...original &#125;; 相似的, 你可以合并多个不同的对象. 在下面的例子中, merged 会有来自 foo, bar 和 baz 的属性. 1let merged = &#123; ...foo, ...bar, ...baz &#125;; 你也可以覆盖已有的属性和添加新的属性: 12let obj = &#123; x: 1, y: "string" &#125;;var newObj = &#123;...obj, z: 3, y: 4&#125;; // &#123; x: number, y: number, z: number &#125; 指定展开操作的顺序决定了那些属性的值会留在创建的对象里; 在靠后的展开中出现的属性会 “战胜” 之前创建的属性. 对象的剩余操作和对象的展开是对应的, 这样一来我们可以导出解构一个元素时被漏掉的其他属性. 123let obj = &#123; x: 1, y: 1, z: 1 &#125;;let &#123; z, ...obj1 &#125; = obj;obj1; // &#123;x: number, y: number&#125;; 声明http://json.schemastore.org/tsconfig https://legacy.gitbook.com/book/zhongsp/typescript-handbook/details http://www.typescriptlang.org/ https://ts.xcatliu.com/ https://zhuanlan.zhihu.com/p/24267683 https://zhuanlan.zhihu.com/p/58517848 https://zhuanlan.zhihu.com/p/66624970 https://zhuanlan.zhihu.com/p/39620591 https://zhuanlan.zhihu.com/p/64423022 https://zhuanlan.zhihu.com/p/40311981]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试指南_JavaScript]]></title>
    <url>%2F2019%2F06%2F03%2Finterview_JavaScript%2F</url>
    <content type="text"><![CDATA[前端面试指南_JavaScript DOMBOM异步EventLoopcallbackpromiseasync/await面向对象继承封装多台柯里化运行机制]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>面试指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试指南_算法]]></title>
    <url>%2F2019%2F06%2F03%2Finterview_algorithm%2F</url>
    <content type="text"><![CDATA[前端面试指南_算法数据结构数组JS的Array是一个万能的数据结构，为什么这么说呢？因为首先它可以当作一个普通的数组来使用，即通过下标找到数组的元素 然后它可以当作一个栈来使用，我们知道栈的特点是先进后出，栈的基本操作是出栈和入栈 同时它还可以当作一个队列，队列的特点是先进先出，基本操作是出队和入队 甚至它还可以当作一个哈希表来使用(但是不推荐这么用) 源码里面说，JSArray有两种模式，一种是快速的，一种是慢速的，快速的用的是索引直接定位，慢速的使用用哈希查找 JSArray是继承于JSObject 增push unshift splice 删pop shift splice 查arr[i] indexOf lastIndexOf includes find findIndex 12345arr.find(callback(element,index,array)[, thisArg])find方法对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回 undefined。注意 callback 函数会为数组中的每个索引调用即从 0 到 length - 1，而不仅仅是那些被赋值的索引，这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。find方法不会改变数组。callback函数带有3个参数：当前元素的值、当前元素的索引，以及数组本身。findIndex() 方法，它返回数组中找到的元素的索引，而不是其值。 改concat join reverse slice sort 1234567891011arr.sort([compareFunction()])numbers.sort((a, b) =&gt; a - b); 从小到大sort方法用原地算法对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。快速排序和优化的归并排序快速排序主要是对哪些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序。使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的归并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。补充一点合并排序的时间复杂度是nlogn, 快速排序的平均时间复杂度也是nlogn，但是合并排序的需要额外的n个引用的空间。当待排序的数组中的元素个数较少时，源码中的阀值为7，采用的是插入排序。尽管插入排序的时间复杂度为0(n^2)，但是当数组元素较少时，插入排序优于快速排序，因为这时快速排序的递归操作影响性能。 迭代器every somefilter reduce map forEach 12345678910111213141516171819202122every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。numbers.every((a) =&gt; a&gt;10)some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。arr.some(callback(element[, index[, array]])[, thisArg])filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])numbers.reduce(function(accumulator, currentValue, currentIndex, array)&#123; return accumulator + currentValue;&#125;);map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array &#125;[, thisArg])forEach() 方法对数组的每个元素执行一次提供的函数。arr.forEach(callback[, thisArg]); 链表(未完)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function LinkedList()&#123; let Node = function(element)&#123; this.element = element; this.next = null; &#125; let length = 0; let head = null; this.append = function(element)&#123; let node = new Node(element),current; if(head === null)&#123; head = node; &#125;else&#123; current = head; while(current.next)&#123; current = current.next &#125; current.next = node; &#125; length++; &#125; this.insert = function(position,element)&#123;&#125; this.removeAt = function(position)&#123; if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let current = head,previous,index=0; if(position === 0)&#123; head = current.next; &#125;else&#123; while(index++&lt;position)&#123; previous = current; current = current.next; &#125; length--; return current.element; &#125; &#125;else&#123; return null; &#125; &#125; this.remove = function(element)&#123;&#125; this.indexOf = function(element)&#123;&#125; this.isEmpty = function()&#123;&#125; this.size = function()&#123;&#125; this.getHead = function()&#123;&#125; this.toString = function()&#123; let current = head,string=&quot;&quot;; while(current)&#123; string+=current.element+(current.next?&quot; &quot;:&quot;&quot;); current=current.next &#125; return string &#125; this.print = function()&#123; return head &#125; &#125; 集合一组无序且唯一的项构成，键值相同 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function Set()&#123; let items = &#123;&#125; this.has = function(value)&#123; return items.hasOwnProperty(value); &#125; this.add = function(value)&#123; if(!this.has(value))&#123; items[value] = value; return true; &#125; return false; &#125; this.remove = function(value)&#123; if(this.has(value))&#123; delete items[value]; return true &#125; return false; &#125; this.clear=function()&#123; items = &#123;&#125; &#125; this.size = function()&#123; return Object.keys(items).length; &#125; this.values = function()&#123; let values = []; for(let i = 0,keys=Object.keys(items);i&lt;keys.length;++i)&#123; values.push(itmes[keys[i]]); &#125; return values; &#125; //并集 this.union = function(otherSet)&#123; let unionSet = new Set() let valuse = this.values(); for(let i = 0;i&lt;values.length;++i)&#123; unionSet.add(values[i]) &#125; valuse = otherSet.values(); for(let i = 0;i&lt;values.length;++i)&#123; unionSet.add(values[i]) &#125; return unionSet; &#125; //交集 this.intersection = function(otherSet)&#123; let intersectionSet = new Set() let values = this.values() for(let i = 0;i&lt;values.length;++i)&#123; if(otherSet.has(values[i]))&#123; intersectionSet.add(values[i]) &#125; &#125; return intersectionSet &#125; //差集 this.difference = function(otherSet)&#123; let differenceSet = new Set() let values = this.values() for(let i = 0;i&lt;values.length;++i)&#123; if(!otherSet.has(values[i]))&#123; intersectionSet.add(values[i]) &#125; &#125; return differenceSet &#125;&#125; 字典/映射(未完)键值对映射，类似于集合值值对 1234function Dictionary()&#123; let items = &#123;&#125;&#125;//可用Map代替 散列表通过一个特定散列函数处理值得到独一无二的键实现快速查找，但开的空间比较大 树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function BinarySearchTree()&#123; let Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125; let root = null; let insertNode = function(node,newNode)&#123; if(newNode.key &lt; node.key)&#123; if(node.left === null)&#123; node.left = newNode &#125;else&#123; insertNode(node.left,newNode); &#125; &#125;else&#123; if(node.right===null)&#123; node.right = newNode; &#125;else&#123; insertNode(node.right,newNode); &#125; &#125; &#125; this.insert = function(key)&#123; let newNode = new Node(key); if(root === null)&#123; root = newNode; &#125;else&#123; insertNode(root,newNode); &#125; &#125; this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root,callback); &#125; let inOrderTraverseNode = (node,callback)=&gt;&#123; if(node!==null)&#123; inOrderTraverseNode(node.left,callback); callback(node.key) inOrderTraverseNode(node.right,callback); &#125; &#125; this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root,callback); &#125; let preOrderTraverseNode = (node,callback)=&gt;&#123; if(node!==null)&#123; callback(node.key) preOrderTraverseNode(node.left,callback); preOrderTraverseNode(node.right,callback); &#125; &#125; this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root,callback); &#125; let postOrderTraverseNode = (node,callback)=&gt;&#123; if(node!==null)&#123; postOrderTraverseNode(node.left,callback); postOrderTraverseNode(node.right,callback); callback(node.key) &#125; &#125; this.print = function()&#123; return root; &#125;&#125; 算法排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//冒泡O(n^2)bbubbleSort = (arr) =&gt;&#123; let length = arr.length; for(1let i = 0;i&lt;length;++i)&#123; for(let j = 0;j&lt;length-1-i;++j)&#123; if(arr[j]&gt;arr[j+1])&#123; let temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125;&#125;//选择O(n^2)selectionSort = (arr)=&gt;&#123; let length = arr.length,indexMin; for(let i = 0;i&lt;length-1;++i)&#123; indexMin = i; for(let j = i;j&lt;length;++j)&#123; if(arr[indexMin]&gt;arr[j])&#123; indexMin = j; &#125; &#125; if(i!=indexMin)&#123; let temp = arr[i]; arr[i]=arr[indexMin]; arr[indexMin]=temp; &#125; &#125;&#125;//插入O(n^2)，小数组比上面好insertionSort = (arr)=&gt;&#123; let length = arr.length,j,temp; for(let i = 1;i&lt;ength;++i)&#123; j = i; temp = arr[i] while(j&gt;0&amp;&amp;arr[j-1]&gt;temp)&#123; arr[j]= arr[j-1] j--; &#125; arr[j]=temp &#125;&#125;//归并O(nlogn)分治mergeSort =(arr)=&gt;&#123; arr = mergeSortRec(arr)&#125;mergeSortRec =(arr)=&gt;&#123; let length = arr.length; if(length==1)&#123; return arr &#125; let mid = Math.floor(length/2) left = arr.slice(0,mid) right = arr.slice(mid,length) return merge(mergeSortRec(left),mergeSortRec(right))&#125;merge =(left,right)=&gt;&#123; let result = [], il = 0, ir = 0; while(il&lt;left.length&amp;&amp;ir&lt;right.length)&#123; if(left[il]&lt;right[ir])&#123; result.push(left[il++]); &#125;else&#123; result.push(right[ir++]) &#125; &#125; while(il&lt;left.length)&#123; result.push(left[il++]); &#125; while(ir&lt;right.length)&#123; result.push(right[ir++]) &#125; return result&#125;//快排O(nlogn)quickSort=(arr)=&gt;&#123; quick(arr,0,arr.length-1)&#125;quick = (arr,left,right)&#123; let index if(arr.length&gt;1)&#123; index = partition(arr,left,right) if(left&lt;index-1)&#123; quick(arr,left,index-1) &#125; if(index&lt;right)&#123; quick(arr,index,right) &#125; &#125;&#125;partition=(arrr,left,right)=&gt;&#123; let pivot = arr[Math.floor((right+left)/2)],i=left,j=right; while(i&lt;=j)&#123; while(arr[i]&lt;pivot)&#123; ++i; &#125; while(arr[j]&gt;pivot)&#123; j-- &#125; if(i&lt;=j)&#123; let temp = arr[j] arr[j]=arr[i] arr[i] = temp &#125; &#125; return i&#125;//堆排heapSort = (arr)=&gt;&#123; let heapSize =arr.length; buildHeap(arr) while(heapSize&gt;1)&#123; heapSize--; [arr[0],arr[heapSize]]=[arr[heapSize],arr[0]] heapify(arr,heapSize,0) &#125;&#125;buildHeap = (arr)=&gt;&#123; heapSize = arr.length for(let i = Math.floor(arr.length/2);i&gt;=0;i--)&#123; heapify(arr,heapSize,i) &#125;&#125;heapify = (arr,heapSize,i)=&gt;&#123; let left = 2*i+1,right = i*2+2,largest = i; if(left&lt;heapSize &amp;&amp; array[left]&gt;arr[largest])&#123; largest = left; &#125; if(right&lt;heapSize &amp;&amp; array[right]&gt;arr[largest])&#123; largest = right; &#125; if(largest!=i)&#123; [arr[i],arr[largest]]=[arr[largest],arr[i]] &#125;&#125; 搜索算法12345678910111213141516171819//顺序//二分binarySearch = (arr,item)=&gt;&#123; let brr = quickSort(arr) let low = 0,high = brr.length -1,mid,element; while(low&lt;=high)&#123; mid = Math.floor((low+high)/2); element = brr[mid] if(element &lt;item)&#123; low = mid+1; &#125;else if(element &gt;item)&#123; high = mid -1; &#125;else&#123; return mid &#125; &#125; return -1&#125; 算法模式12345678910111213141516//递归 ES6有尾调用优化，递归并不更慢fibonacci = (num)=&gt;&#123; if(num ===1||num===2)&#123; return 1 &#125; return fibonacci(num-1)+fibonacci(num-2)&#125;fib = (num)=&gt;&#123; let n1 = 1,n2=1,n=1; for(let i = 3;i&lt;num;++i)&#123; n = n1+n2; n1=n2; n2=n; &#125; return n&#125; 动态规划最少硬币12345678910111213141516171819202122232425262728let minCoin = (coins) =&gt;&#123; let cache = &#123;&#125;; this.makeChange = (amount)=&gt;&#123; let me = this; if(!amount)&#123; return []; &#125; if(cache[amount])&#123; return cache[amount] &#125; let min = [],newMin,newAmount; for(let i = 0;i&lt;coins.length;++i)&#123; let newAmount = amount -coin,coin = coins[i]; if(newAmount &gt;= 0)&#123; newMin = me.makeChange(newAmount); &#125; if( newAmount&gt;=0&amp;&amp; (newMin.length&lt;min.length-1||!min.length) &amp;&amp;(newMin.lengthh||!newAmount) )&#123; min = [coin].concat(newMin); console.log(min+&apos;for&apos;+amount) &#125; &#125; return (cache[amount]=min) &#125;&#125; 贪心最少硬币123456789101112131415function minChange(coins,amount)&#123; coins = quickSort(coins) let l = coins.length-1,cache = []; while(l&gt;=0&amp;&amp;amount&gt;=0)&#123; if(amount&gt;=coins[l])&#123; cache.push(coins[l]) amount -=coins[l] &#125;else&#123; l-- &#125; &#125; return cache&#125;//问题，只在相邻级别中，前一级比后一级少一半以上才可以[1,2,5,10,20,50,100],如果是[1,3,4]这种不行第一种从较小的硬币集合开始算，只有[1],[1,3],[1,3,4] https://zhuanlan.zhihu.com/p/26388217]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>面试指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试指南_浏览器]]></title>
    <url>%2F2019%2F06%2F03%2Finterview_browser%2F</url>
    <content type="text"><![CDATA[前端面试指南_浏览器主流浏览器：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera浏览器的主要组件为： 用户界面 - 除了浏览器主窗口显示的页面外，其他的部分，包括地址栏、前进/后退按钮、书签菜单等。 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。 渲染引擎 - 负责显示请求的内容，负责解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。Firefox-Gecko，Safari和Chrome-WebKit 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。|浏览器|渲染引擎|JS解释器||–|–|–||Chrome|WebKit-&gt;Blink(2013)、|V8||Firefox|Gecko|SpiderMonkey||Safari|Webkit|Nitro||Edge|EdgeHTML-&gt;Chromium(Blink)|Chakra||Opera|Presto-&gt;Blink|V8||IE|Trident|Chakra| Trident IE内核；Blink Chrome内核；Gecko内核 Firefox内核；Safari内核 Webkit内核；360浏览器(IE/Chrome)、2345(IE/Chrome)、钉钉内置浏览器(UC =&gt; Chrome)等等360浏览器、猎豹浏览器内核：IE+Chrome双内核；搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；百度浏览器、世界之窗内核：IE内核；2345浏览器内核：好像以前是IE内核，现在也是IE+Chrome双内核了；UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident，还有说是基于火狐内核。。 输入URL判断 协议 缓存 输入的是 URL 还是 query域名解析DNS 查询 建立连接HTTPS TCP三握四分 渲染 加载 当请求响应返回的时候，network thread 会依据 Content-Type及 MIME Type sniffing 判断响应内容的格式加载过程贼复杂，需要加载各种资源，比如html、css、js或者pdf等等。这里又可以分成两种情况，一种是内容加载，比如需要打开一个新进程、需要打开保存弹窗或者需要直接加载内容；另一种则是子资源下载，比如css、js、图片等等，这里又会涉及到缓存，选择本地读取还是去服务器请求等等一系列的问题。 如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程 解析 解析过程就就是解析上面加载的文件（HTML），建立DOM树的过程， 除了解析HTML生成DOM树，为了提高性能，一般浏览器都会做一些预处理动作，比如：DNS预获取、预加载扫描以及安全扫描(防XSS)等等。 DNS的预获取在前面就顺带提到了，预获取过程就在这里发生的。大家可以回到1688首页可以看到如下一段代码片：12345678&lt;!--dns预解析--&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//cbu01.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//img.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//astyle-src.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//g.alicdn.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//dcms.1688.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//gm.mmstat.com&quot; /&gt; &lt;link rel=&quot;dns-prefetch&quot; href=&quot;//log.mmstat.com&quot; /&gt; 这段代码片没有任何逻辑功能，唯一的作用就是主动告诉浏览器，赶紧去请求解析这些域名，我马上要用了，这样可以极大地缩减dns的解析时间。有人可能怀疑，放在头部，难道不会阻塞页面加载？实际上并不会，查了一下Chrome的文档，这玩意甚至都没有用浏览器的网络栈。Chrome会启动8个异步线程，啥都不干，就蹲在那里等浏览器给他丢任务（队列），然后去找操作系统要解析，这个过程唯一的作用就是提前触发DNS解析，后面再来的时候就直接走缓存了，实际上这8个线程只是下个任务罢了。除了上面这种写法来触发DNS的预获取，实际浏览器还会搞个线程去扫描html文件，看到域名以后也会丢给上面那8个线程。 构建DOM树 DOM本身没有任何渲染能力，我们渲染的也不是DOM。webkit会为DOM树建立一堆渲染树，这些渲染树再用于渲染。 渲染树是归属于DOM树的。渲染树是只存在于上下文中，上下文结束，树销毁；下次再次渲染，再新建一个渲染树。渲染树包含了渲染需要的一切信息。渲染树的节点会有不同种类，下面是几种常见的（都是从一个基类继承出来的），这些类都有自己的渲染方法，你只需要告诉它，该你出场了，他们自己就有方法去把自己画好解析html，生成一个DOM树，解析过程中遇到了script标签就会执行，注意的是，执行js会阻塞DOM的解析，这也是为什么都提倡把不重要的代码放到body的最后面来执行。 如果有些代码确实需要放在靠前的位置，可以写考虑写成异步的方式来避免阻塞页面渲染。新浏览器一般都支持了defer和async属性，其中defer属性的script的下载不会阻塞html解析，而且其会在解析完成后才执行；async属性则是下载不会阻塞html解析，但是执行还是会阻塞。这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。 加载次级的资源网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner 会同时运行，如果在 html 中存在 &lt;img&gt; &lt;link&gt; 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。 样式计算进程还会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值。即使不提供任何 CSS，浏览器对每个元素也会有一个默认的样式 获取布局 想要渲染一个完整的页面，除了获知每个节点的具体样式，还需要获知每一个节点在页面上的位置，布局其实是找到所有元素的几何关系的过程。其具体过程如下： 通过遍历 DOM 及相关元素的计算样式，主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中只包含页面可见的元素，如果一个元素设置了 display:none ，这个元素不会出现在布局树上，伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。 绘制各元素浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建 Rendering Tree即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。 合成帧最终通过调用Native GUI 的 API 绘制网页画面，称为 Paint复合是一种分割页面为不同的层，并单独栅格化，随后组合为帧的技术。不同层的组合由 compositor 线程（合成器线程）完成。主线程会遍历布局树来创建层树（layer tree），添加了 will-change CSS 属性的元素，会被看做单独的一层， z-index 事件处理在构建Rendering Tree的同时，生成Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象并执行所有绑定在其上的相关事件处理函数。件委托，基于事件冒泡，我们常常在最顶层绑定事件： document.body.addEventListener(‘touchstart’, event =&gt; { if (event.target === area) { event.preventDefault(); }} ); 事件分法deligation Repaint当元素改变的时候，将不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为 Repaint。Reflow当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。（ HTML 使用的是 flow based layout ，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 Reflow。） 重绘:当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。回流:当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建回流必定会发生重绘，重绘不一定会引发回流。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 1）常见引起回流属性和方法任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流， 添加或者删除可见的DOM元素；元素尺寸改变——边距、填充、边框、宽度和高度内容变化，比如用户在input框中输入文字浏览器窗口尺寸改变——resize事件发生时计算 offsetWidth 和 offsetHeight 属性设置 style 属性的值 重排width height margin padding display border position overflowclientWidth/Height/Top/Left offsetWidth/Height/Top/Left scrollWidth/Height/Top/Left scrollIntoView ScrollTo scrollIntoViewIfNeeded getComputedStyle getBoundingClientRect重绘color border-style viisbilitybackground text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size 不同的浏览器对于CSS和HTML的处理方式不同如果有的浏览器的渲染引擎是需要等待CSS加载完成之后，对HTML元素进行渲染和展示的，那么在CSS加载完成之前，页面上不有任何信息，这种现象称为白屏（谷歌Chrome和苹果Safari）而有的是先对HTML元素进行展示，然后等待CSS加载完成之后重新对样式进行修改，那么在CSS加载完之前，会首先在页面上显示没有任何CSS渲染的信息，这种现象称为FOUC(无样式内容闪烁)（IE和Firefox火狐） 问题四：为什么操作 DOM 慢因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。 问题五：渲染页面时常见哪些不良现象？由于浏览器的渲染机制不同，在渲染页面时会出现两种常见的不良现象—-白屏问题和FOUS（无样式内容闪烁） FOUC：由于浏览器渲染机制（比如firefox），再CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象； 白屏：有些浏览器渲染机制（比如chrome）要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把js文件放在头部，脚本会阻塞后面内容的呈现，脚本会阻塞其后组件的下载，出现白屏问题。 工作原理 渲染APIhttps://zhuanlan.zhihu.com/p/47407398https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>面试指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试指南]]></title>
    <url>%2F2019%2F06%2F03%2Finterview%2F</url>
    <content type="text"><![CDATA[前端面试指南 前言计算机通识计算机组成原理计算机网络TCP报头格式UDP报头格式TCP/UDP区别（不仅是宏观上的，最好能根据各自的机制讲解清楚）HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）HTTP协议（一些报头字段的作用，如cace-control、keep-alive）OSI协议、TCP/IP协议以及每层对应的协议。SESSION机制、cookie机制TCP三次握手、四次挥手（这个问题真的要回答吐了，不过真的是面试官最喜欢问的，建议每天手撸一遍，而且不只是每次请求的过程，各种FIN_WAIT、TIME_WAIT状态也要掌握）。打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。http和https区别，https在请求时额外的过程，https是如何保证数据安全的IP地址子网划分POST和GET区别DNS解析过程深入部分 TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握） 地址解析协议ARP 交换机和路由器的区别 操作系统当我们启动一个应用，计算机会创建一个进程，操作系统会为进程分配一部分内存，应用的所有状态都会保存在这块内存中，应用也许还会创建多个线程来辅助工作，这些线程可以共享这部分内存中的数据。如果应用关闭，进程会被终结，操作系统会释放相关内存。 一个进程还可以要求操作系统生成另一个进程来执行不同的任务，系统会为新的进程分配独立的内存，两个进程之间可以使用 IPC （Inter Process Communication）进行通信。很多应用都会采用这样的设计，如果一个工作进程反应迟钝，重启这个进程不会影响应用其它进程的工作。 “互斥锁””信号量” 内存的页面置换算法进程调度算法进程间通信方式进程线程区别进程之间的通信父子进程、孤儿进程fork进程时的操作 编译原理数学基础离散数学线性代数数据结构与算法数据结构线性表栈、队列两个栈实现队列。 链表插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环） 树层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）红黑树性质 堆大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整） 图深度广度优先遍历、单源最短路径、最小生成树） 算法查找二分查找（一般会深入，如寻找数组总和为K的两个数字 排序排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问） 动态规划贪心分治前端基础HTML5H5新特性：(1)Canvas绘图(2)SVG绘图(3)地理定位(4)Web Workerweb worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。(5)Web Storage1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）2.（兼容性差,数据8MB,操作简单）sessionStorage 3.localStorage(6)Web SocketWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。 CSS31.复杂的选择器2.弹性布局3.动画 JavaScript12const peopleConfig = Object.create(peopleConfigPrototype)// 采用Object.create方法，当前对象将被复制到peopleConfig的__proto__上 还有另一种方式进行对象拷贝，但是会丢掉对象中的函数： 1const peopleConfig = JSON.parse(JSON.stringfy(peopleConfigProtytype)) MVC，MVVM就是非常典型的中介模式。 中介模式，桥接模式，代理模式的区别是： 代理模式一对一，只能代理特定类和对象，是对其的扩展或是约束。 桥接模式一对多，是对类或对象成员或属性的扩展。 中介模式多对多，全权承包所有两个概念间的关系。 https://zhuanlan.zhihu.com/p/43283016 设计模式 ES6ES7+TypeScript1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。 Node.js浏览器数据库cookie/session/LocalStorage/SessionStorage cookie session LocalStorage SessionStorage ff ff ff ff 工程化性能优化安全测试管理GitWebpack模块化组件化 名称 说明 举例 JS模块 独立的算法和数据单元 浏览器环境检测(detect)，网络请求(ajax)，应用配置(config)，DOM操作(dom)，工具函数(utils)，以及组件里的JS单元 CSS模块 独立的功能性样式单元 栅格系统(grid)，字体图标(icon-fonts)，动画样式(animate)，以及组件里的CSS单元 UI组件 独立的可视/可交互功能单元 页头(header)，页尾(footer)，导航栏(nav)，搜索框(search) 页面 前端这种GUI软件的界面状态，是UI组件的容器 首页(index)，列表页(list)，用户管理(user) 应用 整个项目或整个站点被称之为应用，由多个页面组成 框架ReactVue设计模式函数式编程]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>面试指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用CSS画一只电老鼠]]></title>
    <url>%2F2019%2F05%2F12%2Fpikachu%2F</url>
    <content type="text"><![CDATA[如何用CSS画一只电老鼠 不知道大家有没有去看大侦探皮卡丘呀，有没有被银幕上毛茸茸的电老鼠萌到呢？现在我就来用CSS画一只简易版的皮卡丘吧。（希望不会收到东半球最强法务部的律师函） 12345678910111213141516171819&lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;div class=&quot;ear left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ear right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;eye left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;eye right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;face right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;mouth&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;ball&quot;&gt; &lt;div class=&quot;belt&quot;&gt; &lt;div class=&quot;lock&quot;&gt; &lt;div class=&quot;but&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;light&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177body&#123; display: flex; justify-content: center; align-items: center; min-height: 100vh; &#125;.main&#123; position: relative;&#125;.ear.left&#123; background: #ffe000; width:40px; height:90px; position: absolute; top:-44px; left:0; border-radius: 20px 20px 20px 20px/70px 070px 20px 20px; transform: rotate(-30deg); display: flex; justify-content: center; overflow: hidden;&#125;.ear.left::after&#123; content: &quot;&quot;; display: block; width:30px; height:20px; background: #4E4700; border-radius: 15px 15px 20px 20px/70px 70px 20px 20px;&#125;.ear.right&#123; background:#ffe000; width:40px; height:90px; position: absolute; top:-44px; right:0; border-radius: 20px 20px 20px 20px/70px 070px 20px 20px; transform: rotate(35deg); display: flex; justify-content: center; overflow: hidden;&#125;.ear.right::after&#123; content: &quot;&quot;; display: block; width:30px; height:20px; background: #4E4700; border-radius: 15px 15px 20px 20px/70px 70px 20px 20px;&#125;.eye&#123; background: #4E4700; width: 23px; height: 23px; border-radius: 23px;&#125;.eye.left&#123; position: absolute; left:38px; top:44px;&#125;.eye.right&#123; position: absolute; right:38px; top:44px;&#125;.mouth::before&#123; content: &apos;&apos;; display: block; width: 10px; height: 10px; border: 3px solid #4E4700; border-top:none; border-right: none; border-bottom-left-radius: 10px ; transform: rotateZ(-23deg); position: absolute; top:60px; left:86px;&#125;.mouth::after&#123; content: &apos;&apos;; display: block; width: 10px; height: 10px; border: 3px solid #4E4700; border-top: none; border-left: none; border-bottom-right-radius: 10px; transform: rotateZ(23deg); position: absolute; top:60px; right:86px;&#125;.head&#123; border-radius: 200px 200px 0 0; width:200px; height:100px; background:#ffe000;&#125;.face&#123; background:#FF9900; width:30px; height: 30px; border-radius: 30px; &#125;.face.left&#123; position: absolute; left:18px; bottom:101px;;&#125;.face.right&#123; position: absolute; right:18px; bottom:101px;&#125;.ball&#123; border-radius:0 0 200px 200px; width:200px; height:100px; background:#FF0000;&#125;.belt&#123; width:200px; height:15px; background:#322221; border-radius:0 0 2px 2px/0 0 15px 15px; display: flex; justify-content: center;&#125;.lock&#123; border-radius: 0 0 80px 80px; width:80px; height:40px; background:#322221;&#125;.lock::after&#123; content: &quot;&quot;; display:block; border-radius: 0 0 60px 60px; width:60px; height:30px; background:#FDFDFD; transform: translateX(10px);&#125;.but&#123; content: &quot;&quot;; display:block; border-radius: 0 0 40px 40px; width:40px; height:20px; background:#322221; transform: translateX(20px); position: absolute; z-index: 10;&#125;.but::after&#123; content: &quot;&quot;; display:block; border-radius: 0 0 20px 20px; width:20px; height:10px; background:#686160; transform: translateX(10px);&#125;.light&#123; background:#FFD7C9; width: 20px; height: 27px; border-radius: 10px 10px 10px 10px/15px 15px 10px 10px; position: absolute; top:150px; left:150px; transform: rotate(45deg);&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化]]></title>
    <url>%2F2019%2F04%2F04%2Foptimization%2F</url>
    <content type="text"><![CDATA[Git入门 #关键渲染路径 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。(CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。) 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局。 将各个节点绘制到屏幕上。当DOM或者CSSOM发生变化的时候，浏览器就需要再次执行一次上面的步骤。 当HTML解析过程中遇到一个script标记时，它会暂停DOM构建，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。也就是说，执行内联的JavaScript会阻塞页面的首次渲染。 ##对JS优化 引用JS方式async，完全的异步操作，HTML解析遇到该标签后，发出网络请求，但不阻止HTML解析和其后面的渲染操作，当JavaScript请求返回后立刻执行，且不等待HTML解析或其他操作的完成。所以，如果脚本中有DOM操作，就并不适合。defer，HTML的解析和对JavaScript资源的网络请求是并行的，但它会等待HTML解析完成之后，才执行脚本。 ##对CSS优化 尽早和按需的加载CSS 内联CSS来提高渲染性能 写样式尽量使用class和id，保证层级扁平，减少过度层叠 避免使用CSS表达式举个css表达式的例子 font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF” : “#AAAAAA” );这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。 不同浏览器首屏渲染策略不同。chrome等CSS加载完再渲染，Firefox先生成HTML再附上CSS ##减少HTTP请求 尽量少使用外链的JS和CSS文件以前CSS的@import 雪碧图，尽量合并图片、CSS、JS 渲染必备CSS内联到HTML中 缓存策略 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 可缓存的AJAX异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true就是显式的要求如果当前请求有缓存的话，直接使用缓存 123456$.ajax(&#123; url : &apos;url&apos;, dataType : &quot;json&quot;, cache: true, success : function(son, status)&#123; &#125; 减少Cookie的大小Cookie里面别塞那么多东西，因为每个请求都得带着他跑 使用无cookie的域比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。 ##减少资源的大小 压缩、去注释 JavaScript 和 CSS 使用gzip压缩内容gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。 延迟JavaScript非阻塞资源加载 删除未使用的代码 异步懒加载代码 懒加载屏幕外图片 预先加载关键请求 HTTP的传输层协议是TCP，TCP协议有一个慢启动的过程，即它在第一次传递数据时，只能同时传递14kb的数据块，所以当数据超多14kb时，TCP协议传递数据实际是多次的往返（roundtrip）。如果能够将渲染所需要的资源控制在14kb之内，那么就能TCP协议启动时，一次完成数据的传递。 ##CDN使用CDN网站上静态资源即css、js、图片全都使用cdn分发 #图像 ##JPG/JPEG ####优点JPG的压缩方式（有损压缩）是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩 的要求 ####缺陷处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会明显不支持透明度处理 ####使用场景背景图、轮播图或 Banner 图 ##PNG ####优点PNG是一种无损压缩的高保真的图片格式。8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。 ####缺点 体积太大。 ####使用场景小的 Logo、颜色简单且对比强烈的图片或背景 ##SVG ####优点SVG 指可伸缩矢量图形 ，属于对图像的形状描述，本质上是文本文件，体积较小，且不管放大多少倍都不会失真。 ####缺点绘制太复杂 ####使用场景LOGO ####使用方法 直接插入网页，成为 DOM 的一部分 12345678&lt;svg id=&quot;mysvg&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 800 600&quot; preserveAspectRatio=&quot;xMidYMid meet&quot;&gt; &lt;circle id=&quot;mycircle&quot; cx=&quot;400&quot; cy=&quot;300&quot; r=&quot;50&quot; /&gt;&lt;svg&gt; 写在一个独立文件中，然后用、、、等标签插入网页 1234&lt;img src=&quot;circle.svg&quot;&gt;&lt;object id=&quot;object&quot; data=&quot;circle.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;&lt;embed id=&quot;embed&quot; src=&quot;icon.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;icon.svg&quot;&gt;&lt;/iframe&gt; 转为 BASE64 编码，然后作为 Data URI 写入网页。 1&lt;img src=&quot;data:image/svg+xml;base64,[data]&quot;&gt; 重要属性 123fill：填充色stroke：描边色stroke-width：边框宽度 ##WebP ####优点与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。WebP 是谷歌引入的一种相对较新的格式，它的目标是通过以无损和有损格式编码图像来提供更小的文件大小，使其成为 JPEG 和 PNG 的一个很好的替代方案。WebP 图像的清晰度通常可以与 JPEG 和 PNG相提并论，而且文件大小要小得多。 ####缺点浏览器支持度不够 ####使用方式一旦有了 WebP 图像，可以使用以下标记将它们提供给可以使用它们的浏览器，同时向不兼容 WebP 的浏览器使用 png 或者 jpeg。12345&lt;picture&gt; &lt;source srcset=&quot;sample_image.webp&quot; type=&quot;image/webp&quot;&gt; &lt;source srcset=&quot;sample_image.jpg&quot; type=&quot;image/jpg&quot;&gt; &lt;img src=&quot;sample_image.jpg&quot; alt=&quot;&quot;&gt;&lt;/picture&gt; 理解 image/webp 媒体类型的浏览器将下载 Webp 图片并显示它，而其他浏览器将下载 JPEG 图片。任何不支持 的浏览器都将跳过所有 source 标签，并加载底部 img 标签。因此，我们通过提供对所有浏览器类的支持，逐步增强了我们的页面。*可以根据不同的条件加载不同的图像，这些条件可以是视窗当前的高度（viewport），宽度（width），方向（orientation），像素密度（dpr） #网络字体在网络加载比较慢的情况下，用户可能会感受到字体或者图形的变化（Icon Font）。其实，浏览器在渲染树构建完成之后，会指示需要哪些字体在网页上渲染指定文本，然后分派字体请求，浏览器执行布局并将内容绘制到屏幕上，如果字体尚不可用，浏览器可能不会渲染任何文本像素，待字体可用之后，再绘制文本像素，当然，不同浏览器之间实际行为有所差异123@font-face&#123; font-display:wrap;&#125; Font display 可帮助你根据交换所需的时间来决定网络字体的渲染或退阶方式。 ##其他 避免空的src和href当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。 避免跳转有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问 http://baidu.com 时，实际上返回的是一个包含301代码的跳转，它指向的是 http://baidu.com/（注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。另一种是不用域名之间的跳转， 比如访问 http://baidu.com/bbs 跳转到http://bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。 减少DOM元素数量就会减少浏览器的解析负担 避免404比如外链的css或者js文件出现问题返回404时，会破坏浏览器对文件的并行加载。并且浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。 不要使用滤镜IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 参考资料https://zhuanlan.zhihu.com/p/58419577http://www.ruanyifeng.com/blog/2018/08/svg.htmlhttps://zhuanlan.zhihu.com/p/38548289《高性能网站建设指南（第二版》]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL操作一览]]></title>
    <url>%2F2019%2F02%2F23%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySQL操作一览 BY wid一、概念 SQL即为Structured Query Language(结构化查询语言) MySQL 为关系型数据库(Relational Database Management System), 这种所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格: 表头(header): 每一列的名称; 列(column): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息,每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\物的方法,键的值在当前列中具有唯一性。一、安装信息配置的端口：3306 用户：Root:539450;CatcherInSky:zxc123 Windows Service Name: MySQL57 服务：控制面板-&gt;系统与安全-&gt;管理工具-&gt;服务 可停用、重启与卸载MySQL服务 路径：C:\Program Files\MySQL\MySQL Server 5.7\bin 二、基础操作1.用户行为 2.1.1.登录cmd进入安装路径，输入 mysql -D 数据库名 -h 主机名 -u 用户名 -p； 2.库的操作 2.2.1创建数据库 create database 数据库名 其它选项； 2.2.2查看数据库 show databases； 2.2.3登录数据库 use 数据库名（库声明）; 声明如： character set gbk 可将数据库字符编码指定为 gbk 2.2.4删除数据库 drop database 数据库名; .表的操作 2.3.1创建数据库表 create table 表名称(列声明); 对于一些较长的语句在命令提示符下可能容易输错,因此我们可以通过任何文本编辑器将语句输入好后保存为 createtable.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。 mysql -D samp_db -u root -p &lt; createtable.sql； (提示: 1.如果连接远程主机请加上 -h 指令; 2. 该文件若不在当前工作目录下需指定文件的完整路径。) 列声明首项为列的名称后面为数据类型描述。 2.3.2查看数据库表 查看所有表名称 show tables; 查看某个表的详细信息 describe 表名; 2.3.4删除数据库表 drop table 表名; 2.3.5重命名数据库表 alter table 表名 rename 新表名; 2.3.6修改数据库表alter table 语句用于创建后对表的修改, 基础用法如下: 2.3.6.1添加列 alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例:在表的最后追加列 address: alter table students add address char(60); 示例：在名为 age 的列后插入列 birthday: alter table students add birthday date after age; 2.3.6.2修改列 alter table 表名 change 列名称 列新名称 新数据类型; 示例：将表 tel 列改名为 telphone alter table students change tel telphone char(13) default “-“; 示例：将 name 列的数据类型改为 char(16) alter table students change name name char(16) not null; 2.3.6.3删除列 alter table 表名 drop 列名称; 示例:删除 birthday 列: alter table students drop birthday; 4.值的操作 2.4.1插入数据 insert [into] 表名 [(列名1, 列名2, …)] values (值1, 值2, …); 从第一列数据开始写全部数据 insert into students values(NULL, “王刚”, “男”, 20,”13811371377”); 从某列开始写部分数据 insert into students (name, sex, age) values(“孙丽华”, “女”, 21); 2.4.2查询表中的数据 select 列名称 from 表名称 where 特定条件; 也可以使用通配符 * 查询表中所有的内容。where 子句不仅仅支持 “where 列名 = 值” 这种名等于值的查询形式,对一般的比较运算的运算符都是支持的, 例如 =、&gt;、&lt;、&gt;=、&lt;、!=以及一些扩展运算符 is [not] null、in、like 等等。 还可以对查询条件使用 or 和 and 进行组合查询 示例:查询年龄在21岁以上的所有人信息: select * from students where age &gt; 21; 示例:查询名字中带有 “王” 字的所有人信息: select * from students where name like “%王%”; 示例:查询id小于5且年龄大于20的所有人信息: select * from students where id20; 2.4.3更新表中的数据 update 表名称 set 列名称=新值 更新条件; 2.4.4删除表中数据 delete from 表名称 where 删除条件; 不加条件删除所有数据]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>DataBase</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Console 对象]]></title>
    <url>%2F2018%2F11%2F24%2Fconsole%2F</url>
    <content type="text"><![CDATA[JavaScript Console 对象 Console 对象用于 JavaScript 调试。JavaScript 原生中默认是没有 Console 对象,这是宿主对象（也就是游览器）提供的内置对象。 用于访问调试控制台, 在不同的浏览器里效果可能不同。 Console 对象常见的两个用途： 显示网页代码运行时的错误信息。 提供了一个命令行接口，用来与网页代码互动。 Chrome和大部分浏览器都可以通过F12调出这个窗口 在console面板输入 for(var i in console){console.log(i)} 可列出所有Console方法 log()console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）: 占位符 作用 %s 字符串 %d or %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串 在console.log里使用CSS： info() warn() error() assert()assert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 clear()清除当前控制台的所有输出，将光标回置到第一行。 count()用于计数，输出它被调用了多少次。 group() groupCollapsed() groupEnd()用于将显示的信息分组，可以把信息进行折叠和展开。 与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 table()将复合类型的数据转为表格显示 time()计时 trace()追踪函数的调用过程 dirxml()用来显示网页的某个节点（node）所包含的html/xml代码。 profile() 性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在。 123456789101112131415function All() &#123; for (var i = 0; i &lt; 10; i++) &#123; funcA(1000); &#125; funcB(10000); &#125;function funcA(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125; &#125;function funcB(count) &#123; for (var i = 0; i &lt; count; i++) &#123;&#125; &#125;console.profile(&apos;性能分析器&apos;);All(); console.profileEnd(); dir()console.dir()方法用来对一个对象进行检查，并以易于阅读和打印的格式显示。类似于log()，但可以显示一个对象所有的属性和方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp正则表达式]]></title>
    <url>%2F2018%2F07%2F13%2Fregexp%2F</url>
    <content type="text"><![CDATA[正则表达式 定义正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、RegExp或RE），计算机科学的一个概念。在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 测试Javascript正则表达式在线测试工具[https://www.regexpal.com/][https://regexr.com/] 作用：在字符串操作中常用于： 验证（给定的字符串是否符合正则表达式的过滤逻辑） 验证输入是否符合规范 查找（可以通过正则表达式，从字符串中获取我们想要的特定部分） 查找所需字符段落 替换成自己想要的内容 还有一些特殊的操作 在HTML中可以这样使用 12345&lt;style&gt;input:invalid &#123; border-color: red; &#125; input, input:valid &#123; border-color: #ccc; &#125;&lt;/style&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; placeholder=&quot;tel&quot; pattern=&quot;\d&#123;11&#125;&quot;&gt; 声明123var expression = / pattern / flags;var expression = new RegExp(&quot; patterns &quot; , &quot; flags &quot;);//patterns为pattern中每个元字符前加一个\组成或者由字符串加变量组成 expression：正则表达式的名称 pattern：正则表达式的模式 flags：标志，包括 g:global,应用于所有字符串，而非在发现第一个匹配项时立即停止 i:case-insesitive,忽略大小写 m:multiline,多行检测 u:Unicode,用来正确处理大于\uFFFFd Unicode字符注意：点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码位大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符 y:sticky,y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 实例属性 属性 数据类型 意义 global boolean 是否有g标志 ignoreCase boolean 是否有i标志 multiline boolean 是否有m标志 lastIndex int 从第几个字符开始匹配 source str 正则表达式的字符串表示 flags str 正则表达式的修饰符 sticky boolean 是否有y标签 RegExp实例方法regObj.test(strObj)用于测试字符串中是否存在符合正则表达式模式的部分，如果存在则返回true，否则返回false。123456789var test = function()&#123; var PhoneNumber = /^\d&#123;11&#125;$/; var number1 = &quot;17802015408&quot;; var number2 = &quot;1530775669&quot;; var number3 = &quot;178020154080&quot;; console.log(&quot;number1 is a &quot; + PhoneNumber.test(number1) + &quot; phone number.&quot;); console.log(&quot;number2 is a &quot; + PhoneNumber.test(number2) + &quot; phone number.&quot;); console.log(&quot;number3 is a &quot; + PhoneNumber.test(number3) + &quot; phone number.&quot;);&#125;() regObj.exec(strObj)方法用于正则表达式模式在字符串中运行查找，如果 exec() 找到了匹配的文本，则返回一个结果数组。否则，返回 null。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。 调用非全局的 RegExp对象的 exec() 时，返回数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个分组相匹配的文本（如果有的话），第 2 个元素是与 RegExp对象的第 2 个分组相匹配的文本（如果有的话），以此类推。 调用全局的RegExp对象的 exec() 时，它会在 RegExp实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExp实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。1234567891011121314151617181920212223242526272829//无g标志var execs = function()&#123; var text = &quot;abababab&quot;; var pattern = /ab(ab)/; console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex);&#125;()//有g标志var execg = function()&#123; var text = &quot;AbAbBCAb&quot;; var pattern = /Ab|BC/g; //pattern.lastIndex = 1; //改变lastIndex属性 console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex); console.log(pattern.exec(text)); console.log(pattern.lastIndex);&#125;() 字符串方法strObj.search(RegObj)search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。没有匹配则返回-1。 12345678910var search = function()&#123; var text = &quot;asdfasAAAAAA&quot;; var pattern = /AA/g; var te = &quot;AA&quot; console.log(text.search(pattern)); console.log(text.indexOf(te)); var example = &quot;adfasd9ad1s1f&quot;; var pattern2 = /\d/g; console.log(example.charAt(example.search(pattern2)))；&#125;() strObj.match(RegObj)字符串对象的match方法与正则对象的exec方法比较类似，但是如果正则表达式带有g修饰符，那么match方法就可以以数组的方式返回所有成功匹配的结果，但是exec方法只返回了一个。如果不带g，则是返回其分组结果。 12345var match = function()&#123; var text=&quot;asdfasdasdfasdfadsf&quot; var pattern = /a(sd)/g; console.log(text.match(pattern))&#125;() strObj.replace(regObj,replaceStr|function(){})1stringObject.replace(regexp/substr,replacement) 字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 \$1、\$2、…、\$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 \$&amp; 与 regexp 相匹配的子串。 \$` 位于匹配子串左侧的文本。 \$’ 位于匹配子串右侧的文本。 \$$ 直接量符号。 注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。1234567891011121314//不使用正则var replace = function()&#123; var text = &apos;1&lt;%2%&gt;34&lt;%567%&gt;89&apos;; text = text.replace(&apos;&lt;&apos;,&apos;@&apos;); text = text.replace(&apos;%&apos;,&apos;#&apos;); text = text.replace(&apos;&gt;&apos;,&apos;@&apos;); console.log(text);&#125;()//使用正则var replace = function()&#123; var text = &apos;1&lt;%2%&gt;34&lt;%567%&gt;89&apos;; text = text.replace(/&lt;%(\d+)%&gt;/g,&apos;@#$1#@&apos;); console.log(text);&#125;() strObj.split(regObj)1stringObject.split(separator,howmany) 一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。返回的数组中的字串不包括 separator 自身。 但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。123456var split = function()&#123; text = &apos;a1b2c3d&apos; console.log(text.split(/\d/)); name = &quot;asfasdf,fadf./asdf.asdf[asdf&quot; console.log(name.split(/\W/));&#125;() 语法元字符( [ { \ ^ $ | ) ? * + . 预定义的特殊字符 字符 描述 \t 制表符 \n 换行符 \r 回车符 \f 换页符 \a alert字符 \e escape字符 \cX / 与X相对应的控制字符 \b 与回退字符 \v 垂直制表符 \0 空字符 分枝条件继续在分组上做文章。在分组中插入管道符（“|”），把它划分为两个或多个候多项。1234var reg = /(red|black|yellow)!!/;alert(reg.test(&quot;red!!&quot;))//truealert(reg.test(&quot;black!!&quot;))//truealert(reg.test(&quot;yellow!!&quot;))//true 边界一个要与字符类合用的东西。 边界|正则 |名称| 描述||—|—|—||^| 开头| 注意不能紧跟于左中括号的后面||$| 结尾||\b| 单词边界| 指[a-zA-Z_0-9]之外的字符||\B |非单词边界 |单词边界举例。要匹配的东西的前端或未端不能为英文字母阿拉伯字数字或下横线。12var str = &quot;12w-eefd&amp;efrew&quot;;alert(str.match(/\b\w+\b/g))//12w,eefd,efrew 字符类简单类原则上正则的一个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。如12345alert(/abc/.test(&quot;abc&quot;));//truealert(/[abc]/.test(&quot;a&quot;));//truealert(/[abc]/.test(&quot;b&quot;));//truealert(/[abc]/.test(&quot;c&quot;));//truealert(&quot;a bat ,a Cat,a fAt bat ,a faT cat&quot;.match(/[bcf]at/gi));//bat,Cat,fAt,bat,faT,cat 负向类在[]前面加个元字符^进行取反，表示匹配不能为括号里面的字符。1234alert(/[^abc]/.test(&quot;a&quot;));//falsealert(/[^abc]/.test(&quot;b&quot;));//falsealert(/[^abc]/.test(&quot;6&quot;));//truealert(/[^abc]/.test(&quot;gg&quot;));//true 范围类还是在那个中括号里面做文章。有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以用它。特征就是在中间加了个横线。12345alert(/[a-f]/.test(&quot;b&quot;));//truealert(/[a-f]/.test(&quot;g&quot;));//falsealert(/[a-z]/.test(&quot;h&quot;));//truealert(/[0-9]/.test(&quot;8&quot;));//truealert(/[0-9]/.test(&quot;a&quot;));//false 组合类中括号内可以组合使用不同类型的单个字符。1234567alert(/[^H-Y]/.test(&quot;G&quot;));//truealert(/[^7-9]/.test(&quot;6&quot;));//truealert(/[a-m1-5\n]/.test(&quot;a&quot;))//truealert(/[a-m1-5\n]/.test(&quot;3&quot;))//truealert(/[a-m1-5\n]/.test(&quot;\n&quot;))//truealert(/[a-m1-5\n]/.test(&quot;r&quot;))//false 预定义类使用反义字符代替某些常用的组合集 字符 等同于 描述 . [^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [ \t\n\x0B\f\r] 空白字符 \S [^ \t\n\x0B\f\r] 非空白字符 \w [a-zA-Z_0-9] 单词字符(所有的字母) \W [^a-zA-Z_0-9] 非单词字符 量词（限定符） 代码 描述 ? 出现零次或一次 * 出现零次或多次(任意次) + 出现一次或多次（至少一次） {n} 对应零次或者n次 {n,m} 至少出现n次但不超过m次 {n,} 至少出现n次(+的升级版) 1234567891011alert(/...../.test(&quot;正则表达式&quot;))//truealert(/正则表达式/.test(&quot;正则表达式&quot;))//truealert(/[\u4e00-\u9fa5]&#123;5&#125;/.test(&quot;正则表达式&quot;))//truealert(/[\u4e00-\u9fa5]&#123;4&#125;/.test(&quot;正则表达式55&quot;))//truealert(/^[\u4e00-\u9fa5]+$/.test(&quot;正则表达式&quot;))//truealert(/^[\u4e00-\u9fa5]+$/.test(&quot;正则表达式#&quot;)) //falsealert(/\d&#123;6&#125;/.test(&quot;123456&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;ee&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;ex&quot;))//truealert(/[regx]&#123;2&#125;/.test(&quot;xx&quot;))//true 1/[\u4e00-\u9fa5]/ //用于匹配单个汉字。这两个unicode值正好是Unicode表中的汉字的头和尾。 贪婪量词，懒惰量词与支配性量词贪婪量词: 当正则表达式中包含能接受重复量词时，默认的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。1alert(&quot;aabab&quot;.match(/a.*b/g))//aabab 懒惰量词:在量词后加？，也就是匹配尽可能少的字符。其工作方式与贪婪量词相反。123alert(&quot;abaab&quot;.match(/a.*?b/g))//为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。 表5.懒惰限定符|代码| 描述||—|—||*? |重复任意次，但尽可能少重复||+?| 重复1次或更多次，但尽可能少重复||??| 重复0次或1次，但尽可能少重复||{n,m}?| 重复n到m次，但尽可能少重复||{n,}? |重复n次以上，但尽可能少重复| 支配性量词，在简单量词后加+。支配性量词只尝试一次。但是javascript不支持。 分组到目前为止，我们接触到中括号表示范围内选择，大括号表示重复。小括号就可以表示分组，用作多字符的重复。 123456789//分组+量词alert(/(dog)&#123;2&#125;/.test(&quot;dogdog&quot;))//true//分组+范围alert(&quot;baddad&quot;.match(/([bd]ad?)*?/g))//baddad,dad//分组+分组alert(&quot;mon and dad&quot;.match(/(mon( and dad)?)/))//mon and dad,mon and dad, and dad//man and dad 是符合正则模式的，而 and dad 是正则的一个分组] 捕获性分组所有分组默认都是捕获性分组，当使用match或者exec方法不带全局属性的时候，就可以在返回数组的第1位开始捕获到符合分组的内容。123456789101112131415161718192021222324 var reg = /test(\d+)/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;001&quot;, index: 0, input: &quot;test001&quot;] var reg = /test(\d+)/g; var str = &apos;test001 test002&apos;; console.log(str.match(reg)); //[&quot;test001&quot;, &quot;test002&quot;] var reg = /test(\d)+/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;1&quot;, index: 0, input: &quot;test001&quot;] var reg = /test(\d)+/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test001&quot;, &quot;1&quot;, index: 0, input: &quot;test001&quot;]var reg = /test(\d)+?/; var str = &apos;test001 test002&apos;; console.log(str.match(reg));//[&quot;test0&quot;, &quot;0&quot;, index: 0, input: &quot;test001&quot;] 反向引用反向引用标识由正则表达式中的匹配组捕获性分组。每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法进行引用。（MDN不推荐使用）123456789var color = &quot;#990000&quot;;/#(\d+)/.test(color);alert(RegExp.$1);//990000 alert(/(dog)\1/.test(&quot;dogdog&quot;))//true var num = &quot;1234 5678&quot;;var newNum = num.replace(/(\d&#123;4&#125;) (\d&#123;4&#125;)/,&quot;$2 $1&quot;);alert(newNum) 你也可以自己指定分组的组名。要指定一个分组的组名，请使用这样的语法：(?&lt; name &gt;exp)这样就把这部分表达式的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\${name}来调用匹配到的内容 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：|代码| 说明||—|—||(exp) |匹配exp,并捕获文本到自动命名的组里||(?&lt; name >exp)| 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)||(?:exp)| 匹配exp,不捕获匹配的文本，也不给此分组分配组号| 非捕获性分组并不是所有分组都能创建反向引用，有一种特别的分组称之为非捕获性分组，它是不会创建反向引用。反之，就是捕获性分组。要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号就行了。使用match、exec方法的时候就不会捕获到分组的内容。1234var reg = /test(?:\d)+/; var str = &apos;test001&apos;; console.log(str.match(reg));//[&quot;test001&quot;, index: 0, input: &quot;test001&quot;] 零宽断言 正则 名称 描述 (?=exp) 正向前瞻 匹配exp前面的位置 (?!exp) 负向前瞻 匹配后面不是exp的位置 (?&lt;=exp) 正向后瞻 匹配exp后面的位置 JavaScript不支持 (?&lt;!exp) 负向后瞻 匹配前面不是exp的位置 JavaScript不支持 正向前瞻用来检查接下来的出现的是不是某个特定的字符集。而负向前瞻则是检查接下来的不应该出现的特定字符串集。零宽断言是不会被捕获的。 123456789101112var str1 = &quot;bedroom&quot;;var str2 = &quot;bedding&quot;;var reBed = /(bed(?=room))///在我们捕获bed这个字符串时，抢先去看接下来的字符串是不是roomalert(reBed.test(str1));//truealert(RegExp.$1)//bedalert(RegExp.$2 === &quot;&quot;)//truealert(reBed.test(str2))//falsevar str1 = &quot;bedroom&quot;;var str2 = &quot;bedding&quot;;var reBed = /(bed(?!room))/ //要来它后面不能是roomalert(reBed.test(str1))//falsealert(reBed.test(str2))//true 小练习检验QQ号码： [1-9][0-9]{4,14} 手机号码：^(13[0-9]|14[57]|15[0-35-9]|18[0-35-9])\d{8}$ 身份证：^([0-9]){7,18}(x|X)?$ 密码：^[a-zA-Z]\w{5,17}$ 字母开头，长度在6~18之间，只能包含字母、数字和下划线 强密码：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间电话号码验证码/^[a-zA-z0-9]{4}$]/IP地址邮箱网址 单词首字母大写1234567var a = &quot;asdf&quot;; String.prototype.capitalize = function () &#123; return this.replace(/^\w/, function (s) &#123; return s.toUpperCase(); &#125;); &#125;alert(a.capitalize())//Asdf 12345678910111213var replace = function()&#123; var text = &quot;javascript Tutorial&quot;; console.log(text.replace(/\S/ig, &apos;($&amp;)&apos;));&#125;() var replace = function()&#123; var name = &quot;Doe, John&quot;; console.log(name.replace(/(\w+)\s*, \s*(\w+)/, &quot;$2 $1&quot;)); var str = &apos;aaa bbb ccc&apos;; console.log(str.replace(/\b\w+\b/g, function(word)&#123; return word.substring(0,1).toUpperCase()+word.substring(1);&#125; )) &#125;() 月日年变日月年12345&quot;04-22-2018&quot;.replace(/(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)-(?&lt;year&gt;\d&#123;4&#125;)/, (...args) =&gt; &#123; const groups = args.slice(-1)[0] const &#123;day, month, year&#125; = groups return `$&#123;day&#125;-$&#123;month&#125;-$&#123;year&#125;`&#125;) // &quot;25-04-2017&quot; 题目，移除所有标签，只留下innerText!123var html = &quot;&lt;p&gt;&lt;a href=&apos;http://www.cnblogs.com/rubylouvre/&apos;&gt;Ruby Louvre&lt;/a&gt;by &lt;em&gt;正则表达式&lt;/em&gt;&lt;/p&gt;&quot;;var text = html.replace(/&lt;(.|\s)*?&gt;/g, &quot;&quot;);alert(text)//Ruby Louvreby 正则表达式 官方教程微软：.NET 正则表达式MSDNW3CSCHOOL 正则表达式基本语法 参考资料正则表达式30分钟入门教程JavaScript 正则表达式上——基本语法JavaScript正则表达式下——相关方法js正则表达式/replace替换变量方法65条最常用正则表达式 你要的都在这里了JavaScript replace() 方法JavaScript split() 方法、javascript正则表达式JS 正则中的命名捕获分组javascript正则表达式中分组详解pattern–HTML5的表单验证属性]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种方式进行网页布局]]></title>
    <url>%2F2018%2F05%2F03%2Flayouts%2F</url>
    <content type="text"><![CDATA[网页布局 静态布局意思就是只是针对某个屏幕下设计的网页，当屏幕大小改变时，页面布局不会发生变化，就像经常所看到的滚动条。 自适应布局特点是分别为不同的屏幕设置布局格式，当屏幕大小改变时，会出现不同的布局，意思就是在这个屏幕下这个元素块在这个地方，但是在那个屏幕下，这个元素块又会出现在那个地方。只是布局改变，元素不变。可以看成是不同屏幕下由多个静态布局组成的。 使用了媒体查询1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 流式布局特点是随着屏幕的改变，页面的布局没有发生大的变化，可以进行适配调整，这个正好与自适应布局相补。 PC端常见布局 浮动布局floatBFC 即 Block Formatting Contexts (块级格式化上下文)Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 特性 同一个 BFC 下外边距会发生折叠 BFC 可以包含浮动的元素（清除浮动，使浮动在BFC盒子内） BFC 可以阻止元素被浮动元素覆盖（清除浮动，BFC盒子内不受外部浮动影响） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;float&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .float .left&#123; width:300px; float:left; &#125; .float .right&#123; width:25%; float:right; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;float&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;FL&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;FR&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;FM&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位布局position123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;position&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .position .left&#123; width:300px; position: absolute; left:8px; &#125; .position .right&#123; width:25%; position: absolute; right:8px; &#125; .position .mid&#123; margin:0 25% 0 300px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;position&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;PL&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;PR&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;PM&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 表格布局table缺点： table比其它html标记占更多的字节。(造成下载时间延迟,占用服务器更多流量资源) table会阻挡浏览器渲染引擎的渲染顺序。(会延迟页面的生成速度,让用户等待更久的时间) table里显示图片时需要你把单个、有逻辑性的的图片切成多个图。(增加设计的复杂度,增加页面加载时间,增加http会话数) 在某些浏览器中,table里的文字的拷贝会出现问题。(会让用户不悦) table会影响其内部的某些布局属性的生效(比如里的元素的height:100%) (限制页面设计的自由性) 一旦学了CSS的知识,你会发现使用table做页面布局会变得更麻烦。(先花时间学一些CSS知识,会省去你以后大量的时间) ‘table对’对于页面布局来说,从语义上看是不正确的。(它描述的是表现,而不是内容) table代码会让阅读者抓狂。(不但无法利用CSS,而且会不知所云,尤其在进行页面改版或内容抽取的时候) table一旦设计完成就变成死的,很难通过CSS让它展现新的面貌。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;table&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; table&#123; width:100%; &#125; table .left&#123; width:300px; &#125; table .mid&#123; margin:0 25%; &#125; table .right&#123; width:25%; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;top&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;left&quot;&gt;TL&lt;/td&gt; &lt;td class=&quot;mid&quot;&gt;TM&lt;/td&gt; &lt;td class=&quot;right&quot;&gt;TR&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;bottom&quot; colspan=&quot;3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 弹性布局flex弹性布局重点在单一横排和单一竖排的样式应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;flex&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .flex&#123; display:flex; flex-direction: column; &#125; .flex .top,.flex .bottom&#123; flex:1; &#125; .flex .main&#123; display: flex; &#125; .flex .mid&#123; flex:1; &#125; .flex .left&#123; width:300px; min-width: 100px; &#125; .flex .right&#123; width:25%; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;left&quot;&gt;FL&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;FM&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;FR&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 网格布局gridgrid-area是应用的重点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;grid&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: black; &#125; .left&#123; height:300px; background-color:red; &#125; .right&#123; height:300px; background-color:yellow; &#125; .mid&#123; height:300px; background-color:blue; &#125; .top&#123; height:300px; background-color:green; &#125; .bottom&#123; height:300px; background-color:purple; &#125; .top&#123; grid-area: top; &#125; .left&#123; grid-area: left; &#125; .mid&#123; grid-area: mid; &#125; .right&#123; grid-area: right; &#125; .bottom&#123; grid-area: bottom; &#125; .grid&#123; display: grid; grid-template-columns: 300px 3fr 1fr; grid-template-rows:auto; grid-template-areas: &quot;top top top&quot; &quot;left mid right&quot; &quot;bottom bottom bottom&quot; ; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div class=&quot;grid&quot;&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;GL&lt;/div&gt; &lt;div class=&quot;mid&quot;&gt;GM&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;GR&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局就是分别为不同的屏幕设计的布局方式，可以理解成自适应布局和流程布局的结合。 媒体查询+各类流式布局 12@media (max-width: 1200px) &#123;&#125; 在响应式编程中，比较难处理的就是图片。需要针对不同设备的分辨率进行适配，同时要保持较好的兼容性。在处理图片时，有以下的小技巧： 为图像使用相对尺寸，防止它们意外溢出容器。 如果您要根据设备特性（亦称艺术指导）指定不同图像，则使用 picture 元素。 在 img 元素中使用 srcset 及 x 描述符，引导浏览器从不同密度图像中选择、使用最佳的一张。 如果您的页面仅有一两个图像，且这些图像没有在您的网站上的其他地方使用，可考虑使用内联图像以减少文件请求。 我们一个一个来说这些技巧。首先是为图像使用相对尺寸，跟前面的为元素使用相对尺寸一样，防止在小屏幕设备上溢出容器，可以使用 max-width: 100% 来保证图像及其他内容不会从父容器上溢出。同时，为了提高可访问性，需要为img元素添加有意义的alt描述。 其次是img元素的srcset属性，这个属性非常有用，可以针对不同设备特性提供多种图片文件。如果浏览器支持srcset属性，则会在进行任何请求之前对逗号分隔的图像/条件列表进行解析，并且只会下载和显示最合适的图像。在使用时，为了能够兼容不支持srcset属性的浏览器，还需要为img元素指定src。就像下面这样：1&lt;img src=&quot;lighthouse.jpg&quot;srcset=&quot;lighthouse.jpg , lighthouse-2x.jpg 2x&quot;&gt; 另一个很有用的元素是picture，其能根据设备特性更改图像，picture元素定义了一个声明性解决办法，可根据设备大小、设备分辨率、屏幕方向等不同特性来提供一个图像的多个版本，就像video元素一样，可以指定多个源。为了保持兼容以及默认的情况，还可以在picture元素里面嵌套img，非常好用。12345&lt;picture&gt; &lt;source media=&quot;(min-width: 800px)&quot; srcset=&quot;head.jpg, head-2x.jpg 2x&quot;&gt; &lt;source media=&quot;(min-width: 450px)&quot; srcset=&quot;head-small.jpg, head-small-2x.jpg 2x&quot;&gt; &lt;img src=&quot;head-fb.jpg&quot; srcset=&quot;head-fb-2x.jpg 2x&quot; alt=&quot;a head carved out of wood&quot;&gt;&lt;/picture&gt; 同时，在处理图片时，为了减少请求，我们还可以内联图片资源。常见的方案是base64及内联SVG，内联SVG除了能够减少请求外，还能够保持页面缩放时，图片不失真。]]></content>
      <categories>
        <category>FrontEnd</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git入门]]></title>
    <url>%2F2017%2F12%2F16%2Fgit%2F</url>
    <content type="text"><![CDATA[Git入门 关于版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 本地版本控制系统文件夹备份法。复制整个项目目录来保存不同的版本，或许还会改名加上备份时间以示区别。 其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中化的版本控制系统（Centralized Version Control Systems）使用一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 这类系统，常见的有 CVS、Subversion 以及 Perforce 等，优点是有完善的权限系统，以及统一的服务端，适合商业软件的开发。缺点是如果出现中央服务器的单点故障，会有所有人无法工作甚至丢失文件的风险。 分布式版本控制系统(Distributed Version Control System)客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 在这类系统中，像 Git、Mercurial、Bazaar、BitKeeper 以及 Darcs 等，它们相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只有需要不同开发者合并代码时，才需要一个中转站来完成。 集成管理者工作流Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表`‘官方’’项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。 这一流程的工作方式如下所示 项目维护者推送到主仓库。 贡献者克隆此仓库，做出修改。 贡献者将数据推送到自己的公开仓库。 贡献者给维护者发送邮件，请求拉取自己的更新。 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。 维护者将合并后的修改推送到主仓库。 什么是GitGit是目前世界上最先进的分布式版本控制系统。最初由Linus Torvalds编写，用作Linux内核代码的管理。 直接记录快照，而非差异比较 Git 对待数据更像是一个 快照流。这是 Git 与几乎所有其它版本控制系统的重要区别。 近乎所有操作都是本地执行Git 保证完整性Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git 一般只添加数据所有Git 操作，几乎只往 Git 数据库中增加数据。以删除数据为例，删除一个文件只会是这次提交的版本中没有这个文件的快照，不会删除前几个版本中的这个文件。 三种状态已提交（committed）、已修改（modified）和已暂存（staged） 什么是githubgithub是一个用git做版本控制系统的项目托管平台。 github上常见用语Version Control（版本控制）: 任何一个能够让你了解文件的历史，以及该文件的发展进程的系统。Git：一个版本控制程序，通过对变更进行注释，以创建一个易于遍历的系统历史。Commit（提交）：在指定时间点对系统差异进行的注释 “快照”。Local（本地）：指任意时刻工作时正在使用的电脑。Remote（远程）： 指某个联网的位置。Repository (仓库，简称 repo)：配置了Git超级权限的特定文件夹，包含了你的项目或系统相关的所有文件。Github：获取本地提交历史记录，并进行远程存储，以便你可以从任何计算机访问这些记录。Pushing（推送）：取得本地Git提交（以及相关的所有工作），然后将其上传到在线Github。Pulling（拉取）：从在线的Github上获取最新的提交记录，然后合并到本地电脑上。Master (branch)：主分支，提交历史 “树”的 “树干”，包含所有已审核的内容/代码。Feature branch（功能分支/特性分支）：一个基于主分支的独立的位置，在再次并入到主分支之前，你可以在这里安全地写工作中的新任务。Pull Request（发布请求）：一个 Github 工具，允许用户轻松地查看某功能分支的更改 （the difference或 “diff”），同时允许用户在该分支合并到主分支之前对其进行讨论和调整。Merging（合并）：该操作指获取功能分支的提交，加入到主分支提交历史的顶部。Checking out（切换）：该操作指从一个分支切换到另一个分支。 一、基本操作1.设置用户信息 $ git config –global user.name “用户名” $ git config –global user.email “用户邮箱” 当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： 再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 很多 GUI 工具都会在第一次运行时帮助你配置这些信息。 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 $ git config –listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto… 你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 git config ： 来检查 Git 的某一项配置 $ git config user.nameJohn Doe 2.建库 $ git init 3.提交 $ git add 文件名 文件名 文件名 —&gt;从工作区提交文件到暂存区 $ git commit -m “更改说明” —&gt;从暂存区提交修改到版本库 4.查看 $ git status —&gt;查看仓库状态 $ git diff 文件名 —&gt;查看修改内容 $ git log —&gt;查看提交日志 查看日志具体信息[https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2] $ git reflog —&gt;查看命令日志 5.回退 $ git reset –hard HEAD^ —&gt;回到上次修改 $ git reset –hard commit_id —&gt;回到任意版本(提交码取前面7位就够了) 6.撤销 $ git checkout –文件名 —&gt;把版本库中的文件替换当前文件，撤销所有未add修改 $ git reset HEAD 文件名 —&gt;把上一次add撤销 7.删除 $ git rm 文件名 —&gt;从版本库中删除文件 $ git commit -m “更改说明” —&gt;删除也是需要提交的修改 $ git checkout –文件名 —&gt;把版本库中的文件替换当前文件，误删恢复 8.移动 git mv file_from file_to 二、标签先切换到需要打标签的分支上 $ git tag 标签名字 查看所有标签 $ git tag 给历史提交打标签 $ git tag 标签名字 commit_id 显示标签分支的信息 $ git show 标签名字 还可以通过-s用私钥签名一个标签： $ git tag -s v0.2 -m “signed version 0.2 released” fec145a 如果标签打错了，也可以删除 $ git tag -d 标签名字 因为创建的标签都只存储在本地，不会自动推送到远程。如果要推送某个标签到远程，使用命令 $ git push origin 标签名 一次性推送全部尚未推送到远程的本地标签 $ git push origin –tags 三、远程仓库1. 创建SSH Key $ ssh-keygen -t rsa -C “用户邮箱” 可在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 2. 绑定GitHub登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 3. 绑定库在GitHub上创建一个新库之后，本地用git上传内容 $ git remote add origin git@github.com:GitHub用户名/库名.git 添加上游 $git remote add upstream https://github.com/GitHub用户名/库名.git 查看远程库的信息 $ git remote -v 4.推送本地库内容把本地库的内容推送到远程，用git push命令把当前分支master推送到远程。 $ git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。 5.克隆远程库内容 $ git clone git@github.com:GitHub用户名/库名.git (文件名) 6.抓取远程库内容 $ git fetch 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 四、分支管理master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b dev 命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev $ git checkout dev 查看所有分支(当前分支前面会标一个*号) $ git branch 切换回master分支： $ git checkout master 把dev分支的工作成果合并到当前分支上： $ git merge -m “合并说明” dev 删除dev分支 $ git branch -d dev 查看分支合并图 $ git log –graph 以图形化的方式展现提交的日志 $gitk 暂时分支（当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。） $ git stash —&gt;创建暂时分支保存当前工作区内容 $ git stash apply —&gt;恢复暂时分支 $ git stash drop —&gt;删除暂时分支 $ git stash pop —&gt;恢复并删除暂时分支 $ git stash list —&gt;查看所有暂时分支 参考资料http://blog.jobbole.com/111187/https://zhuanlan.zhihu.com/p/45724857]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
